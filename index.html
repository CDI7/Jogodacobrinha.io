<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Jogo da Cobrinha</title>
<link rel="icon" type="image/png" href="https://i.imgur.com/Y0hwK0g.png">
<style>
        /* --- GERAL & RESET --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1d2d 0%, #11131e 100%);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            touch-action: none;
            user-select: none;
            overflow: hidden;
        }

        /* --- CONTAINER PRINCIPAL --- */
        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            border-radius: 24px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 95%;
            max-width: 400px;
            max-height: 95vh;
            overflow-y: auto;
        }
        /* Custom scrollbar for webkit browsers */
        .game-container::-webkit-scrollbar {
            width: 5px;
        }
        .game-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        .game-container::-webkit-scrollbar-track {
            background: transparent;
        }
/* Botão de configurações do painel PvP */
.settings-btn-pvp {
    position: absolute;
    top: 15px;
    right: 15px;
    z-index: 2650; /* Garante que fique acima do conteúdo pvp, mas abaixo do modal */
    background: transparent;
    border: none;
    outline: none;
    width: 35px;
    height: 35px;
    border-radius: 50%;
    font-size: 20px;
    cursor: pointer;
    color: white;
    display: flex;
    justify-content: center;
    align-items: center;
    transition: all 0.2s ease;
}

.settings-btn-pvp:hover {
    background: rgba(255, 255, 255, 0.2);
    transform: rotate(45deg);
}

/* Garante que o painel de configurações pvp fique escondido por padrão */
#pvpSettingsPanel {
    display: none;
}

        /* --- TIPOGRAFIA --- */
        .main-title {
            font-size: 2.5em;
            color: #ffffff;
            font-weight: 700;
            margin-bottom: 3px;
        }

        .login-logo {
            width: 120px; /* Ajuste a largura conforme necessário */
            height: auto;
            margin-bottom: 15px;
        }
        
        .leaderboard-logo {
            width: 50px; /* Ajuste o tamanho conforme preferir */
            height: auto;
            margin-bottom: 10px;
        }

        h1, h2, h3, h4 {
            color: #ffffff;
            margin-bottom: 15px;
            font-weight: 600;
        }

        p, label {
            color: #d1d1d1;
            font-size: 14px;
        }

        a {
            color: #4a72ff;
            text-decoration: none;
            font-weight: 600;
        }

        a:hover {
            text-decoration: underline;
        }
        
        .selection-title {
            color: #ffffff;
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: 500;
            width: 100%;
            text-align: center;
        }

        /* --- BOTÕES --- */
        .btn {
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            cursor: pointer;
            padding: 12px 24px;
            transition: all 0.2s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-weight: 600;
        }

        .btn-primary {
            background-color: #4a72ff;
            box-shadow: 0 4px 15px rgba(74, 114, 255, 0.2);
        }

        .btn-primary:hover {
            background-color: #5a82ff;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 114, 255, 0.3);
        }

        .btn-primary:active {
            transform: scale(0.98);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .btn-danger {
            background: #d63031;
        }
        .btn-danger:hover {
            background: #e17055;
        }

        .start-btn {
            width: 100%;
            margin-bottom: 20px;
        }

        .restart-btn {
            margin-top: 15px;
        }

        /* --- FORMULÁRIOS E INPUTS --- */
        .name-input, #skinSelector, #supportType, #supportMessage {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            color: white;
            font-size: 16px;
            text-align: center;
            margin-bottom: 10px;
            width: 100%;
            transition: border-color 0.2s, background-color 0.2s;
        }
        #skinSelector, #supportType {
            text-align: left; /* Alinha o texto do select à esquerda */
            -webkit-appearance: none; /* Remove a aparência padrão no Chrome/Safari */
            -moz-appearance: none; /* Remove a aparência padrão no Firefox */
            appearance: none; /* Remove a aparência padrão */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22/%3E%3C/svg%3E');
            background-repeat: no-repeat;
            background-position: right 12px top 50%;
            background-size: .65em auto;
            padding-right: 30px; /* Espaço para a seta */
        }
        #skinSelector option, #supportType option {
            background-color: #1a1d2d;
            color: white;
        }
        
        .name-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
            text-transform: none;
        }

        .name-input:focus, #skinSelector:focus, #supportType:focus, #supportMessage:focus {
            outline: none;
            border-color: #4a72ff;
            background-color: rgba(0, 0, 0, 0.3);
        }


        /* --- TELA PRINCIPAL DO JOGO --- */
        #mainGame { display: none; position: relative; }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            background: #11131e;
            width: 100%;
            max-width: 360px;
            height: auto;
            margin: 15px 0;
        }

        .player-score-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            margin-top: 15px;
            padding: 0 5px;
            font-size: 16px;
            color: white;
        }

        .current-difficulty {
            color: white;
            font-size: 14px;
            margin-top: 10px;
            opacity: 0.8;
        }

        /* --- LEADERBOARD --- */
        .leaderboard {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
            color: white;
            position: relative; /* Adicionado para posicionamento absoluto do personal-record */
        }
        .leaderboard h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 5px 0;
            padding: 8px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.1);
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .leaderboard-difficulty {
            font-size: 12px;
            opacity: 0.8;
            margin-left: 8px;
        }

        /* Estilo para o recorde pessoal */
        .personal-record {
            text-align: left;
            color: #ffffff; /* Cor branca para o texto */
            font-size: 11px;
            font-weight: 500;
            margin-bottom: 10px; /* Espaçamento abaixo */
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 3px;
            /* Posicionamento para ficar à esquerda do TOP 3 */
            position: absolute;
            top: 100px; /* Ajuste conforme a altura da logo e do h3 */
            left: 20px; /* Ajuste para espaçamento da borda */
            transform: translateY(-50%); /* Centraliza verticalmente com o TOP 3 se necessário */
            white-space: nowrap; /* Impede quebra de linha */
            background: transparent; /* Sem fundo */
            padding: 0; /* Sem padding */
        }
        .personal-record strong {
            color: #ffffff; /* Cor branca para o valor do recorde */
            font-weight: 500; /* Mantém o mesmo peso da fonte do texto normal */
        }
        .leaderboard-logo + .personal-record { /* Ajuste de posição quando a logo está presente */
            top: 105px; /* Ajuste para ficar abaixo da logo */
        }
        .leaderboard h3 {
             /* Ajusta margem para dar espaço ao recorde pessoal */
            margin-top: 5px; 
            text-align: center;
        }


        /* --- SELEÇÃO DE DIFICULDADE E MAPA --- */
        .difficulty-selection, .map-selection {
            display: flex;
            justify-content: center;
            gap: 8px;
        }
        
        .difficulty-selection {
            flex-wrap: nowrap;
            overflow-x: auto;
            padding-bottom: 5px;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .difficulty-selection::-webkit-scrollbar {
            display: none;
        }
        
        .map-selection {
             flex-wrap: wrap;
        }

        .difficulty-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid transparent;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            padding: 5px;
            transition: all 0.2s ease;
            flex-shrink: 0; 
            width: 68px;
            height: 68px;
            line-height: 1.3;
            text-align: center;
        }

        .difficulty-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .difficulty-btn.selected {
            background: #4a72ff;
            border-color: transparent;
            color: white;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(74, 114, 255, 0.3);
        }
        
        .difficulty-info {
            color: #d1d1d1;
            font-size: 12px;
            margin-top: 8px;
            width: 100%;
            text-align: center;
            min-height: 28px;
        }

        /* --- CONTROLES --- */
        .controls {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            width: 200px;
            height: 120px;
            margin-left: auto;
            margin-right: auto;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .control-btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.25);
        }
        .up { grid-column: 2; grid-row: 1; }
        .left { grid-column: 1; grid-row: 2; }
        .right { grid-column: 3; grid-row: 2; }
        .down { grid-column: 2; grid-row: 2; }

        .pause-btn, .quit-game-btn {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 14px;
        }
        #quitGameBtn { margin-left: 10px; }


        /* --- MODAIS E TELAS DE SOBREPOSIÇÃO (GAME OVER, PARABÉNS, INBOX) --- */
        .game-over, #congratulationsScreen {
    /* MUDANÇA: Posicionamento absoluto em relação ao pai (#mainGame) */
    position: absolute;
    top: 67%;
    left: 50%;
    transform: translate(-50%, -50%);

    /* MUDANÇA: Tamanho definido para se ajustar dentro do contêiner do jogo */
    width: 95%; 
    height: auto; /* A altura será automática com base no conteúdo */
    max-width: 350px;

    /* Estilos visuais mantidos e aprimorados */
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    background: rgba(26, 29, 45, 0.95); /* Fundo um pouco mais opaco */
    backdrop-filter: blur(8px);
    z-index: 2000;
    color: white;
    padding: 25px;
    border-radius: 16px; /* Borda arredondada para combinar com o canvas */
    border: 1px solid rgba(255, 255, 255, 0.1);
}

/* Regra separada para outros modais que precisam ocupar a tela inteira */
.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    display: none;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    text-align: center;
    background: rgba(26, 29, 45, 0.9);
    backdrop-filter: blur(5px);
    z-index: 2000;
    color: white;
    padding: 20px;
}
        .game-over h2, #congratulationsScreen h2, .modal-content h2 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        #congratulationsScreen h2 {
            text-shadow: 0 0 15px #FFD700;
            animation: congrats-pulse 1s infinite alternate;
        }
        @keyframes congrats-pulse {
            to { transform: scale(1.05); text-shadow: 0 0 25px #FFD700; }
        }

        /* --- CAIXA DE ENTRADA --- */
        .modal-content {
            background: #1a1d2d;
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            width: 100%;
            max-width: 380px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .inbox-list {
            overflow-y: auto;
            flex-grow: 1;
        }
        .inbox-message {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            text-align: left;
        }
        .inbox-message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .inbox-message-header span { font-size: 12px; opacity: 0.7; }
        .inbox-message p { font-size: 14px; color: #fff; white-space: pre-wrap; }
        .inbox-message button { font-size: 10px; padding: 4px 8px; }


        /* --- FOGOS DE ARTIFÍCIO --- */
        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            opacity: 1;
            animation: firework-explode 1.2s forwards;
        }
        @keyframes firework-explode {
            100% { transform: scale(30); opacity: 0; }
        }


        /* --- CONFIGURAÇÕES E ABAS --- */
        .settings-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        .settings-tabs::-webkit-scrollbar { display: none; }

        .tab-button {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.3s, border-bottom 0.3s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }
        .tab-button:hover { color: white; }
        .tab-button.selected {
            color: white;
            border-bottom: 3px solid #4a72ff;
            font-weight: 600;
        }

        .settings-tab-content { padding-top: 10px; text-align: left; }
        .settings-tab-content h4 { margin-top: 20px; margin-bottom: 10px; font-size: 16px; color: white; }
        .settings-tab-content label { display: block; margin-bottom: 8px; font-weight: 500; }
        .settings-tab-content input[type="color"], .settings-tab-content input[type="range"], .settings-tab-content select {
            width: 100%;
            padding: 5px;
            margin-bottom: 10px;
        }
        
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .setting-item label {
            margin-bottom: 0;
        }
        .setting-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }


        /* --- SELETOR DE IDIOMA --- */
        .language-selector {
            position: absolute;
            top: 28px;
            right: 90px;
            z-index: 1000;
        }
        .language-selector-button {
            background: rgba(255, 255, 255, 0.1);
            border: 0px solid rgba(255, 255, 255, 0.2);
            border-radius: 0px;
            padding: 0px;
            cursor: pointer;
            display: flex;
            align-items: center;
            width: 30px;
            height: 20px;
        }
        .language-selector-button img { width: 100%; border-radius: 4px; }
        .language-selector-dropdown {
            position: absolute;
            top: 110%;
            left: 0;
            background: #2a2d3d;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            z-index: 100;
            min-width: 120px;
            display: none;
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
        }
        .language-selector-dropdown.show { display: block; }
        .language-selector-option {
            padding: 8px 12px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        .language-selector-option:hover { background: #4a72ff; }
        .language-selector-option img { width: 24px; height: 16px; border-radius: 2px; }

        /* --- BOTÕES DE AÇÃO NO TOPO DA TELA DE JOGO --- */
        #logoutBtn, #settingsBtn, #inboxBtn {
            position: absolute;
            top: 17px;
            z-index: 1000;
            background: none;
            border: none;
            font-size: 25px;
            cursor: pointer;
            color: white;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        #logoutBtn:hover, #settingsBtn:hover, #inboxBtn:hover { opacity: 1; }
        #logoutBtn { left: 18px; font-size: 22px; }
        #inboxBtn { right: 52px; }
        #settingsBtn { right: 20px; }

        /* Notificação da caixa de entrada */
        #inboxNotification {
            position: absolute;
            top: -5px;
            right: -8px;
            background-color: #d63031;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: none;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }


        /* Estilo para o display de moedas totais */
        .total-coins-display {
            position: absolute;
            top: 50px; /* Ajuste conforme necessário para ficar abaixo dos botões */
            right: 20px;
            color: #FFD700; /* Cor dourada para as moedas */
            font-size: 0.7em;
            font-weight: bold;
            z-index: 999;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #skinPreviewCanvas {
            display: block;
            margin: 15px auto; /* Adiciona espaço e centraliza */
            background: #11131e; /* Mesmo fundo do canvas principal */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }
        /* --- ANÚNCIO GLOBAL --- */
        #globalAnnouncement {
            display: none;
            background-color: #4a72ff;
            color: white;
            padding: 8px;
            font-size: 12px;
            text-align: center;
            border-radius: 8px;
            margin: 0 auto 10px auto;
            max-width: 95%;
        }

        /* --- ESTILOS DO PAINEL DE ADMIN --- */
        #adminPanel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 29, 45, 0.95);
            backdrop-filter: blur(10px);
            z-index: 2500;
            color: white;
            display: none;
            flex-direction: column;
            padding: 20px;
        }

        .admin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .admin-header h2 {
            margin: 0;
        }

        .admin-content {
            flex-grow: 1;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
        }

        /* Custom scrollbar for admin panel content */
        .admin-content::-webkit-scrollbar {
            width: 5px;
        }
        .admin-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        .admin-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .admin-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap; /* Permite que as abas quebrem a linha em telas pequenas */
        }

        .admin-tab-button {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        .admin-tab-button:hover { color: white; }
        .admin-tab-button.selected {
            color: white;
            border-bottom-color: #e17055;
            font-weight: 600;
        }

        .admin-tab-content {
            display: none;
        }
        .admin-tab-content.active {
            display: block;
        }

        .stat-card {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            text-align: center;
        }
        .stat-card h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #d1d1d1;
        }
        .stat-card p {
            font-size: 24px;
            font-weight: bold;
            color: white;
        }
        /* Card de análise */
        .analytics-card {
            text-align: left;
            padding: 20px;
        }
        .analytics-card h4 {
            text-align: center;
            font-size: 16px;
            margin-bottom: 15px;
        }
        .analytics-card p {
            font-size: 16px;
            font-weight: normal;
            display: flex;
            justify-content: space-between;
        }
        .analytics-card p strong {
            font-weight: 600;
            color: #e17055;
        }
        
        /* Gráfico de Barras */
        .bar-chart-container { margin-top: 20px; }
        .bar-chart-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .bar-chart-label { width: 80px; flex-shrink: 0; }
        .bar-chart-bar-bg {
            flex-grow: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            height: 20px;
            overflow: hidden;
        }
        .bar-chart-bar {
            background-color: #4a72ff;
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease-out;
        }
        .bar-chart-value { margin-left: 10px; font-weight: bold; }


        .admin-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .admin-table th, .admin-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .admin-table th {
            color: #d1d1d1;
            font-weight: 600;
        }
        .admin-table td .btn {
            font-size: 10px;
            padding: 4px 8px;
        }

        .filter-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        /* Modal de Edição de Usuário */
        .edit-user-modal {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            padding: 20px;
        }
        .edit-user-modal-content {
            background: #1a1d2d;
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            width: 100%;
            max-width: 350px;
            text-align: left;
        }
        .edit-user-modal-content h3 {
            margin-top: 0;
            text-align: center;
        }
        .edit-user-modal-content label {
            margin-top: 10px;
        }
        .edit-user-modal-content .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .edit-user-modal-content .btn {
            width: 100%;
        }

        /* --- ESTILOS DO PAINEL PVP (ATUALIZADO) --- */
        #pvpPanel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 29, 45, 0.98); /* Fundo mais opaco */
            backdrop-filter: blur(10px);
            z-index: 2600;
            color: white;
            display: none;
            justify-content: center;
            align-items: center;
            padding: 10px;
            box-sizing: border-box;
        }

.pvp-content {
    width: 95%;
    max-width: 500px;
    max-height: 100%;
    overflow-y: hidden;
    overflow-x: hidden; 
    display: flex;
    flex-direction: column;
    justify-content: center; 
    align-items: center;
    gap: 2px;
    padding: 5px 0;
}

        .pvp-content::-webkit-scrollbar {
            width: 5px;
        }
        .pvp-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        .pvp-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .opponent-view, .local-player-view {
            width: 100%;
            max-width: 480px;
            text-align: center;
            position: relative; 
        }

        #opponentCanvas, #localPlayerPvPCanvas {
    border-radius: 12px;
    background: #11131e;
    width: 100%; /* ALTERADO: Para ser flexível */
    height: auto; /* ALTERADO: Para manter a proporção automaticamente */
    max-width: 480px; /* Adicionado: Define o tamanho máximo que ele pode atingir */
    margin: 0 auto;
}

        #opponentCanvas {
            border: 3px solid #d63031; /* Borda vermelha */            
        }

        #localPlayerPvPCanvas {
            border: 3px solid #4a72ff; /* Borda azul */
        }

        .opponent-overlay {
    position: absolute;
    /* Ajuste de posição e tamanho */
    width: calc(100% - 6px); /* Subtrai a largura da borda (3px de cada lado) */
    height: calc(100% - 6px); /* Subtrai a altura da borda (3px de cada lado) */
    top: 3px;
    left: 3px;
    transform: none; /* Remove a transformação anterior */
    /* Estilos existentes */
    max-width: 480px;
    background: rgba(0, 0, 0, 0.5);
    border-radius: 10px; /* Um raio um pouco menor para encaixar melhor */
    display: flex;
    flex-direction: column;
    gap: 15px;
    justify-content: center;
    align-items: center;
}
/* Adicione esta regra para corrigir o problema do modal fantasma */
#quitConfirmModal {
    z-index: 2100; /* Um valor maior que o da tela de Game Over (2000) */
}
.wait-time-display {
    color: white;
    font-size: 14px;
    font-weight: 500;
    background: rgba(0, 0, 0, 0.4);
    padding: 8px 15px;
    border-radius: 10px;
    border: 1px solid rgba(255, 255, 255, 0.1);
}
        #searchMatchBtn {
            width: 80%;
            max-width: 250px;
        }
        
        .close-pvp-btn {
            position: absolute;
            top: 15px;
            left: 15px;
            width: 30px;
            height: 30px;
            background: #d63031;
            color: white;
            border: 2px solid #1a1d2d;
            border-radius: 50%;
            font-size: 20px;
            font-weight: bold;
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            line-height: 1;
            padding: 0;
            z-index: 10;
        }
        .close-pvp-btn:hover {
            background: #e17055;
        }

        #pvpGameControls {
   margin-top: 5px;
   flex-shrink: 0;
}
/* Estilos para a área de informação da partida PvP */
.pvp-match-info {
    position: relative;
    width: 100%;
    margin: 0;
    text-align: center;
}

/* Estilo para o cronômetro principal do jogo (03:00) */
#pvpGameTimer {
    font-size: 16px; /* REDUZIDO */
    font-weight: bold;
    color: #FFD700; 
    background: rgba(0,0,0,0.3);
    padding: 3px 10px; /* REDUZIDO */
    border-radius: 8px;
    display: inline-block;
    visibility: hidden;
}

/* Estilo para a contagem regressiva (5, 4, 3...) */
#pvpCountdown {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 80px;
    font-weight: 900;
    color: white;
    text-shadow: 0 0 20px rgba(0,0,0,0.7);
    z-index: 50;
    display: none;
    animation: countdown-pulse 1s infinite;
}
/* Estilo para os novos placares do PvP */
.pvp-score-display {
    color: white;
    font-size: 16px;
    font-weight: 500;
    margin-top: 0px; /* Adiciona espaço acima do placar */
    text-align: center;
}

/* Exceção para o placar do OPONENTE ficar acima do mapa */
#localScoreDisplay {
    color: white;
    font-size: 16px;
    font-weight: 500;
    margin-top: 8px;
    text-align: center;
}

/* Estilo para o placar do OPONENTE (agora flutuando sobre o mapa) */
#opponentScoreDisplay {
    position: absolute;  /* Tira o elemento do fluxo normal */
    top: 10px;           /* Distância do topo do container pai */
    left: 0;
    right: 0;
    z-index: 10;         /* Garante que fique visível */
    
    color: white;
    font-size: 16px;
    font-weight: 500;
    text-align: center;
}
#sabotageControls {
    display: flex;
    justify-content: flex-end; /* Alinha à direita */
    gap: 8px;
    padding: 5px 10px 0 0; /* Espaçamento */
    height: 40px; /* Altura fixa para evitar que o layout pule */
}

.sabotage-btn {
    width: 35px;
    height: 35px;
    font-size: 20px; /* Tamanho do emoji */
    border-radius: 8px;
    border: 1px solid rgba(255, 255, 255, 0.2);
    background: rgba(255, 255, 255, 0.1);
    color: white;
    cursor: pointer;
    transition: all 0.2s ease;
}

.sabotage-btn:hover:not(:disabled) {
    background: rgba(255, 255, 255, 0.2);
    transform: scale(1.05);
}

.sabotage-btn:disabled {
    opacity: 0.3;
    cursor: not-allowed;
    transform: none;
}
#sabotage-feedback {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 80px;
    color: white;
    text-shadow: 0 0 15px rgba(0,0,0,0.8);
    opacity: 0;
    pointer-events: none; /* Impede que o emoji bloqueie o toque na tela */
    z-index: 100;    
}

#sabotage-feedback.show {
    animation: fade-out-up 1.5s ease-out forwards;
    z-index: 101;
}

@keyframes fade-out-up {
    0% {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
    }
    100% {
        opacity: 0;
        transform: translate(-50%, -150%) scale(1.2); /* Sobe e desaparece */
    }
}
#smoke-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle, transparent 25%, rgba(40, 40, 40, 0.95) 70%);
    opacity: 0;
    pointer-events: none;
    z-index: 100;
    transition: opacity 0.5s ease-in-out;
}
.sabotage-item {
    display: flex;
    align-items: flex-start;
    gap: 15px;
    margin-bottom: 15px;
    text-align: left;
}

.sabotage-item-icon {
    font-size: 24px;
    margin-top: -3px;
}

.sabotage-item-details h5 {
    margin: 0 0 3px 0;
    color: #ffffff;
    font-size: 15px;
}

.sabotage-item-details p {
    margin: 0;
    font-size: 13px;
    line-height: 1.4;
    color: #d1d1d1;
}
/* Animação de pulsar para a contagem regressiva */
@keyframes countdown-pulse {
    0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
    100% { transform: translate(-50%, -50%) scale(1.5); opacity: 0; }
}
</style>
</head>
<body>
<div id="adminPanel">
    <div class="admin-header">
        <h2>Painel do Administrador</h2>
        <button class="btn btn-danger" onclick="closeAdminPanel()">Fechar</button>
    </div>
    <div class="admin-tabs">
        <button class="admin-tab-button selected" onclick="showAdminTab('dashboard')">Dashboard</button>
        <button class="admin-tab-button" onclick="showAdminTab('analytics')">Análises</button> <button class="admin-tab-button" onclick="showAdminTab('users')">Usuários</button>
        <button class="admin-tab-button" onclick="showAdminTab('leaderboard')">Leaderboard</button>
        <button class="admin-tab-button" onclick="showAdminTab('support')">Suporte</button>
        <button class="admin-tab-button" onclick="showAdminTab('announcements')">Anúncios</button>
        <button class="admin-tab-button" onclick="showAdminTab('collectiveActions')">Ações Coletivas</button> </div>
    <div class="admin-content">
        <div id="adminDashboardTab" class="admin-tab-content active">
            <h3>Visão Geral</h3>
            <div id="admin-stats-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px;">
                <div class="stat-card">
                    <h4>Total de Usuários</h4>
                    <p id="totalUsersStat">0</p>
                </div>
                <div class="stat-card">
                    <h4>Novos Usuários (24h)</h4>
                    <p id="newUsersStat">0</p>
                </div>
                <div class="stat-card">
                    <h4>Partidas Jogadas</h4>
                    <p id="totalScoresStat">0</p>
                </div>
                <div class="stat-card">
                    <h4>Tickets Abertos</h4>
                    <p id="openTicketsStat">0</p>
                </div>
            </div>
        </div>

        <div id="adminAnalyticsTab" class="admin-tab-content">
            <h3>Análises Detalhadas do Jogo</h3>
            
            <div class="analytics-card stat-card" style="margin-top: 15px;">
                <h4>Preferências Gerais</h4>
                <p>Skin Mais Usada: <strong id="mostUsedSkinStat">Calculando...</strong></p>
                <p>Mapa Mais Jogado: <strong id="mostPlayedMapStat">Calculando...</strong></p>
                <p>Dificuldade Mais Usada: <strong id="mostUsedDifficultyStat">Calculando...</strong></p>
            </div>

            <div class="analytics-card stat-card" style="margin-top: 15px;">
                <h4>Uso de Skins</h4>
                <div style="overflow-x: auto;">
                    <table class="admin-table" id="skinUsageTable">
                        <thead><tr><th>Skin</th><th>Nº de Jogadores</th><th>% do Total</th></tr></thead>
                        <tbody><tr><td colspan="3">Calculando...</td></tr></tbody>
                    </table>
                </div>
            </div>

            <div class="analytics-card stat-card" style="margin-top: 15px;">
                <h4>Distribuição de Dificuldade</h4>
                <div id="difficultyDistributionChart" class="bar-chart-container">
                    <p>Calculando...</p>
                </div>
            </div>

             <div class="analytics-card stat-card" style="margin-top: 15px;">
                <h4>Mapas Mais Jogados (por partida)</h4>
                <div id="mostPlayedMapsList">
                    <p>Calculando...</p>
                </div>
            </div>

        </div>
        <div id="adminUsersTab" class="admin-tab-content">
            <div class="filter-controls">
                <input type="text" id="userSearchInput" class="name-input" placeholder="Buscar por nome de usuário..." style="flex-grow: 1; margin: 0;">
                <button class="btn btn-primary" onclick="searchUser()">Buscar</button>
            </div>
            <div style="overflow-x: auto;">
                <table class="admin-table" id="usersTable">
                    <thead><tr><th>Usuário</th><th>Email</th><th>Moedas</th><th>Status</th><th>Ações</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div id="adminLeaderboardTab" class="admin-tab-content">
            <div class="filter-controls">
                <label for="leaderboardMapSelector">Mapa:</label>
                <select id="leaderboardMapSelector" class="name-input" onchange="loadFullLeaderboard(this.value)" style="flex-grow: 1; margin: 0; text-align: left;">
                    <option value="normal">Padrão</option>
                    <option value="no-walls">Sem Paredes</option>
                </select>
            </div>
            <div style="overflow-x: auto;">
                <table class="admin-table" id="leaderboardTable">
                     <thead><tr><th>#</th><th>Nome</th><th>Pontuação</th><th>Comidas</th><th>Dificuldade</th><th>Data</th><th>Ação</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div id="adminSupportTab" class="admin-tab-content">
            <div class="filter-controls">
                <label for="supportStatusFilter">Filtrar por Status:</label>
                <select id="supportStatusFilter" class="name-input" onchange="loadSupportTickets()" style="flex-grow: 1; margin: 0; text-align: left;">
                    <option value="new">Novo</option>
                    <option value="in_progress">Em Andamento</option>
                    <option value="resolved">Resolvido</option>
                </select>
            </div>
            <div id="supportTicketsList"></div>
        </div>
        
        <div id="adminAnnouncementsTab" class="admin-tab-content">
            <h3>Anúncio Global</h3>
            <p style="font-size:12px; opacity: 0.7; margin-bottom: 15px;">A mensagem abaixo será exibida para todos os jogadores na tela principal.</p>
            <label for="announcementText">Texto do Anúncio:</label>
            <textarea id="announcementText" class="name-input" rows="3" style="text-align: left;"></textarea>
            <div class="setting-item">
                <label for="announcementActive">Ativar Anúncio</label>
                <input type="checkbox" id="announcementActive">
            </div>
            <button class="btn btn-primary" onclick="saveAnnouncement()" style="width:100%; margin-top: 20px;">Salvar Anúncio</button>
        </div>

        <div id="adminCollectiveActionsTab" class="admin-tab-content">
            <h3>Enviar Recompensa Coletiva</h3>
            <p style="font-size:12px; opacity: 0.7; margin-bottom: 15px;">Envie Snake Coins e uma mensagem para a caixa de entrada de todos os usuários cadastrados.</p>
            
            <label for="collectiveCoinsAmount">Quantidade de Snake Coins:</label>
            <input type="number" id="collectiveCoinsAmount" class="name-input" placeholder="Ex: 500">

            <label for="collectiveRewardMessage">Mensagem da Recompensa:</label>
            <textarea id="collectiveRewardMessage" class="name-input" rows="3" style="text-align: left;" placeholder="Ex: Obrigado por jogar! Aqui está um presente."></textarea>
            
            <button class="btn btn-primary" onclick="sendCollectiveReward()" style="width:100%; margin-top: 20px;">Enviar para Todos os Jogadores</button>
        </div>
        </div>
</div>
<div id="pvpSettingsPanel" class="modal-overlay" style="z-index: 2700;">
    <div class="modal-content">
        <h3 style="margin-top: 0; text-align: center;">⚔️ Configurações PvP ⚔️</h3>
        <div class="settings-tabs">
            <button class="tab-button selected" onclick="showPvPSettingsTab('pvpGeneral')">Geral</button>
            <button class="tab-button" onclick="showPvPSettingsTab('pvpControls')">Controles</button>
            <button class="tab-button" onclick="showPvPSettingsTab('pvpMatch')">Partida</button>
            <button class="tab-button" onclick="showPvPSettingsTab('pvpSabotages')">Sabotagens</button>
        </div>

        <div id="pvpGeneralSettings" class="settings-tab-content">
            <label for="skinSelectorPvp" data-lang-key="label_skin">Visual da Cobrinha:</label>
            <select id="skinSelectorPvp" onchange="selectPvpSkin(this.value)"></select>
            <canvas id="skinPreviewCanvasPvp" width="120" height="40" style="display: block; margin: 15px auto; background: #11131e; border: 1px solid rgba(255, 255, 255, 0.1); border-radius: 8px;"></canvas>
            <button id="buySkinBtnPvp" onclick="handlePurchase(true)" class="btn btn-primary" style="display: none; width: 100%; margin-top: 5px;"></button>
            <div id="colorPickerContainerPvp" style="display: none; margin-top: 10px;">
                <label for="snakeColorPickerPvp" data-lang-key="label_snake_color">Cor Personalizada:</label>
                <input id="snakeColorPickerPvp" type="color" value="#00b894" oninput="selectPvpSkin('custom')"/>
            </div>
        </div>

        <div id="pvpControlsSettings" class="settings-tab-content" style="display:none;">
            <label for="sensitivityRangePvp">Sensibilidade dos Botões:</label>
            <input id="sensitivityRangePvp" max="10" min="1" type="range" value="5"/>
        </div>
        
        <div id="pvpMatchSettings" class="settings-tab-content" style="display:none;">
            <h4 class="selection-title" style="margin-top: 5px;">Dificuldade da Partida:</h4>
            <div id="pvpDifficultySelection" class="difficulty-selection">
                <button class="difficulty-btn easy" onclick="selectPvpDifficulty('easy')">🐌<br>Fácil</button>
                <button class="difficulty-btn normal selected" onclick="selectPvpDifficulty('normal')">🐍<br>Normal</button>
                <button class="difficulty-btn hard" onclick="selectPvpDifficulty('hard')">🚀<br>Difícil</button>
                <button class="difficulty-btn insane" onclick="selectPvpDifficulty('insane')">💀<br>Insano</button>
            </div>

            <h4 class="selection-title">Mapa da Partida:</h4>
            <div id="pvpMapSelection" class="map-selection">
                <button class="difficulty-btn selected" onclick="selectPvpMap('normal')">🧱<br>Padrão</button>
                <button class="difficulty-btn" onclick="selectPvpMap('no-walls')">🌌<br>Sem Paredes</button>
            </div>
        </div>
        <div id="pvpSabotagesSettings" class="settings-tab-content" style="display:none;">
            <h4 style="text-align: center; margin-bottom: 15px;">Efeitos das Sabotagens</h4>
            <div id="sabotage-list-container" style="max-height: 250px; overflow-y: auto; padding-right: 10px;">
                </div>
        </div>
        <button class="btn btn-secondary" onclick="closePvPSettings()" style="margin-top: 20px; width:100%;">Fechar</button>
    </div>
</div>

<div id="pvpPanel">
    <button id="pvpSettingsBtn" class="settings-btn-pvp" onclick="openPvPSettings()">⚙️</button>
    
    <button class="close-pvp-btn" onclick="requestQuitPvp()">×</button>

    <div class="pvp-content">
       <div class="opponent-view">
            <div id="opponentScoreDisplay" class="pvp-score-display">Oponente: 0</div>
            <canvas id="opponentCanvas" width="400" height="256"></canvas>
            <div class="opponent-overlay">
                <div id="waitTimeDisplay" class="wait-time-display">
                    Tempo de Espera: --
                </div>
                <button id="searchMatchBtn" class="btn btn-primary" onclick="handleSearchMatch()">Procurar Partida</button>
                <button id="cancelSearchBtn" class="btn btn-danger" onclick="cancelSearch()" style="display: none;">Cancelar Busca</button>
            </div>
        </div>

        <div id="pvpMatchInfo" class="pvp-match-info">
            <div id="pvpGameTimer">01:30</div>
            <div id="pvpCountdown" class="pvp-countdown"></div>
        </div>
        
        <div class="local-player-view">
            <canvas id="localPlayerPvPCanvas" width="400" height="256"></canvas>
            
            <div id="sabotage-feedback"></div>
            <div id="smoke-overlay"></div>

            <div id="localScoreDisplay" class="pvp-score-display">Sua Pontuação: 0</div>
            <div id="sabotageControls">
                </div>
        </div>
        <div class="modal-overlay" id="pvpResultModal" style="z-index: 2800; display: none;">
    <div class="modal-content" style="max-width: 340px; text-align: center;">
        <h2 id="pvpResultTitle" style="margin-top: 0;"></h2>
        <p id="pvpResultMessage" style="font-size: 14px; opacity: 0.9; margin: 15px 0;"></p>
        <p id="pvpResultCoins" style="font-size: 24px; font-weight: bold; color: #FFD700; min-height: 30px;"></p>
        <button class="btn btn-primary" onclick="closePvpResultModal()" style="margin-top: 20px; width:100%;">OK</button>
    </div>
</div>
<div class="modal-overlay" id="customAlertModal" style="z-index: 2900;">
    <div class="modal-content" style="max-width: 340px; text-align: center;">
        <h3 id="customAlertTitle" style="margin-top: 0; margin-bottom: 15px;">Título do Aviso</h3>
        <p id="customAlertMessage" style="font-size: 14px; opacity: 0.9; line-height: 1.5; margin: 15px 0;"></p>
        <button class="btn btn-primary" onclick="closeCustomAlert()" style="margin-top: 20px; width:100%;">OK</button>
    </div>
</div>
        <div class="controls" id="pvpGameControls">
            <button class="control-btn up">↑</button>
            <button class="control-btn left">←</button>
            <button class="control-btn right">→</button>
            <button class="control-btn down">↓</button>
        </div>
    </div>
</div>

<div id="editUserModal" class="edit-user-modal">
    <div class="edit-user-modal-content">
        <h3 id="editUserTitle">Editar Usuário</h3>
        <input type="hidden" id="editUserId">
        <label for="editUserCoins">Snake Coins</label>
        <input type="number" id="editUserCoins" class="name-input">
        <div class="setting-item" style="margin-top: 15px;">
            <label for="editUserBanned">Banir Usuário</label>
            <input type="checkbox" id="editUserBanned">
        </div>
        <div class="btn-group">
            <button class="btn btn-secondary" onclick="closeEditUserModal()">Cancelar</button>
            <button class="btn btn-primary" onclick="handleUpdateUser()">Salvar</button>
        </div>
    </div>
</div>


<div id="reenterFullscreenPrompt" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); color: white; z-index: 3000; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 20px;">
    <h2>Tela Cheia Recomendada</h2>
    <p style="margin: 20px 0;">Para a melhor experiência, o jogo deve ser jogado em tela cheia.</p>
    <button class="btn btn-primary">Voltar para Tela Cheia</button>
</div>

<div id="inboxModal" class="modal-overlay">
    <div class="modal-content">
        <h2 data-lang-key="inbox_title">Caixa de Entrada</h2>
        <div class="inbox-list" id="inboxList">
            </div>
        <button class="btn btn-secondary" onclick="closeInbox()" style="margin-top: 20px; width:100%;">Fechar</button>
    </div>
</div>

<div class="main-title">
    <span data-lang-key="title_snake_emoji">🐍</span>
    <span data-lang-key="title_j">J</span><span data-lang-key="title_o">o</span><span data-lang-key="title_g">g</span><span data-lang-key="title_o2">o</span>
    <span data-lang-key="title_d">d</span><span data-lang-key="title_a">a</span>
    <span data-lang-key="title_c">C</span><span data-lang-key="title_o3">o</span><span data-lang-key="title_b">b</span><span data-lang-key="title_r">r</span><span data-lang-key="title_i">i</span><span data-lang-key="title_n">n</span><span data-lang-key="title_h">h</span><span data-lang-key="title_a2">a</span>
</div>

<div class="game-container" id="loginScreen">
    <img src="https://i.imgur.com/Y0hwK0g.png" alt="Logo" class="login-logo">
    <h1 data-lang-key="welcome_title">Bem-vindo</h1>
    <input class="name-input" id="loginEmail" placeholder="Email" type="email" style="text-transform: none;"/>
    <input class="name-input" id="loginPass" placeholder="Senha" type="password"/>

    <p style="text-align: right; margin-top: 5px; margin-bottom: 15px; font-size: 12px;">
        <a href="#" onclick="handlePasswordReset()" data-lang-key="forgot_password_link">Esqueci a senha?</a>
    </p>

    <button class="btn btn-primary start-btn" onclick="handleLogin()" data-lang-key="login_button" style="margin-bottom: 0;">Entrar</button>
    <p style="margin-top: 15px;" data-lang-key="no_account_text">Ainda não tem conta? <a href="#" onclick="showRegister()" data-lang-key="register_link">Cadastre-se</a></p>
    <p style="font-size: 10px; margin-top: 20px; opacity: 0.5;" data-lang-key="developed_by">Desenvolvido por: John Costa</p>
</div>


<div class="game-container" id="registerScreen" style="display:none;">
    <h1 data-lang-key="register_title">📝 Cadastro</h1>
    <input class="name-input" id="registerEmail" placeholder="Email" type="email" style="text-transform: none;"/>
    <input class="name-input" id="registerPass" placeholder="Senha" type="password"/>
    <input class="name-input" id="registerPassConfirm" placeholder="Confirmar Senha" type="password"/>
    <input class="name-input" id="registerUsername" placeholder="Nome de Usuário" type="text" />
    <button class="btn btn-primary start-btn" onclick="handleRegister()" data-lang-key="register_button" style="margin-bottom: 0;">Cadastrar</button>
    <p style="margin-top: 15px;"><a href="#" onclick="showLogin()" data-lang-key="already_have_account_link">Já tem conta? Entrar</a></p>
</div>

<div class="game-container" id="mainGame" style="display: none;">
    <button id="logoutBtn" onclick="handleLogout()" data-lang-key="logout_button" title="">🚪</button>
    <button id="inboxBtn" onclick="openInbox()" title="Caixa de Entrada">
        ✉️
        <div id="inboxNotification">0</div>
    </button>
    <button id="settingsBtn" onclick="toggleSettings()" title="Configurações">⚙️</button>
    <div class="language-selector">
        <button class="language-selector-button" id="languageButton">
            <img id="currentFlag" src="https://flagsapi.com/BR/flat/64.png" alt="Brazilian Flag">
        </button>
        <div class="language-selector-dropdown" id="languageDropdown">
            <div class="language-selector-option" data-lang="pt">
                <img src="https://flagsapi.com/BR/flat/64.png" alt="Brazilian Flag">
                <span>Português</span>
            </div>
            <div class="language-selector-option" data-lang="en">
                <img src="https://flagsapi.com/US/flat/64.png" alt="USA Flag">
                <span>English</span>
            </div>
            <div class="language-selector-option" data-lang="es">
                <img src="https://flagsapi.com/ES/flat/64.png" alt="Spanish Flag">
                <span>Español</span>
            </div>
        </div>
    </div>

    <div class="total-coins-display">
        <span id="totalSnakeCoins">0</span>
    </div>


<div class="leaderboard">
<img src="https://i.imgur.com/Y0hwK0g.png" alt="Logo" class="leaderboard-logo">

    <div class="personal-record">
        <span data-lang-key="your_high_score_prefix">Seu Recorde:</span> <span id="userHighScoreDisplay">0</span>
    </div>
    <h3 data-lang-key="top3_title">🏆 TOP 3</h3>
    <div class="leaderboard-item" id="leaderboard-item-1">
        <span>1º <span id="first-name">---</span><span class="leaderboard-difficulty" id="first-difficulty"></span></span>
        <span id="first-score">0</span>
    </div>
    <div class="leaderboard-item" id="leaderboard-item-2">
        <span>2º <span id="second-name">---</span><span class="leaderboard-difficulty" id="second-difficulty"></span></span>
        <span id="second-score">0</span>
    </div>
    <div class="leaderboard-item" id="leaderboard-item-3">
        <span>3º <span id="third-name">---</span><span class="leaderboard-difficulty" id="third-difficulty"></span></span>
        <span id="third-score">0</span>
    </div>
</div>
<div id="globalAnnouncement"></div>
<div class="player-score-container">
    <div id="loggedUser" data-lang-key="player_name_prefix">Jogador: ---</div>
    <div class="current-score">
        <span id="scorePrefix" data-lang-key="score_prefix">Pontos: </span><span id="score">0</span>
    </div>
</div>

<div class="current-difficulty" id="difficultyDisplay" style="display: none;">
    <span data-lang-key="difficulty_prefix">Dificuldade:</span> <span id="currentDifficultyText">Normal</span>
</div>

<canvas height="320" id="gameCanvas" width="320"></canvas>

<div id="settingsMenu" style="display: none; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 15px; margin-top: 10px;">
    <h3 style="margin-top: 0;" data-lang-key="settings_title">⚙️ Configurações do Jogo</h3>
    <div class="settings-tabs">
        <button class="tab-button selected" onclick="showSettingsTab('general')" data-lang-key="tab_general">Geral</button>
        <button class="tab-button" onclick="showSettingsTab('controls')" data-lang-key="tab_controls">Controles</button>
        <button class="tab-button" onclick="showSettingsTab('account')" data-lang-key="tab_account">Conta</button>
        <button class="tab-button" onclick="showSettingsTab('support')" data-lang-key="tab_support">Suporte</button>
    </div>
    <div id="generalSettings" class="settings-tab-content">
        <label for="skinSelector" data-lang-key="label_skin">Visual da Cobrinha:</label>
        <select id="skinSelector" onchange="selectSkin(this.value)"></select>
        <canvas id="skinPreviewCanvas" width="120" height="40"></canvas>
        <button id="buySkinBtn" onclick="handlePurchase()" class="btn btn-primary" style="display: none; width: 100%; margin-top: 5px;"></button>
        <div id="colorPickerContainer" style="display: none; margin-top: 10px;">
            <label for="snakeColorPicker" data-lang-key="label_snake_color">Cor Personalizada:</label>
            <input id="snakeColorPicker" type="color" value="#00b894"/>
        </div>
        <br/><br/>
        
        <label for="screenBackgroundColor" data-lang-key="label_screen_background_color">Cor da Tela:</label>
        <input type="color" id="screenBackgroundColor" value="#1a1a1a" /><br /><br />

        <br/><br/>
        <label for="gameBackgroundColor" data-lang-key="label_game_background_color">Cor do Fundo do Jogo:</label>
        <input type="color" id="gameBackgroundColor" value="#11131e" />
    </div>
    <div id="controlsSettings" class="settings-tab-content" style="display:none;">
        <label for="sensitivityRange" data-lang-key="label_button_sensitivity">Sensibilidade dos Botões:</label>
        <input id="sensitivityRange" max="10" min="1" type="range" value="5"/><br/><br/>
        <label for="joystickModel" data-lang-key="label_joystick_model">Modelo de Joystick:</label>
        <select id="joystickModel" class="name-input" onchange="toggleJoystick()">
            <option value="classic" data-lang-key="option_classic">Clássico</option>
            <option value="floating" data-lang-key="option_floating">Flutuante</option>
        </select><br/><br/>
        <label for="joystickPosition" data-lang-key="label_joystick_position">Posição do Joystick Flutuante:</label>
        <select id="joystickPosition" class="name-input" onchange="updateJoystickPosition()">
            <option value="right" data-lang-key="option_right">Direita</option>
            <option value="left" data-lang-key="option_left">Esquerda</option>
            <option value="center" data-lang-key="option_center">Centro</option>
        </select><br/><br/>
    </div>
    <div id="accountSettings" class="settings-tab-content" style="display:none;">
        <h4 data-lang-key="change_username_title">Mudar Nome de Usuário</h4>
        <input class="name-input" id="newUsername" placeholder="Novo Nome de Usuário" type="text"/>
        <input class="name-input" id="currentPassForUsername" placeholder="Sua Senha Atual" type="password"/>
        <button class="btn btn-primary" onclick="handleChangeUsername()" data-lang-key="confirm_button">Confirmar</button>
        <p style="color:red; font-size:12px; min-height: 15px;" id="usernameChangeError"></p>

        <h4 data-lang-key="change_email_title">Mudar Email</h4>
        <input class="name-input" id="newEmail" placeholder="Novo Email" type="email" style="text-transform: none;"/>
        <input class="name-input" id="currentPassForEmail" placeholder="Sua Senha Atual" type="password"/>
        <button class="btn btn-primary" onclick="handleChangeEmail()" data-lang-key="confirm_button_2">Confirmar</button>
        <p style="color:red; font-size:12px; min-height: 15px;" id="emailChangeError"></p>

        <h4 style="margin-top: 20px;" data-lang-key="change_password_title">Mudar Senha</h4>
        <input class="name-input" id="oldPassword" placeholder="Senha Antiga" type="password"/>
        <input class="name-input" id="newPassword" placeholder="Nova Senha" type="password"/>
        <input class="name-input" id="confirmNewPassword" placeholder="Confirme Nova Senha" type="password"/>
        <button class="btn btn-primary" onclick="handleChangePassword()" data-lang-key="confirm_button_3">Confirmar</button>
        <p style="color:red; font-size:12px; min-height: 15px;" id="passwordChangeError"></p>
    </div>
    <div id="supportSettings" class="settings-tab-content" style="display:none;">
        <h4 data-lang-key="support_title">Contatar Suporte</h4>
        <p style="font-size: 12px; opacity: 0.8; margin-bottom: 15px;" data-lang-key="support_description">Encontrou um problema ou tem alguma sugestão? Nos envie uma mensagem!</p>
        
        <label for="supportType" data-lang-key="label_support_type">Tópico:</label>
        <select id="supportType" class="name-input">
            <option value="bug" data-lang-key="option_bug">Reportar Bug</option>
            <option value="player" data-lang-key="option_player">Reportar Jogador</option>
            <option value="feedback" data-lang-key="option_feedback">Feedback/Sugestão</option>
            <option value="other" data-lang-key="option_other">Outro</option>
        </select>
        
        <label for="supportMessage" data-lang-key="label_support_message">Sua Mensagem:</label>
        <textarea id="supportMessage" class="name-input" rows="4" style="text-align: left; padding: 10px; resize: vertical;" placeholder="Descreva seu problema ou sugestão detalhadamente aqui..."></textarea>
        
        <p style="color:limegreen; font-size:12px; min-height: 15px;" id="supportSuccessMessage"></p>
        
        <button class="btn btn-primary" onclick="handleSupportRequest()" data-lang-key="send_button" style="width: 100%;">Enviar</button>
    </div>
    <button class="btn btn-secondary" onclick="closeSettings()" style="margin-top: 20px; width:100%;" data-lang-key="close_button">Fechar</button>
</div>

<div id="startScreen">
    <button class="btn btn-primary start-btn" onclick="startGame()" data-lang-key="start_game_button">Iniciar Jogo</button>
    
    <h3 class="selection-title" data-lang-key="choose_difficulty_title">Escolha a Dificuldade:</h3>
    <div class="difficulty-selection">
        <button class="difficulty-btn easy" onclick="selectDifficulty('easy')" data-lang-key="difficulty_easy_button">🐌<br>Fácil</button>
        <button class="difficulty-btn normal selected" onclick="selectDifficulty('normal')" data-lang-key="difficulty_normal_button">🐍<br>Normal</button>
        <button class="difficulty-btn hard" onclick="selectDifficulty('hard')" data-lang-key="difficulty_hard_button">🚀<br>Difícil</button>
        <button class="difficulty-btn insane" onclick="selectDifficulty('insane')" data-lang-key="difficulty_insane_button">💀<br>Insano</button>
    </div>
    <div class="difficulty-info" id="difficultyInfo">Velocidade média - Perfeito para iniciantes!</div>

    <h3 class="selection-title" data-lang-key="choose_map_title">Escolha o Mapa:</h3>
    <div class="map-selection">
        <button class="difficulty-btn selected" onclick="selectMap('normal')" data-lang-key="map_default_button">🧱<br>Padrão</button>
        <button class="difficulty-btn" onclick="selectMap('no-walls')" data-lang-key="map_no_walls_button">🌌<br>Sem Paredes</button>
        <button class="difficulty-btn" onclick="openPvPPanel()">⚔️<br>PvP</button>
    </div>
    <div class="difficulty-info" id="mapInfo">Paredes normais.</div>
</div>

<div class="controls" id="gameControls" style="display: none;">
    <button class="control-btn up" id="upBtn">↑</button>
    <button class="control-btn left" id="leftBtn">←</button>
    <button class="control-btn right" id="rightBtn">→</button>
    <button class="control-btn down" id="downBtn">↓</button>
</div>
<div style="display: flex; justify-content: center;">
    <button class="btn btn-secondary pause-btn" id="pauseBtn" onclick="togglePause()" style="display: none;" data-lang-key="pause_button">⏸️ Pausar</button>
    <button class="btn btn-danger quit-game-btn" id="quitGameBtn" onclick="quitGame()" style="display: none;" data-lang-key="quit_game_button">🚫 Sair</button>
</div>
<div class="instructions" id="gameInstructions" style="display: none; margin-top: 15px;">
    <p data-lang-key="instructions_controls" style="font-size: 12px; opacity: 0.7;">Use os botões para controlar a cobra</p>
    <p data-lang-key="instructions_food" style="font-size: 12px; opacity: 0.7;">Colete a comida vermelha para crescer!</p>
</div>

<div class="game-over" id="gameOver">
<h2>Game Over!</h2>
<p><span id="yourScorePrefix" data-lang-key="your_score_prefix">Sua pontuação: </span><span id="finalScore">0</span></p>
<p><span data-lang-key="coins_earned_in_game_prefix">Moedas ganhas nesta partida: </span><span id="coinsEarnedGameOver">0</span>🪙</p>
<button class="btn btn-primary restart-btn" onclick="restartGame()" data-lang-key="play_again_button">Jogar Novamente</button>
</div>

<div id="congratulationsScreen">
    <h2 data-lang-key="congrats_title">🎉 Parabéns! Novo Recorde! 🎉</h2>
    <p><span data-lang-key="your_score_prefix">Sua pontuação: </span><span id="finalScoreCongrats">0</span></p>
    <p><span data-lang-key="coins_earned_in_game_prefix">Moedas ganhas nesta partida: </span><span id="coinsEarnedCongrats">0</span>🪙</p>
    <button class="btn btn-primary restart-btn" onclick="restartGame()" data-lang-key="play_again_button">Jogar Novamente</button>
</div>

<div class="modal-overlay" id="quitConfirmModal">
    <div class="modal-content" style="max-width: 320px;">
        <h3>Sair da Partida?</h3>
        <p style="margin-top: 5px; font-size: 13px; opacity: 0.8;">Seu progresso na partida atual será perdido.</p>
        <div style="display: flex; gap: 10px; margin-top: 20px;">
            <button class="btn btn-secondary" style="width: 100%;" onclick="handleCancelQuit()">Cancelar</button>
            <button class="btn btn-danger" style="width: 100%;" onclick="handleConfirmQuit()">Sim, Sair</button>
        </div>
    </div>
</div>
</div>
<div class="modal-overlay" id="quitPvpConfirmModal" style="z-index: 2800;">
        <div class="modal-content" style="max-width: 320px;">
            <h3>Sair da Partida PvP?</h3>
            <p style="margin-top: 5px; font-size: 13px; opacity: 0.8;">
                Seu oponente será notificado e a partida será encerrada.
            </p>
            <div style="display: flex; gap: 10px; margin-top: 20px;">
                <button class="btn btn-secondary" style="width: 100%;" onclick="cancelQuitPvp()">Cancelar</button>
                <button class="btn btn-danger" style="width: 100%;" onclick="confirmQuitPvp()">Sim, Sair</button>
            </div>
        </div>
    </div>
<div id="floatingJoystick" style="position: fixed; bottom: 40px; right: 40px; width: 120px; height: 120px; border-radius: 50%; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); display: none; touch-action: none;">
    <div id="joystickThumb" style="width: 40px; height: 40px; background: rgba(255,255,255,0.3); border-radius: 50%; position: absolute; left: 40px; top: 40px;"></div>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>

<script>
    // Configuração e inicialização do Firebase
    const firebaseConfig = {
        apiKey: "AIzaSyD-W1DR-m3kRXZ9l4J04R8D_L0adVGkxyA",
        authDomain: "cdi-games.firebaseapp.com",
        projectId: "cdi-games",
        storageBucket: "cdi-games.appspot.com",
        messagingSenderId: "965010965921",
        appId: "1:965010965921:web:270812342fe53f4d1637e0",
        measurementId: "G-P0TL8K8GH6"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    const skinPreviewCanvas = document.getElementById('skinPreviewCanvas');
    const previewCtx = skinPreviewCanvas.getContext('2d');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const gameOverElement = document.getElementById('gameOver');
    const finalScoreElement = document.getElementById('finalScore');
    const startScreen = document.getElementById('startScreen');
    const gameControls = document.getElementById('gameControls');
    const pauseBtn = document.getElementById('pauseBtn');
    const quitGameBtn = document.getElementById('quitGameBtn');
    const gameInstructions = document.getElementById('gameInstructions');
    const difficultyDisplay = document.getElementById('difficultyDisplay');
    const currentDifficultyText = document.getElementById('currentDifficultyText');
    const difficultyInfo = document.getElementById('difficultyInfo');
    const mapInfo = document.getElementById('mapInfo');
    const congratulationsScreen = document.getElementById('congratulationsScreen');
    const finalScoreCongrats = document.getElementById('finalScoreCongrats');
    const reenterPrompt = document.getElementById('reenterFullscreenPrompt');
    let fireworksInterval;
    const firstName = document.getElementById('first-name');
    const firstScore = document.getElementById('first-score');
    const firstDifficulty = document.getElementById('first-difficulty');
    const secondName = document.getElementById('second-name');
    const secondScore = document.getElementById('second-score');
    const secondDifficulty = document.getElementById('second-difficulty');
    const thirdName = document.getElementById('third-name');
    const thirdScore = document.getElementById('third-score');
    const thirdDifficulty = document.getElementById('third-difficulty');
    let screenBackgroundColor;
    
    // Variáveis para o sistema de moedas
    let snakeCoins = 0; // Total de Snake Coins do usuário
    let coinsEarnedThisGame = 0; // Moedas ganhas na partida atual
    let foodEatenThisGame = 0;
    const coinsEarnedCongratsElement = document.getElementById('coinsEarnedCongrats');
    const coinsEarnedGameOverElement = document.getElementById('coinsEarnedGameOver');
    const totalSnakeCoinsElement = document.getElementById('totalSnakeCoins');
    const userHighScoreDisplay = document.getElementById('userHighScoreDisplay'); // Elemento para recorde pessoal

    // Objeto para armazenar recordes pessoais por mapa
    let userHighScoresPerMap = {}; 

    // --- Sistema de Skins ---
    const skins = {
        'custom': { name_pt: 'Personalizada', name_en: 'Custom', name_es: 'Personalizado', unlockScore: 0, bodyColor: null, headColor: null },
        'default': { name_pt: 'Padrão', name_en: 'Default', name_es: 'Estándar', unlockScore: 0, bodyColor: '#00b894', headColor: '#008269' },
        'spider': { name_pt: 'Aranha', name_en: 'Spider', name_es: 'Araña', unlockScore: 2000, blueColor: '#005AFF', redColor: '#FF0000' },
        'coral': { name_pt: 'Coral', name_en: 'Coral', name_es: 'Coral', unlockScore: 1500, colors: ['#D90429', '#000000', '#FFFFFF'] }, // Vermelho, Preto, Branco
        'pharaoh': { name_pt: 'Faraó', name_en: 'Pharaoh', name_es: 'Faraón', unlockScore: 2500, bodyColor1: '#FFD700', bodyColor2: '#DAA520', headColor: '#00008B', uraeusColor: '#FF0000' },
        // Novas skins baseadas em SC
        'galaxy': { name_pt: 'Galáxia', name_en: 'Galaxy', name_es: 'Galaxia', unlockCoins: 1500, colors: ['#4B0082', '#00008B', '#8A2BE2'], headColor: '#FFFFFF' },
        'windowsClassic': { name_pt: 'Windows Classic', name_en: 'Windows Classic', name_es: 'Windows Classic', unlockCoins: 1000 },
        'camo': { name_pt: 'Camo', name_en: 'Camo', name_es: 'Camo', unlockCoins: 500, colors: ['#4B5320', '#8B4513', '#D2B48C'], headColor: '#228B22' },
        'halloween': { name_pt: 'Halloween', name_en: 'Halloween', name_es: 'Halloween', unlockCoins: 1000, bodyColor1: '#000000', bodyColor2: '#4B0082', headColor: '#FF8C00', lineColor: '#FF8C00' },
        'christmas': { name_pt: 'Natal', name_en: 'Christmas', name_es: 'Navidad', unlockCoins: 500, bodyColor: '#ffffff', shadowColor: '#d0e1f9', eyeColor: '#2c3e50', noseColor: '#e67e22', wireColor: '#34495e', outlineColor: '#2c3e50', lightColors: ['#00FF00', '#FFFF00', '#0080FF', '#FF0000'], lightOffColor: '#2c3e50', glowColor: 'rgba(208, 225, 249, 0.7)' },
    };
    let currentSkin = 'default';
    let unlockedSkins = ['default', 'custom']; // Inicializa com default e custom
    
    document.getElementById('screenBackgroundColor').addEventListener('input', function(e) {
        screenBackgroundColor = e.target.value;
        document.getElementById('mainGame').style.background = screenBackgroundColor;
    });
    function shadeColor(color, percent) {
        let f=parseInt(color.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;
        return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
    }
const pvpRewards = {
    easy: 10,
    normal: 25,
    hard: 50,
    insane: 100
};
    const difficulties = {
        easy: { speed: 150, name_pt: 'Fácil', name_en: 'Easy', name_es: 'Fácil', description_pt: 'Velocidade lenta - Ideal para relaxar!', description_en: 'Slow speed - Ideal for relaxing!', description_es: 'Velocidad lenta - ¡Ideal para relajarse!', emoji: '🐌', points: 5 },
        normal: { speed: 120, name_pt: 'Normal', name_en: 'Normal', name_es: 'Normal', description_pt: 'Velocidade balanceada - A experiência clássica.', description_en: 'Balanced speed - The classic experience.', description_es: 'Velocidad equilibrada - La experiencia clásica.', emoji: '🐍', points: 10 },
        hard: { speed: 90, name_pt: 'Difícil', name_en: 'Hard', name_es: 'Difícil', description_pt: 'Velocidade rápida - Um bom desafio!', description_en: 'Fast speed - A good challenge!', description_es: 'Velocidad rápida - ¡Un buen desafío!', emoji: '🚀', points: 20 },
        insane: { speed: 70, name_pt: 'Insano', name_en: 'Insane', name_es: 'Insano', description_pt: 'Velocidade extrema - Para os mestres da cobrinha!', description_en: 'Extreme speed - For the snake masters!', description_es: 'Velocidad extrema - ¡Para los maestros de la serpiente!', emoji: '💀', points: 32 }
    };
    let currentDifficulty = 'normal';
    let gameInterval;
    const maps = {
        'normal': { name_pt: 'Padrão', name_en: 'Standard', name_es: 'Estándar', description_pt: 'As paredes são barreiras mortais.', description_en: 'Walls are deadly barriers.', description_es: 'Las paredes son barreras mortales.', wrapAround: false },
        'no-walls': { name_pt: 'Sem Paredes', name_en: 'No Walls', name_es: 'Sin Paredes', description_pt: 'Atravesse as paredes e reapareça do outro lado!', description_en: 'Pass through walls and reappear on the other side!', description_es: '¡Atraviesa las paredes y reaparece del otro lado!', wrapAround: true }
    };
const sabotages = {
        'addObstacles': { 
            name_pt: 'Obstáculos', 
            description_pt: 'Cria 8 barreiras no campo inimigo que duram 10 segundos ou até colidir.',
            icon: '⚠️',
            duration: 10000 // 1O segundos ou até colidir
        },
        'invertControls': {
            name_pt: 'Controles Invertidos',
            description_pt: 'Inverte os controles do oponente por 4 segundos.',
            icon: '⏪',
            duration: 3000 // 3 segundos
        },
        'smokeScreen': {
            name_pt: 'Cortina de Fumaça',
            description_pt: 'Cobre parte da tela do oponente com fumaça.',
            icon: '💨',
            duration: 5000 // 5 segundos
        },
        'poisonedFood': {
            name_pt: 'Comida Envenenada',
            description_pt: 'Cria uma comida "envenenada" na tela rival. Uma dá +2 pontos, a outra pune! Válido por 3 comidas.',
            icon: '🍎',
            duration: 10000 // Por 10 segundos, comidas podem ser venenosas
        },
        'forcedAcceleration': {
            name_pt: 'Aceleração Forçada',
            description_pt: 'Aumenta a velocidade do oponente em 25% por 3 segundos.',
            icon: '🚀',
            duration: 3000 // 3 segundos
        },
        'foodRepellent': {
            name_pt: 'Repelente de Comida',
            description_pt: 'As comidas na tela do oponente fogem dele por 5 segundos.',
            icon: '🧲',
            duration: 5000 // 5 segundos
        }
    };
    let currentMap = 'normal';
    const gridSize = 16;
    const tileCount = Math.floor(canvas.width / gridSize);
    let snake = [{x: Math.floor(tileCount/2), y: Math.floor(tileCount/2)}];
    let food = {};
    let dx = 0;
    let dy = 0;
    let score = 0;
    let gameRunning = false;
    let gameStarted = false;
    let gamePaused = false;
    let inputQueue = [];
    const translations = {
        'pt': {
            'label_skin': 'Visual da Cobrinha:', 'label_snake_color': 'Cor Personalizada:', 'skin_custom': 'Personalizada', 'skin_default': 'Padrão', 'skin_spider': 'Aranha', 'skin_coral': 'Coral', 'skin_pharaoh': 'Faraó', 'skin_galaxy': 'Galáxia', 'skin_windowsClassic': 'Windows Classic', 'skin_camo': 'Camuflado', 'skin_halloween': 'Halloween', 'skin_christmas': 'Natal', 'congrats_title': '🎉 Parabéns! Novo Recorde! 🎉', 'title_snake_emoji': '', 'title_j': 'J', 'title_o': 'o', 'title_g': 'g', 'title_o2': 'o', 'title_d': ' d', 'title_a': 'a', 'title_c': ' C', 'title_o3': 'o', 'title_b': 'b', 'title_r': 'r', 'title_i': 'i', 'title_n': 'n', 'title_h': 'h', 'title_a2': 'a', 'welcome_title': 'Bem-vindo', 'login_button': 'Entrar', 'no_account_text': 'Ainda não tem conta?', 'register_link': 'Cadastre-se', 'developed_by': 'Desenvolvido por: John Costa', 'register_title': '📝 Cadastro', 'register_button': 'Cadastrar', 'already_have_account_link': 'Já tem conta? Entrar', 'game_title': 'Jogo da Cobrinha', 'player_name_prefix': 'Jogador:', 'score_prefix': 'Pontos:', 'difficulty_prefix': 'Dificuldade:', 'top3_title': '🏆 TOP 3', 'logout_button': '🚪', 'settings_title': '⚙️ Configurações', 'tab_general': 'Geral', 'tab_controls': 'Controles', 'tab_account': 'Conta', 'label_screen_background_color': 'Cor da Tela:', 'label_button_sensitivity': 'Sensibilidade dos Botões:', 'label_joystick_model': 'Modelo de Joystick:', 'option_classic': 'Clássico', 'option_floating': 'Flutuante', 'label_joystick_position': 'Posição do Joystick Flutuante:', 'option_right': 'Direita', 'option_left': 'Esquerda', 'option_center': 'Centro', 'change_username_title': 'Mudar Nome de Usuário', 'change_email_title': 'Mudar Email', 'confirm_button': 'Confirmar', 'confirm_button_2': 'Confirmar', 'confirm_button_3': 'Confirmar', 'change_password_title': 'Mudar Senha', 'close_button': 'Fechar', 'start_game_button': 'Iniciar Jogo', 'choose_difficulty_title': 'Escolha a Dificuldade:', 'difficulty_easy_button': '🐌<br>Fácil', 'difficulty_normal_button': '🐍<br>Normal', 'difficulty_hard_button': '🚀<br>Difícil', 'difficulty_insane_button': '💀<br>Insano', 'choose_map_title': 'Escolha o Mapa:', 'map_default_button': '🧱<br>Padrão', 'map_no_walls_button': '🌌<br>Sem Paredes', 'pause_button': 'Pausar', 'continue_button': 'Continuar', 'quit_game_button': '🚫 Sair', 'game_over_title': 'Game Over!', 'your_score_prefix': 'Sua pontuação:', 'play_again_button': 'Jogar Novamente', 'instructions_controls': 'Use os botões para controlar a cobra', 'instructions_food': 'Colete a comida vermelha para crescer!', 'alert_fill_all_fields': 'Preencha todos os campos', 'alert_user_exists': 'Este email já está cadastrado', 'alert_registration_success': 'Cadastro realizado com sucesso!', 'alert_invalid_credentials': 'Email ou senha inválidos', 'alert_confirm_quit': 'Tem certeza que deseja sair da partida atual?', 'alert_no_user_logged_in': 'Nenhum usuário logado.', 'alert_new_email_empty': 'O novo email não pode ser vazio.', 'alert_email_taken': 'Este email já está em uso.', 'alert_incorrect_current_password': 'Senha atual incorreta.', 'alert_email_changed_success': 'Email alterado com sucesso!', 'alert_new_email_same_as_current': 'O novo email é o mesmo que o atual.', 'alert_fill_all_password_fields': 'Preencha todos os campos de senha.', 'alert_old_password_incorrect': 'Senha antiga incorreta.', 'alert_new_passwords_dont_match': 'A nova senha e a confirmação não coincidem.', 'alert_password_changed_success': 'Senha alterada com sucesso!', 'alert_new_password_same_as_old': 'A nova senha não pode ser igual à antiga.', 'password_min_length': 'A senha deve ter no mínimo {minLength} caracteres.', 'password_needs_number': 'A senha deve conter pelo menos um número.', 'password_needs_letter': 'A senha deve conter pelo menos uma letra.', 'alert_invalid_email': 'Por favor, insira um endereço de e-mail válido.', 'choose_username_title': 'Escolha seu nome de usuário', 'choose_username_subtitle': 'Este nome será exibido no jogo e no ranking.', 'alert_username_taken': 'Este nome de usuário já está em uso.', 'alert_username_empty': 'O nome de usuário não pode ser vazio.', 'alert_username_changed_success': 'Nome de usuário alterado com sucesso!', 'alert_new_username_same_as_current': 'O novo nome de usuário é o mesmo que o atual.', 'forgot_password_link': 'Esqueci a senha?', 'alert_enter_email_for_reset': 'Por favor, insira seu email no campo correspondente para redefinir a senha.', 'alert_password_reset_success': 'Email de redefinição de senha enviado! Verifique sua caixa de entrada.',
            'coins_earned_in_game_prefix': 'Moedas ganhas nesta partida:',
            'total_coins_display': 'SC',
            'confirm_buy_skin': 'Tem certeza que deseja comprar esta skin por',
            'not_enough_coins': 'Você não tem Snake Coins suficientes para comprar esta skin!',
            'skin_unlocked_success': 'Skin desbloqueada com sucesso!',
            'your_high_score_prefix': 'Seu Recorde:',
            // Novas traduções de Suporte
            'tab_support': 'Suporte',
            'support_title': 'Contatar Suporte',
            'support_description': 'Encontrou um problema ou tem alguma sugestão? Nos envie uma mensagem!',
            'label_support_type': 'Tópico:',
            'option_bug': 'Reportar Bug',
            'option_player': 'Reportar Jogador',
            'option_feedback': 'Feedback/Sugestão',
            'option_other': 'Outro',
            'label_support_message': 'Sua Mensagem:',
            'send_button': 'Enviar',
            'alert_support_message_empty': 'A mensagem não pode estar vazia.',
            'alert_support_success': 'Mensagem enviada com sucesso! Agradecemos o contato.',
            // Novas traduções da Caixa de Entrada
            'inbox_title': 'Caixa de Entrada',
            'inbox_empty': 'Sua caixa de entrada está vazia.',
            'inbox_delete_confirm': 'Tem certeza que deseja apagar esta mensagem?'
        },
        'en': {
            'label_skin': 'Snake Skin:', 'label_snake_color': 'Custom Color:', 'skin_custom': 'Custom', 'skin_default': 'Default', 'skin_spider': 'Spider', 'skin_coral': 'Coral', 'skin_pharaoh': 'Pharaoh', 'skin_galaxy': 'Galaxy', 'skin_windowsClassic': 'Windows Classic', 'skin_camo': 'Camouflaged', 'skin_halloween': 'Halloween', 'skin_christmas': 'Christmas', 'congrats_title': '🎉 Congratulations! New Record! 🎉', 'title_snake_emoji': '', 'title_j': 'S', 'title_o': 'n', 'title_g': 'a', 'title_o2': 'k', 'title_d': 'e', 'title_a': ' G', 'title_c': 'a', 'title_o3': 'm', 'title_b': 'e', 'title_r': '', 'title_i': '', 'title_n': '', 'title_h': '', 'title_a2': '', 'welcome_title': 'Welcome', 'login_button': 'Login', 'no_account_text': 'Don\'t have an account?', 'register_link': 'Sign Up', 'developed_by': 'John Costa', 'register_title': '📝 Sign Up', 'register_button': 'Sign Up', 'already_have_account_link': 'Already have an account? Login', 'game_title': ' Snake Game', 'player_name_prefix': 'Player:', 'score_prefix': 'Score:', 'difficulty_prefix': 'Difficulty:', 'top3_title': '🏆 TOP 3', 'logout_button': '🚪', 'settings_title': '⚙️ Settings', 'tab_general': 'General', 'tab_controls': 'Controls', 'tab_account': 'Account', 'label_screen_background_color': 'Screen Color:', 'label_button_sensitivity': 'Button Sensitivity:', 'label_joystick_model': 'Joystick Model:', 'option_classic': 'Classic', 'option_floating': 'Floating', 'label_joystick_position': 'Floating Joystick Position:', 'option_right': 'Right', 'option_left': 'Left', 'option_center': 'Center', 'change_username_title': 'Change Username', 'change_email_title': 'Change Email', 'confirm_button': 'Confirm', 'confirm_button_2': 'Confirm', 'confirm_button_3': 'Confirm', 'change_password_title': 'Change Password', 'close_button': 'Close', 'start_game_button': 'Start Game', 'choose_difficulty_title': 'Choose Difficulty:', 'difficulty_easy_button': '🐌<br>Easy', 'difficulty_normal_button': '🐍<br>Normal', 'difficulty_hard_button': '🚀<br>Hard', 'difficulty_insane_button': '💀<br>Insane', 'choose_map_title': 'Choose Map:', 'map_default_button': '🧱<br>Standard', 'map_no_walls_button': '🌌<br>No Walls', 'pause_button': 'Pause', 'continue_button': 'Continue', 'quit_game_button': '🚫 Quit', 'game_over_title': 'Game Over!', 'your_score_prefix': 'Your Score:', 'play_again_button': 'Play Again', 'instructions_controls': 'Use the buttons to control the snake', 'instructions_food': 'Collect red food to grow!', 'alert_fill_all_fields': 'Please fill in all fields', 'alert_user_exists': 'This email is already registered', 'alert_registration_success': 'Registration successful!', 'alert_invalid_credentials': 'Invalid email or password', 'alert_confirm_quit': 'Are you sure you want to quit the current game?', 'alert_no_user_logged_in': 'No user logged in.', 'alert_new_email_empty': 'New email cannot be empty.', 'alert_email_taken': 'This email is already in use.', 'alert_incorrect_current_password': 'Incorrect current password.', 'alert_email_changed_success': 'Email changed successfully!', 'alert_new_email_same_as_current': 'The new email is the same as the current one.', 'alert_fill_all_password_fields': 'Please fill in all password fields.', 'alert_old_password_incorrect': 'Incorrect old password.', 'alert_new_passwords_dont_match': 'New password and confirmation do not match.', 'alert_password_changed_success': 'Password changed successfully!', 'alert_new_password_same_as_old': 'New password cannot be the same as the old one.', 'password_min_length': 'Password must be at least {minLength} characters long.', 'password_needs_number': 'Password must contain at least one number.', 'password_needs_letter': 'Password must contain at least one letter.', 'alert_invalid_email': 'Please enter a valid email address.', 'choose_username_title': 'Choose your username', 'choose_username_subtitle': 'This name will be displayed in-game and on the leaderboard.', 'alert_username_taken': 'This username is already taken.', 'alert_username_empty': 'Username cannot be empty.', 'alert_username_changed_success': 'Username changed successfully!', 'alert_new_username_same_as_current': 'The new username is the same as the current one.', 'forgot_password_link': 'Forgot password?', 'alert_enter_email_for_reset': 'Please enter your email in the field to reset your password.', 'alert_password_reset_success': 'Password reset email sent! Check your inbox.',
            'coins_earned_in_game_prefix': 'Coins earned this game:',
            'total_coins_display': 'SC',
            'confirm_buy_skin': 'Are you sure you want to buy this skin for',
            'not_enough_coins': 'You do not have enough Snake Coins to buy this skin!',
            'skin_unlocked_success': 'Skin unlocked successfully!',
            'your_high_score_prefix': 'Your High Score:',
            // Novas traduções de Suporte
            'tab_support': 'Support',
            'support_title': 'Contact Support',
            'support_description': 'Found an issue or have a suggestion? Send us a message!',
            'label_support_type': 'Topic:',
            'option_bug': 'Report a Bug',
            'option_player': 'Report a Player',
            'option_feedback': 'Feedback/Suggestion',
            'option_other': 'Other',
            'label_support_message': 'Your Message:',
            'send_button': 'Send',
            'alert_support_message_empty': 'The message cannot be empty.',
            'alert_support_success': 'Message sent successfully! Thank you for contacting us.',
            // Novas traduções da Caixa de Entrada
            'inbox_title': 'Inbox',
            'inbox_empty': 'Your inbox is empty.',
            'inbox_delete_confirm': 'Are you sure you want to delete this message?'
        },
        'es': {
            'label_skin': 'Aspecto de Serpiente:', 'label_snake_color': 'Color Personalizado:', 'skin_custom': 'Personalizado', 'skin_default': 'Estándar', 'skin_spider': 'Araña', 'skin_coral': 'Coral', 'skin_pharaoh': 'Faraón', 'skin_galaxy': 'Galaxia', 'skin_windowsClassic': 'Windows Classic', 'skin_camo': 'Camuflado', 'skin_halloween': 'Halloween', 'skin_christmas': 'Navidad', 'congrats_title': '🎉 ¡Felicidades! ¡Nuevo Récord! 🎉', 'title_snake_emoji': '', 'title_j': 'J', 'title_o': 'u', 'title_g': 'e', 'title_o2': 'g', 'title_d': 'o', 'title_a': ' d', 'title_c': 'e', 'title_o3': ' l', 'title_b': 'a', 'title_r': ' S', 'title_i': 'e', 'title_n': 'r', 'title_h': 'p', 'title_a2': 'iente', 'welcome_title': 'Bienvenido', 'login_button': 'Iniciar Sesión', 'no_account_text': '¿No tienes cuenta?', 'register_link': 'Regístrate', 'developed_by': 'Desarrollado por: John Costa', 'register_title': '📝 Registro', 'register_button': 'Registrar', 'already_have_account_link': '¿Ya tienes cuenta? Iniciar Sesión', 'game_title': ' Juego de la Serpiente', 'player_name_prefix': 'Jugador:', 'score_prefix': 'Puntos:', 'difficulty_prefix': 'Dificultad:', 'top3_title': '🏆 TOP 3', 'logout_button': '🚪', 'settings_title': '⚙️ Ajustes', 'tab_general': 'General', 'tab_controls': 'Controles', 'tab_account': 'Cuenta', 'label_screen_background_color': 'Color de la Pantalla:', 'label_button_sensitivity': 'Sensibilidad de los Botones:', 'label_joystick_model': 'Modelo de Joystick:', 'option_classic': 'Clásico', 'option_floating': 'Flotante', 'label_joystick_position': 'Posición del Joystick Flotante:', 'option_right': 'Derecha', 'option_left': 'Izquierda', 'option_center': 'Centro', 'change_username_title': 'Cambiar Nombre de Usuario', 'change_email_title': 'Cambiar Email', 'confirm_button': 'Confirmar', 'confirm_button_2': 'Confirmar', 'confirm_button_3': 'Confirmar', 'change_password_title': 'Cambiar Contraseña', 'close_button': 'Cerrar', 'start_game_button': 'Iniciar Juego', 'choose_difficulty_title': 'Elige la Dificultad:', 'difficulty_easy_button': '🐌<br>Fácil', 'difficulty_normal_button': '🐍<br>Normal', 'difficulty_hard_button': '🚀<br>Difícil', 'difficulty_insane_button': '💀<br>Insano', 'choose_map_title': 'Elige el Mapa:', 'map_default_button': '🧱<br>Estándar', 'map_no_walls_button': '🌌<br>Sin Paredes', 'pause_button': 'Pausar', 'continue_button': 'Continuar', 'quit_game_button': '🚫 Salir', 'game_over_title': '¡Fin del Juego!', 'your_score_prefix': 'Tu puntuación:', 'play_again_button': 'Jugar de Nuevo', 'instructions_controls': 'Usa los botones para controlar la serpiente', 'instructions_food': '¡Recoge la comida roja para crecer!', 'alert_fill_all_fields': 'Por favor, rellene todos los campos', 'alert_user_exists': 'Este correo electrónico ya está registrado', 'alert_registration_success': '¡Registro exitoso!', 'alert_invalid_credentials': 'Correo electrónico o contraseña no válidos', 'alert_confirm_quit': '¿Estás seguro de que quieres salir del juego actual?', 'alert_no_user_logged_in': 'Ningún usuario ha iniciado sesión.', 'alert_new_email_empty': 'El nuevo correo electrónico no puede estar vacío.', 'alert_email_taken': 'Este correo electrónico ya está en uso.', 'alert_incorrect_current_password': 'Contraseña actual incorrecta.', 'alert_email_changed_success': '¡Correo electrónico cambiado con éxito!', 'alert_new_email_same_as_current': 'El nuevo correo electrónico es el mismo que el actual.', 'alert_fill_all_password_fields': 'Por favor, rellene todos los campos de contraseña.', 'alert_old_password_incorrect': 'Contraseña antigua incorrecta.', 'alert_new_passwords_dont_match': 'La nueva contraseña y la confirmación no coinciden.', 'alert_password_changed_success': '¡Contraseña cambiada con éxito!', 'alert_new_password_same_as_old': 'La nueva contraseña no puede ser igual a la antigua.', 'password_min_length': 'La contraseña debe tener al menos {minLength} caracteres.', 'password_needs_number': 'La contraseña debe contener al menos un número.', 'password_needs_letter': 'La contraseña debe contener al menos uma letra.', 'alert_invalid_email': 'Por favor, introduce una dirección de correo electrónico válida.', 'choose_username_title': 'Elige tu nombre de usuario', 'choose_username_subtitle': 'Este nombre se mostrará en el juego y en la clasificación.', 'alert_username_taken': 'Este nombre de usuario ya está en uso.', 'alert_username_empty': 'El nombre de usuario no puede estar vacío.', 'alert_username_changed_success': '¡Nombre de usuario cambiado con éxito!', 'alert_new_username_same_as_current': 'El nuevo nombre de usuario es el mismo que el actual.', 'forgot_password_link': '¿Olvidaste la contraseña?', 'alert_enter_email_for_reset': 'Por favor, introduce tu correo electrónico en el campo para restablecer la contraseña.', 'alert_password_reset_success': '¡Correo de restablecimiento de contraseña enviado! Revisa tu bandeja de entrada.',
            'coins_earned_in_game_prefix': 'Monedas ganadas en esta partida:',
            'total_coins_display': 'SC',
            'confirm_buy_skin': '¿Estás seguro de que quieres comprar esta skin por',
            'not_enough_coins': '¡No tienes suficientes Snake Coins para comprar esta skin!',
            'skin_unlocked_success': '¡Skin desbloqueada con éxito!',
            'your_high_score_prefix': 'Tu Record:',
            // Novas traduções de Suporte
            'tab_support': 'Soporte',
            'support_title': 'Contactar a Soporte',
            'support_description': '¿Encontraste un problema o tienes una sugerencia? ¡Envíanos un mensaje!',
            'label_support_type': 'Asunto:',
            'option_bug': 'Reportar un Bug',
            'option_player': 'Reportar un Jugador',
            'option_feedback': 'Comentarios/Sugerencia',
            'option_other': 'Otro',
            'label_support_message': 'Tu Mensaje:',
            'send_button': 'Enviar',
            'alert_support_message_empty': 'El mensaje no puede estar vacío.',
            'alert_support_success': '¡Mensaje enviado con éxito! Gracias por contactarnos.',
             // Novas traduções da Caixa de Entrada
            'inbox_title': 'Buzón de Entrada',
            'inbox_empty': 'Tu buzón de entrada está vacío.',
            'inbox_delete_confirm': '¿Estás seguro de que quieres borrar este mensaje?'
        }
    };
    let currentLanguage = localStorage.getItem('snakeGameLanguage') || 'pt';

    function updateContent() {
        const lang = translations[currentLanguage];
        document.querySelectorAll('[data-lang-key]').forEach(element => {
            const key = element.getAttribute('data-lang-key');
            const text = lang[key];
            if (key.startsWith('skin_')) return; 

            if (key.startsWith('title_') && element.closest('.main-title')) {
                const fullTitle = [ lang['title_snake_emoji'], lang['title_j'], lang['title_o'], lang['title_g'], lang['title_o2'], lang['title_d'], lang['title_a'], lang['title_c'], lang['title_o3'], lang['title_b'], lang['title_r'], lang['title_i'], lang['title_n'], lang['title_h'], lang['title_a2'] ].join('');
                document.querySelector('.main-title').textContent = fullTitle.replace(/,/g, ''); 
                return;
            }
            
            if (key === 'player_name_prefix') {
                 if (currentUsername) {
                    element.textContent = `${text} ${currentUsername}`;
                } else {
                    element.textContent = text;
                }
            } else if (key === 'your_high_score_prefix') {
                element.textContent = text;
            } else if (element.placeholder && key) {
                element.placeholder = text;
            } else if (key === 'no_account_text') {
                const linkText = lang['register_link'];
                element.innerHTML = `${text} <a href="#" onclick="showRegister()">${linkText}</a>`;
            } else if (key === 'already_have_account_link') {
                element.innerHTML = `<a href="#" onclick="showLogin()">${text}</a>`;
            } else if (key === 'pause_button' && !gamePaused) {
                element.innerHTML = `⏸️ ${text}`;
            } else if (key === 'continue_button' && gamePaused) {
                 element.innerHTML = `▶️ ${text}`;
            }
            else if (key.endsWith('_button')) {
                element.innerHTML = text;
            }
            else {
                if (text) element.textContent = text;
            }
        });
        totalSnakeCoinsElement.textContent = `🪙 ${snakeCoins} ${translations[currentLanguage]['total_coins_display']}`;
        
        // Atualiza placeholder do campo de mensagem de suporte
        const supportMessageTextarea = document.getElementById('supportMessage');
        if (supportMessageTextarea) {
            supportMessageTextarea.placeholder = translations[currentLanguage]['placeholder_support_message'] || 'Descreva seu problema ou sugestão detalhadamente aqui...';
        }

        populateSkinSelector();
        selectDifficulty(currentDifficulty);
        selectMap(currentMap);
    }
    function toggleLanguageDropdown() { document.getElementById('languageDropdown').classList.toggle('show'); }
    function selectLanguage(lang) {
        currentLanguage = lang; localStorage.setItem('snakeGameLanguage', lang);
        const flagMap = { pt: 'BR', en: 'US', es: 'ES' }; const flagCode = flagMap[lang] || 'BR';
        document.getElementById('currentFlag').src = `https://flagsapi.com/${flagCode}/flat/64.png`;
        updateContent(); document.getElementById('languageDropdown').classList.remove('show');
    }
    window.addEventListener('click', function(event) { if (!event.target.closest('.language-selector')) { const dropdown = document.getElementById('languageDropdown'); if (dropdown.classList.contains('show')) { dropdown.classList.remove('show'); } } });
    document.getElementById('languageButton').addEventListener('click', toggleLanguageDropdown);
    document.querySelectorAll('.language-selector-option').forEach(option => { option.addEventListener('click', function() { selectLanguage(this.dataset.lang); }); });
    
    function selectDifficulty(difficulty) {
        currentDifficulty = difficulty;
        // Limita a busca para remover a classe 'selected' apenas dos botões na tela inicial
        document.querySelectorAll('#startScreen .difficulty-selection .difficulty-btn').forEach(btn => btn.classList.remove('selected'));
        // Limita a busca para adicionar a classe 'selected' ao botão correto na tela inicial
        document.querySelector(`#startScreen .difficulty-selection .difficulty-btn.${difficulty}`).classList.add('selected');
        difficultyInfo.textContent = difficulties[difficulty]['description_' + currentLanguage];
    }

    function selectMap(map) {
        currentMap = map; 
        document.querySelectorAll('.map-selection .difficulty-btn').forEach(btn => btn.classList.remove('selected'));
        
        // Desseleciona todos e seleciona o correto.
        const mapButtons = document.querySelectorAll('.map-selection .difficulty-btn');
        mapButtons.forEach(btn => {
            btn.classList.remove('selected');
            if (btn.getAttribute('onclick').includes(`'${map}'`)) {
                 btn.classList.add('selected');
            }
        });

        mapInfo.textContent = maps[map]['description_' + currentLanguage];
        userHighScoreDisplay.textContent = userHighScoresPerMap[currentMap] || 0;
        updateLeaderboardDisplay();
    }
    function randomTile() { return Math.floor(Math.random() * tileCount); }
    function generateFood() { food = { x: randomTile(), y: randomTile() }; for (let segment of snake) { if (segment.x === food.x && segment.y === food.y) { generateFood(); return; } } }
    
    function queueDirection(newDx, newDy) {
        if (!gameRunning || !gameStarted) return;

        // SE O JOGO ESTIVER PAUSADO, UM TOQUE DIRECIONAL IRÁ CONTINUÁ-LO
        if (gamePaused) {
            togglePause();
        }

        let lastDirection = { dx: dx, dy: dy };
        if (inputQueue.length > 0) {
            lastDirection = inputQueue[inputQueue.length - 1];
        }
        if ((newDx !== 0 && newDx === -lastDirection.dx) || (newDy !== 0 && newDy === -lastDirection.dy)) {
            return;
        }
        if (inputQueue.length < 2) {
            inputQueue.push({ dx: newDx, dy: newDy });
        }
    }

    function processInput() {
        if (gamePaused || !gameRunning || inputQueue.length === 0) {
            return;
        }
        const nextMove = inputQueue.shift();
        if ((nextMove.dx !== 0 && nextMove.dx === -dx) || (nextMove.dy !== 0 && nextMove.dy === -dy)) {
            return;
        }
        dx = nextMove.dx;
        dy = nextMove.dy;
    }

    function handleCanvasInteraction(e) {
        if (!gameRunning || gamePaused || joystickType === 'floating' || !gameStarted) {
            return;
        }
        e.preventDefault();
        if (dx === 0 && dy === 0) return;
        const rect = canvas.getBoundingClientRect();
        const touch = e.type === 'touchstart' ? e.touches[0] : e;
        const tapX = touch.clientX - rect.left;
        const tapY = touch.clientY - rect.top;
        const headCanvasX = snake[0].x * gridSize + (gridSize / 2);
        const headCanvasY = snake[0].y * gridSize + (gridSize / 2);
        const deltaX = tapX - headCanvasX;
        const deltaY = tapY - headCanvasY;
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            queueDirection(deltaX > 0 ? 1 : -1, 0);
        } else {
            queueDirection(0, deltaY > 0 ? 1 : -1);
        }
    }
    
    // ==================================================================
    // FUNÇÃO DO VISUALIZADOR DE SKINS
    // ==================================================================
    function drawSkinPreview(skinKey) {
    if (!previewCtx) return;

    const previewGridSize = 20;
    const previewCanvasWidth = skinPreviewCanvas.width;
    const previewCanvasHeight = skinPreviewCanvas.height;

    previewCtx.clearRect(0, 0, previewCanvasWidth, previewCanvasHeight);
    previewCtx.fillStyle = '#11131e';
    previewCtx.fillRect(0, 0, previewCanvasWidth, previewCanvasHeight);

    const previewSnake = [
        { x: 4, y: 1 }, { x: 3, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 1 }, { x: 0, y: 1 }
    ];
    const offsetX = 10;
    const skinOptions = skins[skinKey] || skins['default'];
    
    // Helper da teia da aranha
    const drawPreviewWebPattern = (x, y) => {
        previewCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        previewCtx.lineWidth = 1;
        previewCtx.beginPath();
        previewCtx.moveTo(x + previewGridSize / 3, y);
        previewCtx.lineTo(x + previewGridSize / 3, y + previewGridSize);
        previewCtx.moveTo(x + (previewGridSize / 3) * 2, y);
        previewCtx.lineTo(x + (previewGridSize / 3) * 2, y + previewGridSize);
        previewCtx.moveTo(x, y + previewGridSize / 3);
        previewCtx.lineTo(x + previewGridSize, y + previewGridSize / 3);
        previewCtx.moveTo(x, y + (previewGridSize / 3) * 2);
        previewCtx.lineTo(x + previewGridSize, y + (previewGridSize / 3) * 2);
        previewCtx.stroke();
    };

    // --- DESENHO DE CADA SEGMENTO, SKIN POR SKIN ---
    // Loop de trás para frente para facilitar a lógica de alguns desenhos
    for (let i = previewSnake.length - 1; i >= 0; i--) {
        const segment = previewSnake[i];
        const segmentX = segment.x * previewGridSize + offsetX;
        const segmentY = segment.y * previewGridSize;
        const isHead = (i === 0);

        if (skinKey === 'default' || skinKey === 'custom') {
            let color;
            if (isHead) {
                color = (skinKey === 'custom') ? shadeColor(document.getElementById('snakeColorPicker').value, -20) : skinOptions.headColor;
            } else {
                color = (skinKey === 'custom') ? document.getElementById('snakeColorPicker').value : skinOptions.bodyColor;
            }
            previewCtx.fillStyle = color;
            previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
        
        } else if (skinKey === 'pharaoh') {
            const goldColor = '#FFD700', blueColor = '#00008B';
            if (isHead) {
                const eyeWhiteColor = '#FFFFFF', eyePupilColor = '#000000';
                previewCtx.save();
                previewCtx.translate(segmentX + previewGridSize / 2, segmentY + previewGridSize / 2);
                previewCtx.rotate(Math.PI / 2);
                const halfGrid = previewGridSize / 2;
                previewCtx.fillStyle = blueColor; previewCtx.fillRect(-halfGrid, -halfGrid, previewGridSize, previewGridSize);
                previewCtx.fillStyle = goldColor; previewCtx.fillRect(-halfGrid, -halfGrid, previewGridSize, halfGrid * 0.2);
                previewCtx.fillRect(-halfGrid, -halfGrid * 0.2, previewGridSize, halfGrid * 0.2);
                previewCtx.fillRect(-halfGrid, halfGrid * 0.6, previewGridSize, halfGrid * 0.2);
                previewCtx.fillStyle = goldColor; previewCtx.fillRect(-halfGrid * 0.6, -halfGrid * 0.8, halfGrid * 1.2, halfGrid * 0.8);
                const eyeY = -halfGrid * 0.5, eyeX = -halfGrid * 0.2;
                previewCtx.fillStyle = eyeWhiteColor; previewCtx.fillRect(eyeX - (previewGridSize * 0.2), eyeY, previewGridSize * 0.4, previewGridSize * 0.2);
                previewCtx.fillRect(-eyeX - (previewGridSize * 0.2), eyeY, previewGridSize * 0.4, previewGridSize * 0.2);
                previewCtx.fillStyle = eyePupilColor; previewCtx.fillRect(eyeX - (previewGridSize * 0.05), eyeY, previewGridSize * 0.1, previewGridSize * 0.2);
                previewCtx.fillRect(-eyeX - (previewGridSize * 0.05), eyeY, previewGridSize * 0.1, previewGridSize * 0.2);
                const beardYStart = halfGrid * 0.1; const beardHeight = halfGrid * 0.8;
                previewCtx.fillStyle = blueColor; previewCtx.fillRect(-previewGridSize * 0.15, beardYStart, previewGridSize * 0.3, beardHeight);
                previewCtx.fillStyle = goldColor;
                for (let j = 0; j < 3; j++) { previewCtx.fillRect(-previewGridSize * 0.15, beardYStart + (j * 0.3) * beardHeight, previewGridSize * 0.3, beardHeight * 0.15); }
                previewCtx.restore();
            } else {
                const prevSegment = previewSnake[i - 1];
                const segmentDx = segment.x - prevSegment.x;
                const halfGridSize = previewGridSize / 2;
                if (segmentDx === 1) { // Lógica para corpo movendo para a direita
                    previewCtx.fillStyle = goldColor; previewCtx.fillRect(segmentX, segmentY, previewGridSize, halfGridSize);
                    previewCtx.fillStyle = blueColor; previewCtx.fillRect(segmentX, segmentY + halfGridSize, previewGridSize, halfGridSize);
                } else { // Lógica para corpo movendo para a esquerda (preview)
                    previewCtx.fillStyle = blueColor; previewCtx.fillRect(segmentX, segmentY, previewGridSize, halfGridSize);
                    previewCtx.fillStyle = goldColor; previewCtx.fillRect(segmentX, segmentY + halfGridSize, previewGridSize, halfGridSize);
                }
                if (i % 2 === 0) {
                    const dotSize = 1;
                    previewCtx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                    previewCtx.fillRect(segmentX + previewGridSize * 0.2, segmentY + previewGridSize * 0.2, dotSize, dotSize);
                    previewCtx.fillRect(segmentX + previewGridSize * 0.7, segmentY + previewGridSize * 0.8, dotSize, dotSize);
                    previewCtx.fillStyle = 'rgba(0, 0, 139, 0.8)';
                    previewCtx.fillRect(segmentX + previewGridSize * 0.8, segmentY + previewGridSize * 0.3, dotSize, dotSize);
                    previewCtx.fillRect(segmentX + previewGridSize * 0.3, segmentY + previewGridSize * 0.7, dotSize, dotSize);
                }
            }
        } else if (skinKey === 'spider') {
            if (isHead) {
                previewCtx.fillStyle = skinOptions.redColor;
                previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                drawPreviewWebPattern(segmentX, segmentY);
                const eyeXOffset = previewGridSize * 0.2, eyeYOffset = previewGridSize * 0.2;
                const eyeWidth = previewGridSize * 0.25, eyeHeight = previewGridSize * 0.5;
                previewCtx.fillStyle = 'white';
                previewCtx.fillRect(segmentX + eyeXOffset, segmentY + eyeYOffset, eyeWidth, eyeHeight);
                previewCtx.fillRect(segmentX + previewGridSize - 2 - eyeXOffset - eyeWidth, segmentY + eyeYOffset, eyeWidth, eyeHeight);
                previewCtx.strokeStyle = 'black';
                previewCtx.lineWidth = 1.5;
                previewCtx.strokeRect(segmentX + eyeXOffset, segmentY + eyeYOffset, eyeWidth, eyeHeight);
                previewCtx.strokeRect(segmentX + previewGridSize - 2 - eyeXOffset - eyeWidth, segmentY + eyeYOffset, eyeWidth, eyeHeight);
            } else {
                const isRedSegment = i % 2 === 0;
                previewCtx.fillStyle = isRedSegment ? skinOptions.redColor : skinOptions.blueColor;
                previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                if (isRedSegment) drawPreviewWebPattern(segmentX, segmentY);
            }
        } else if (skinKey === 'coral') {
                const [c1, c2, c3] = skinOptions.colors;
                if (isHead) {
                    previewCtx.fillStyle = c2; 
                    previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                    const mouthSize = Math.max(2, Math.floor(previewGridSize / 6));
                    previewCtx.fillStyle = c3;
                    // CORREÇÃO: A boca agora fica na direita, na direção do movimento
                    previewCtx.fillRect(segmentX + previewGridSize - 2 - mouthSize, segmentY + mouthSize, mouthSize, previewGridSize - 2 - (2 * mouthSize));
                } else {
                    const patternIndex = (i - 1) % 4;
                    const halfSize = (previewGridSize - 2) / 2;

                    switch (patternIndex) {
                        case 0:
                            previewCtx.fillStyle = c1;
                            previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                            break;
                        case 1: 
                        case 2:
                            // A cobra está na horizontal, a divisão é na VERTICAL.
                            // A ordem de cor é Preto/Branco.
                            const firstColor = c3;
                            const secondColor = c2;
                            
                            previewCtx.fillStyle = firstColor;
                            previewCtx.fillRect(segmentX, segmentY, halfSize, previewGridSize - 2);
                            previewCtx.fillStyle = secondColor;
                            previewCtx.fillRect(segmentX + halfSize, segmentY, halfSize, previewGridSize - 2);
                            break;
                        case 3:
                            previewCtx.fillStyle = c2;
                            previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                            break;
                    }
                }
        } else if (skinKey === 'windowsClassic') {
           const blueScreenColor = '#0000AA';
           const folderColor = '#FFD700';
           const textColor = '#FFFFFF';

           if (isHead) {
               const growth = 2;
               const baseSize = previewGridSize - 2;
               const headY = segmentY + (previewGridSize * 0.1) - (growth / 2);
               const headX = segmentX - (growth / 2);
               const headSize = baseSize + growth;

               const bezelColor = '#DCDCDC';
               const shadowColor = '#888888';
               const highlightColor = '#FFFFFF';

               previewCtx.fillStyle = bezelColor;
               previewCtx.fillRect(headX, headY, headSize, headSize);
               previewCtx.fillStyle = highlightColor;
               previewCtx.fillRect(headX, headY, headSize, 1);
               previewCtx.fillRect(headX, headY, 1, headSize);
               previewCtx.fillStyle = shadowColor;
               previewCtx.fillRect(headX, headY + headSize - 1, headSize, 1);
               previewCtx.fillRect(headX + headSize - 1, headY, 1, headSize);

               const screenX = headX + 3;
               const screenY = headY + 3;
               const screenSize = headSize - 6;
               const skyColor = '#4595E7';
               const hillColor = '#58B435';
               const cloudColor = '#FFFFFF';

               previewCtx.fillStyle = skyColor;
               previewCtx.fillRect(screenX, screenY, screenSize, screenSize);
               previewCtx.fillStyle = hillColor;
               previewCtx.beginPath();
               previewCtx.moveTo(screenX, screenY + screenSize * 0.5);
               previewCtx.quadraticCurveTo(screenX + screenSize / 2, screenY + screenSize * 0.4, screenX + screenSize, screenY + screenSize * 0.6);
               previewCtx.lineTo(screenX + screenSize, screenY + screenSize);
               previewCtx.lineTo(screenX, screenY + screenSize);
               previewCtx.closePath();
               previewCtx.fill();
               previewCtx.fillStyle = cloudColor;
               previewCtx.fillRect(screenX + screenSize * 0.55, screenY + screenSize * 0.15, screenSize * 0.3, screenSize * 0.1);
               previewCtx.fillRect(screenX + screenSize * 0.2, screenY + screenSize * 0.25, screenSize * 0.35, screenSize * 0.1);
           } else {
               // Ícone de pasta na pré-visualização
               const backColor = '#FBC02D';
               const frontColor = '#FFF176';
               const handleColor = '#64B5F6';
               const size = previewGridSize;

               previewCtx.fillStyle = backColor;
               previewCtx.beginPath();
               previewCtx.rect(segmentX + 1, segmentY + size * 0.2, size - 2, size * 0.8 - 1);
               previewCtx.rect(segmentX + 1, segmentY + size * 0.1, size * 0.4, size * 0.2);
               previewCtx.fill();
               
               previewCtx.fillStyle = frontColor;
               previewCtx.fillRect(segmentX + 1, segmentY + size * 0.3, size - 2, size * 0.7 - 1);

               previewCtx.fillStyle = handleColor;
               const handleY = segmentY + size * 0.55;
               const handleHeight = size * 0.4;
               const legWidth = size * 0.2;
               previewCtx.fillRect(segmentX + size * 0.15, handleY, legWidth, handleHeight);
               previewCtx.fillRect(segmentX + size - size * 0.15 - legWidth, handleY, legWidth, handleHeight);
               previewCtx.fillRect(segmentX + size * 0.15, handleY + handleHeight - legWidth, size - (size * 0.15 * 2), legWidth);
           }
        } else if (skinKey === 'galaxy') {
            previewCtx.fillStyle = isHead ? skinOptions.headColor : skinOptions.colors[i % skinOptions.colors.length];
            previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
            previewCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            previewCtx.fillRect(segmentX + Math.random() * (previewGridSize-2), segmentY + Math.random() * (previewGridSize-2), isHead ? 1.5 : 1, isHead ? 1.5 : 1);
        
        } else if (skinKey === 'camo') {
            if (isHead) {
                previewCtx.fillStyle = skinOptions.headColor;
            } else {
                previewCtx.fillStyle = skinOptions.colors[i % skinOptions.colors.length];
            }
            previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
        
        } else if (skinKey === 'christmas') {
            const currentGridSize = 20; // Tamanho da grade do preview
            const segX = segment.x * currentGridSize + 10;
            const segY = segment.y * currentGridSize;
            const centerX = segX + currentGridSize / 2;
            const centerY = segY + currentGridSize / 2;
            const radius = (currentGridSize / 2) + 1;

            previewCtx.shadowColor = skinOptions.glowColor;
            previewCtx.shadowBlur = 8;

            previewCtx.fillStyle = skinOptions.shadowColor;
            previewCtx.beginPath();
            previewCtx.arc(centerX, centerY + 1, radius - 1.5, 0, 2 * Math.PI);
            previewCtx.fill();
            previewCtx.fillStyle = skinOptions.bodyColor;
            previewCtx.beginPath();
            previewCtx.arc(centerX, centerY, radius - 1.5, 0, 2 * Math.PI);
            previewCtx.fill();
            previewCtx.strokeStyle = skinOptions.outlineColor;
            previewCtx.lineWidth = 2;
            previewCtx.beginPath();
            previewCtx.arc(centerX, centerY, radius - 1.5, 0, 2 * Math.PI);
            previewCtx.stroke();
            
            previewCtx.shadowColor = 'transparent';
            previewCtx.shadowBlur = 0;

            if (isHead) {
                previewCtx.save();
                previewCtx.translate(centerX, centerY);
                // A preview sempre vai para a direita, então dx=1, dy=0
                let rotation = Math.PI / 2;
                previewCtx.rotate(rotation);
                previewCtx.fillStyle = skinOptions.eyeColor;
                const eyeRadius = currentGridSize / 12;
                previewCtx.beginPath();
                previewCtx.arc(-radius / 2.5, -radius / 2.5, eyeRadius, 0, 2 * Math.PI);
                previewCtx.arc(radius / 2.5, -radius / 2.5, eyeRadius, 0, 2 * Math.PI);
                previewCtx.fill();
                const mouthDotRadius = currentGridSize / 20;
                for (let j = 0; j < 5; j++) {
                    const angle = Math.PI * 0.6 + (j * Math.PI * 0.2) / 4;
                    const mouthX = Math.cos(angle) * radius * 0.6;
                    const mouthY = Math.sin(angle) * radius * 0.6;
                    previewCtx.beginPath();
                    previewCtx.arc(mouthX, mouthY, mouthDotRadius, 0, 2 * Math.PI);
                    previewCtx.fill();
                }
                previewCtx.fillStyle = skinOptions.noseColor;
                previewCtx.beginPath();
                previewCtx.moveTo(0, -eyeRadius);
                previewCtx.lineTo(0, eyeRadius);
                previewCtx.lineTo(radius * 0.7, 0);
                previewCtx.closePath();
                previewCtx.fill();
                previewCtx.restore();
            } else {
                const prevSegment = previewSnake[i - 1]; // Usa a array correta
                const prevSegX = prevSegment.x * currentGridSize + 10;
                const prevSegY = prevSegment.y * currentGridSize;
                const prevCenterX = prevSegX + currentGridSize / 2;
                const prevCenterY = prevSegY + currentGridSize / 2;
                const segDx_preview = segment.x - prevSegment.x;
                const segDy_preview = segment.y - prevSegment.y;
                
                previewCtx.strokeStyle = skinOptions.wireColor;
                previewCtx.lineWidth = 1.5;
                previewCtx.beginPath();
                previewCtx.moveTo(prevCenterX, prevCenterY);
                previewCtx.lineTo(centerX, centerY);
                previewCtx.stroke();
                
                let entryPoint, exitPoint, controlPoint, remainingArc;
                if (segDx_preview === 1) { entryPoint = { x: centerX - radius, y: centerY }; exitPoint = { x: prevCenterX + radius, y: prevCenterY }; controlPoint = { x: (centerX + prevCenterX) / 2, y: centerY + radius / 1.5 }; remainingArc = { start: Math.PI / 2, end: -Math.PI / 2 }; } 
                else if (segDx_preview === -1) { entryPoint = { x: centerX + radius, y: centerY }; exitPoint = { x: prevCenterX - radius, y: prevCenterY }; controlPoint = { x: (centerX + prevCenterX) / 2, y: centerY - radius / 1.5 }; remainingArc = { start: -Math.PI / 2, end: Math.PI / 2 }; } 
                else if (segDy_preview === 1) { entryPoint = { x: centerX, y: centerY - radius }; exitPoint = { x: prevCenterX, y: prevCenterY + radius }; controlPoint = { x: centerX - radius / 1.5, y: (centerY + prevCenterY) / 2 }; remainingArc = { start: 0, end: Math.PI }; } 
                else { entryPoint = { x: centerX, y: centerY + radius }; exitPoint = { x: prevCenterX, y: prevCenterY - radius }; controlPoint = { x: centerX + radius / 1.5, y: (centerY + prevCenterY) / 2 }; remainingArc = { start: Math.PI, end: 0 }; }
                
                previewCtx.strokeStyle = skinOptions.wireColor;
                previewCtx.lineWidth = 2.5;
                previewCtx.beginPath();
                previewCtx.moveTo(exitPoint.x, exitPoint.y);
                previewCtx.quadraticCurveTo(controlPoint.x, controlPoint.y, entryPoint.x, entryPoint.y);
                previewCtx.stroke();
                previewCtx.beginPath();
                previewCtx.arc(centerX, centerY, radius - 1.5, remainingArc.start, remainingArc.end, segDx_preview === -1 || segDy_preview === 0);
                previewCtx.stroke();
            }
        } else if (skinKey === 'halloween') {
            const pumpkinColor = skinOptions.headColor;
            const bodyBlack = skinOptions.bodyColor1;
            const bodyPurple = skinOptions.bodyColor2;
            const lineOrange = skinOptions.lineColor;

            if (isHead) {
                // Cabeça de abóbora
                previewCtx.fillStyle = pumpkinColor;
                previewCtx.fillRect(segmentX, segmentY, previewGridSize, previewGridSize);

                // Rosto entalhado (preto)
                previewCtx.fillStyle = '#000000';
                const pg_half = previewGridSize / 2;
                
                // Olho esquerdo (triângulo)
                previewCtx.beginPath();
                previewCtx.moveTo(segmentX + previewGridSize * 0.2, segmentY + previewGridSize * 0.2);
                previewCtx.lineTo(segmentX + previewGridSize * 0.4, segmentY + previewGridSize * 0.4);
                previewCtx.lineTo(segmentX + previewGridSize * 0.2, segmentY + previewGridSize * 0.4);
                previewCtx.closePath();
                previewCtx.fill();
                
                // Olho direito (triângulo)
                previewCtx.beginPath();
                previewCtx.moveTo(segmentX + previewGridSize * 0.8, segmentY + previewGridSize * 0.2);
                previewCtx.lineTo(segmentX + previewGridSize * 0.6, segmentY + previewGridSize * 0.4);
                previewCtx.lineTo(segmentX + previewGridSize * 0.8, segmentY + previewGridSize * 0.4);
                previewCtx.closePath();
                previewCtx.fill();
                
                // Nariz (triângulo)
                previewCtx.beginPath();
                previewCtx.moveTo(segmentX + pg_half, segmentY + pg_half - (pg_half * 0.1));
                previewCtx.lineTo(segmentX + pg_half - (pg_half * 0.2), segmentY + pg_half + (pg_half * 0.2));
                previewCtx.lineTo(segmentX + pg_half + (pg_half * 0.2), segmentY + pg_half + (pg_half * 0.2));
                previewCtx.closePath();
                previewCtx.fill();

                // Boca Sorridente
                const mouthY_abs = segmentY + pg_half + (pg_half * 0.4);
                previewCtx.fillRect(segmentX + pg_half - (pg_half * 0.8), mouthY_abs, pg_half * 1.6, pg_half * 0.2); // Linha principal
                previewCtx.fillRect(segmentX + pg_half - (pg_half * 0.5), mouthY_abs - (pg_half * 0.2), pg_half * 0.2, pg_half * 0.2); // Dente 1
                previewCtx.fillRect(segmentX + pg_half + (pg_half * 0.3), mouthY_abs - (pg_half * 0.2), pg_half * 0.2, pg_half * 0.2); // Dente 2
            } else {
                // Desenha a borda interna primeiro
                previewCtx.fillStyle = bodyPurple; // Borda superior/esquerda
                previewCtx.fillRect(segmentX, segmentY, previewGridSize, previewGridSize);
                previewCtx.fillStyle = bodyBlack; // Borda inferior/direita
                previewCtx.fillRect(segmentX + 0, segmentY + 1, previewGridSize + 3, previewGridSize + 3);

                // Corpo: Metade preto, metade roxo com linha laranja (desenhado dentro da borda)
                const fillSize = previewGridSize - 2;
                const fillX = segmentX + 1;
                const fillY = segmentY + 1;
                const halfFillSize = fillSize / 2;
                const lineSize = 2;

                // Metade preta (superior)
                previewCtx.fillStyle = bodyBlack;
                previewCtx.fillRect(fillX, fillY, fillSize, halfFillSize - (lineSize/2));

                // Metade roxa (inferior)
                previewCtx.fillStyle = bodyPurple;
                previewCtx.fillRect(fillX, fillY + halfFillSize + (lineSize/2), fillSize, halfFillSize - (lineSize/2));

                // Linha laranja no meio
                previewCtx.fillStyle = lineOrange;
                previewCtx.fillRect(fillX, fillY + halfFillSize - (lineSize/2), fillSize, lineSize);
            }
        }
    }
    // PASS 2 for preview: Draw connectors
    if (skinKey === 'halloween') {
        const lineOrange = skins.halloween.lineColor;
        const bodyBlack = skins.halloween.bodyColor1;
        const bodyPurple = skins.halloween.bodyColor2;
        const lineSize = 2;

        for (let i = 1; i < previewSnake.length; i++) {
             // Preview é sempre horizontal, então o conector é sempre vertical
            const curr = previewSnake[i];
            const connX = (curr.x * previewGridSize) + offsetX - 1;
            const connY = curr.y * previewGridSize + 1;
            const connW = 2;
            const connH = previewGridSize - 2;
            
            const halfSize = connH / 2;
            previewCtx.fillStyle = bodyBlack;
            previewCtx.fillRect(connX, connY, connW, halfSize - lineSize / 2);
            previewCtx.fillStyle = bodyPurple;
            previewCtx.fillRect(connX, connY + halfSize + lineSize / 2, connW, halfSize - lineSize / 2);
            previewCtx.fillStyle = lineOrange;
            previewCtx.fillRect(connX, connY + halfSize - lineSize / 2, connW, lineSize);
        }
    }
}

    // SUBSTITUA a sua função drawGame por esta:
function drawGame() {
    // A LINHA QUE LIMPAVA O CANVAS FOI REMOVIDA DAQUI
    
    // 1. Chama a função unificada para desenhar a cobra
    drawSnakeOnCanvas(ctx, snake, currentSkin, { dx, dy }, document.getElementById('snakeColorPicker').value);

    // 2. Desenha a comida
    ctx.fillStyle = '#e17055';
    ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);
    ctx.fillStyle = '#fd79a8';
    ctx.fillRect(food.x * gridSize + 2, food.y * gridSize + 2, gridSize - 6, gridSize - 6);
}
    
    function updateGame() {
        if (!gameRunning || gamePaused) return; if (dx === 0 && dy === 0) return;
        const head = {x: snake[0].x + dx, y: snake[0].y + dy};
        if (maps[currentMap].wrapAround) {
            if (head.x < 0) head.x = tileCount - 1; else if (head.x >= tileCount) head.x = 0;
            if (head.y < 0) head.y = tileCount - 1; else if (head.y >= tileCount) head.y = 0;
        } else { if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) { gameOver(); return; } }
        for (let segment of snake) { if (head.x === segment.x && head.y === segment.y) { gameOver(); return; } }
        snake.unshift(head);
        if (head.x === food.x && head.y === food.y) {
            foodEatenThisGame++;
            let foodPoints = difficulties[currentDifficulty].points;
            score += foodPoints;
            scoreElement.textContent = score;
            const newCoins = Math.floor(score / 40) - coinsEarnedThisGame;
            if (newCoins > 0) {
                coinsEarnedThisGame += newCoins;
            }
            generateFood();
        } else { snake.pop(); }
    }

    async function updateLeaderboardDisplay() {
        try {
            const difficultyEmojis = { easy: '🐌', normal: '🐍', hard: '🚀', insane: '💀' };
            const mapIdentifier = currentMap || 'normal';
            const user = auth.currentUser;
            const querySnapshot = await db.collection('scores').where('map', '==', mapIdentifier).orderBy('score', 'desc').limit(3).get();
            const topScores = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            for (let i = 1; i <= 3; i++) {
                document.getElementById(`leaderboard-item-${i}`).style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
            }

            firstName.textContent = "---"; firstScore.textContent = "0"; firstDifficulty.textContent = "";
            secondName.textContent = "---"; secondScore.textContent = "0"; secondDifficulty.textContent = "";
            thirdName.textContent = "---"; thirdScore.textContent = "0"; thirdDifficulty.textContent = "";

            if (topScores[0]) {
                firstName.textContent = topScores[0].name; firstScore.textContent = topScores[0].score; firstDifficulty.textContent = difficultyEmojis[topScores[0].difficulty] || '🐍';
                if (user && topScores[0].userId === user.uid) { document.getElementById('leaderboard-item-1').style.backgroundColor = '#d68910'; }
            }
            if (topScores[1]) {
                secondName.textContent = topScores[1].name; secondScore.textContent = topScores[1].score; secondDifficulty.textContent = difficultyEmojis[topScores[1].difficulty] || '🐍';
                if (user && topScores[1].userId === user.uid) { document.getElementById('leaderboard-item-2').style.backgroundColor = '#d68910'; }
            }
            if (topScores[2]) {
                thirdName.textContent = topScores[2].name; thirdScore.textContent = topScores[2].score; thirdDifficulty.textContent = difficultyEmojis[topScores[2].difficulty] || '🐍';
                if (user && topScores[2].userId === user.uid) { document.getElementById('leaderboard-item-3').style.backgroundColor = '#d68910'; }
            }
            
            userHighScoreDisplay.textContent = userHighScoresPerMap[currentMap] || 0;

        } catch (error) {
            console.error("Erro ao buscar o leaderboard online: ", error);
            firstName.textContent = "ERRO";
        }
    }

    // FUNÇÃO DE COMPRA ATUALIZADA PARA FUNCIONAR EM AMBOS OS MENUS
async function handlePurchase(isPvpMenu = false) {
    // Determina qual botão de compra e seletor usar com base no menu
    const buyBtnId = isPvpMenu ? 'buySkinBtnPvp' : 'buySkinBtn';
    const selectorId = isPvpMenu ? 'skinSelectorPvp' : 'skinSelector';

    const buyBtn = document.getElementById(buyBtnId);
    const skinKey = buyBtn.dataset.skinToBuy;
    if (!skinKey) return;

    const skin = skins[skinKey];
    if (!skin || !skin.unlockCoins) return;

    if (snakeCoins < skin.unlockCoins) {
        alert(translations[currentLanguage]['not_enough_coins']);
        return;
    }

    if (confirm(`${translations[currentLanguage]['confirm_buy_skin']} ${skin.unlockCoins} SC?`)) {
        // Atualiza o estado local do jogador
        snakeCoins -= skin.unlockCoins;
        unlockedSkins.push(skinKey);
        currentSkin = skinKey; 
        
        // Salva os dados atualizados no Firebase
        await updateUserCoins(snakeCoins);
        await updateUserUnlockedSkins(unlockedSkins);
        
        // Atualiza a UI
        totalSnakeCoinsElement.textContent = `🪙 ${snakeCoins} ${translations[currentLanguage]['total_coins_display']}`;
        alert(translations[currentLanguage]['skin_unlocked_success']);
        buyBtn.style.display = 'none';

        // ========================================================================
        // MODIFICAÇÃO PRINCIPAL: Atualiza ambos os seletores para manter a consistência
        // ========================================================================
        populateSkinSelector();      // Atualiza o seletor do menu single-player
        populatePvpSkinSelector();   // Atualiza o seletor do menu PvP

        // Garante que o seletor do menu que você está usando reflita a nova skin
        document.getElementById(selectorId).value = currentSkin;
        
        // Garante que o outro seletor também seja atualizado, caso o usuário troque de menu
        const otherSelectorId = isPvpMenu ? 'skinSelector' : 'skinSelectorPvp';
        document.getElementById(otherSelectorId).value = currentSkin;
    }
}
    async function isNewRecord(score) {
        try {
            if (!currentUsername) return false;
            const querySnapshot = await db.collection('scores').where('map', '==', currentMap).orderBy('score', 'desc').limit(3).get();
            const topScores = querySnapshot.docs.map(doc => doc.data());
            return topScores.length < 3 || score > topScores[topScores.length - 1].score;
        } catch (error) {
            console.error("Erro ao verificar recorde: ", error);
            return false;
        }
    }

    async function saveScore() {
        const user = auth.currentUser;
        if (!user || !currentUsername) return;
        try {
            const name = currentUsername.substring(0, 15).toUpperCase();
            const newEntry = { userId: user.uid, name, score, difficulty: currentDifficulty, map: currentMap, foodCount: foodEatenThisGame, skin: currentSkin, timestamp: firebase.firestore.FieldValue.serverTimestamp() };
            await db.collection('scores').add(newEntry);
            await updateLeaderboardDisplay();
        } catch (error) {
            console.error("Erro ao salvar a pontuação no servidor: ", error);
        }
    }

    function triggerFireworks() {
        congratulationsScreen.style.display = 'flex';
        function createFirework() {
            const firework = document.createElement('div'); firework.className = 'firework';
            const colors = ['#ffc700', '#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#00ffff'];
            firework.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            firework.style.left = Math.random() * window.innerWidth + 'px'; firework.style.top = Math.random() * window.innerHeight + 'px';
            document.body.appendChild(firework);
            setTimeout(() => { firework.remove(); }, 1200);
        }
        fireworksInterval = setInterval(createFirework, 300);
    }
    function enterFullScreen(element) {
    const options = { navigationUI: "hide" };

    if (element.requestFullscreen) {
        element.requestFullscreen(options);
    } else if (element.mozRequestFullScreen) { // Firefox
        element.mozRequestFullScreen(options);
    } else if (element.webkitRequestFullscreen) { // Chrome, Safari e Opera
        element.webkitRequestFullscreen(options);
    } else if (element.msRequestFullscreen) { // IE/Edge
        element.msRequestFullscreen(); // Edge não suporta options
    }
}
    function startGame() {
        enterFullScreen(document.documentElement);
        inputQueue = [];
        snake = [{x: Math.floor(tileCount/2), y: Math.floor(tileCount/2)}]; dx = 0; dy = 0; score = 0; scoreElement.textContent = score;
        coinsEarnedThisGame = 0;
        foodEatenThisGame = 0;
        gameRunning = true; gameStarted = true; gamePaused = false;
        startScreen.style.display = 'none'; toggleJoystick();
        pauseBtn.style.display = 'inline-block'; quitGameBtn.style.display = 'inline-block'; gameInstructions.style.display = 'block'; difficultyDisplay.style.display = 'block';
        const difficultyConfig = difficulties[currentDifficulty];
        currentDifficultyText.textContent = `${difficultyConfig.emoji} ${difficultyConfig['name_' + currentLanguage]}`;
        generateFood();
        if (gameInterval) { clearInterval(gameInterval); }
        gameInterval = setInterval(gameLoop, difficultyConfig.speed);
    }
    function togglePause() { 
        if (!gameRunning || !gameStarted) return; 
        gamePaused = !gamePaused; 
        pauseBtn.innerHTML = gamePaused ? `▶️ ${translations[currentLanguage].continue_button}` : `⏸️ ${translations[currentLanguage].pause_button}`; 
    }
    function quitGame() {
        // Pausa o jogo se ele não estiver pausado.
        if (!gamePaused) {
            togglePause();
        }
        // Exibe o nosso novo modal de confirmação personalizado.
        document.getElementById('quitConfirmModal').style.display = 'flex';
    }

    // 2. ADICIONE estas duas novas funções ao seu script:
    function handleConfirmQuit() {
        // Esconde o modal.
        document.getElementById('quitConfirmModal').style.display = 'none';
        // Reinicia o jogo (volta para a tela de menu).
        restartGame();
    }

    function handleCancelQuit() {
        // Apenas esconde o modal.
        document.getElementById('quitConfirmModal').style.display = 'none';
        // O jogo continuará pausado, esperando que você pressione o botão de "Continuar" (▶️).
    }
    
    async function gameOver() {
    // Primeiramente, paramos a lógica principal do jogo
    gameRunning = false;
    gameStarted = false;
    if (gameInterval) {
        clearInterval(gameInterval);
    }

    // Escondemos botões de controle para evitar cliques
    quitGameBtn.style.display = 'none';
    reenterPrompt.style.display = 'none';

    // O bloco try...catch é a nossa rede de segurança. Se algo der errado
    // (como a cota excedida), o jogo não vai travar, ele vai pular para o 'catch'.
    try {
        const user = auth.currentUser;
        // Se não houver usuário logado, não há o que salvar.
        // Apenas mostramos a tela de game over padrão.
        if (!user || !currentUsername) {
            finalScoreElement.textContent = score;
            coinsEarnedGameOverElement.textContent = 0;
            gameOverElement.style.display = 'flex';
            return; // Encerra a função aqui.
        }

        // --- AQUI COMEÇA A NOSSA OTIMIZAÇÃO ---

        // 1. Inicia um lote. Pense nele como uma "caixa de envio".
        const batch = db.batch();

        // 2. Colocamos todas as nossas "cartas" (operações) dentro da caixa, uma por uma.
        //    Note que não usamos 'await' aqui. As operações são apenas preparadas.

        // Operação A: Log para o painel de admin
        if (score > 0) {
            const gameLogRef = db.collection('game_logs').doc(); // Pega uma referência para um novo documento
            batch.set(gameLogRef, {
                userId: user.uid,
                username: currentUsername,
                score: score,
                difficulty: currentDifficulty,
                map: currentMap,
                skin: currentSkin,
                foodCount: foodEatenThisGame,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
        }

        // Operação B: Incrementa o contador geral de partidas
        const statsRef = db.collection('game_stats').doc('counters');
        batch.set(statsRef, { totalGamesPlayed: firebase.firestore.FieldValue.increment(1) }, { merge: true });

        // Operação C: Atualiza os dados do usuário (moedas e, se necessário, o recorde pessoal)
        const newTotalCoins = snakeCoins + coinsEarnedThisGame;
        const currentMapHighScore = userHighScoresPerMap[currentMap] || 0;
        const userRef = db.collection('users').doc(user.uid);
        
        const userDataUpdate = {
            snakeCoins: newTotalCoins
        };
        // Só adicionamos a atualização de recorde ao pacote se um novo recorde foi batido
        if (score > currentMapHighScore) {
            userDataUpdate[`highScoresPerMap.${currentMap}`] = score;
        }
        batch.update(userRef, userDataUpdate);
        
        // Operação D: Salva no placar do TOP 3 (leaderboard), mas só se for um novo recorde
        // Primeiro, verificamos se é um novo recorde (isso é uma leitura, então fica fora do lote)
        const newRecord = await isNewRecord(score); 
        if (newRecord && score > 0) {
            const scoreRef = db.collection('scores').doc(); // Pega referência para um novo score
            batch.set(scoreRef, {
                userId: user.uid,
                name: currentUsername.substring(0, 15).toUpperCase(),
                score,
                difficulty: currentDifficulty,
                map: currentMap,
                foodCount: foodEatenThisGame,
                skin: currentSkin,
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });
        }

        // 3. Agora, enviamos a "caixa" com tudo dentro para o Firebase de uma só vez!
        //    Isso conta como UMA ÚNICA ESCRITA na sua cota.
        console.log("Enviando lote de operações para o Firestore...");
        await batch.commit();
        console.log("Lote enviado com sucesso!");
        
        // --- FIM DA OTIMIZAÇÃO ---

        // Se o código chegou até aqui, significa que o 'batch.commit()' funcionou.
        // Agora podemos atualizar a interface do usuário com segurança.
        snakeCoins = newTotalCoins;
        totalSnakeCoinsElement.textContent = `🪙 ${snakeCoins} ${translations[currentLanguage]['total_coins_display']}`;
        if (score > currentMapHighScore) {
            userHighScoresPerMap[currentMap] = score;
            userHighScoreDisplay.textContent = score;
        }

        // E, finalmente, mostramos a tela de fim de jogo correta.
        if (newRecord && score > 0) {
            await updateLeaderboardDisplay();
            finalScoreCongrats.textContent = score;
            coinsEarnedCongratsElement.textContent = coinsEarnedThisGame;
            triggerFireworks();
        } else {
            finalScoreElement.textContent = score;
            coinsEarnedGameOverElement.textContent = coinsEarnedThisGame;
            gameOverElement.style.display = 'flex';
        }

    } catch (error) {
        // PLANO B: Se o 'try' falhar em qualquer ponto (especialmente no 'batch.commit()'),
        // o jogo não vai mais travar. Ele virá para cá.
        console.error("Falha ao salvar dados no Firestore (Cota excedida ou erro de rede):", error);
        
        // Mostramos a tela de Game Over padrão para o jogador não ficar numa tela congelada.
        finalScoreElement.textContent = score;
        coinsEarnedGameOverElement.textContent = coinsEarnedThisGame;
        gameOverElement.style.display = 'flex';
        
        // Opcional: Avisar o jogador que a pontuação não foi salva.
        alert("Sua pontuação foi ótima, mas não conseguimos salvá-la. Verifique sua conexão ou tente novamente mais tarde.");
    }
}

    function restartGame() {        
        if (gameInterval) { clearInterval(gameInterval); }
        if (fireworksInterval) { clearInterval(fireworksInterval); fireworksInterval = null; }
        inputQueue = [];
        congratulationsScreen.style.display = 'none'; reenterPrompt.style.display = 'none';
        snake = [{x: Math.floor(tileCount/2), y: Math.floor(tileCount/2)}];
        dx = 0; dy = 0; score = 0; gameRunning = false; gameStarted = false; gamePaused = false;
        scoreElement.textContent = score; gameOverElement.style.display = 'none'; startScreen.style.display = 'block';
        gameControls.style.display = 'none'; pauseBtn.style.display = 'none'; quitGameBtn.style.display = 'none';
        gameInstructions.style.display = 'none'; difficultyDisplay.style.display = 'none';
        pauseBtn.innerHTML = `⏸️ ${translations[currentLanguage].pause_button}`;
        ctx.fillStyle = '#2d3436'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        updateLeaderboardDisplay();
    }
    async function logGameForAnalytics() {
    const user = auth.currentUser;
    if (!user || !currentUsername) return;
    try {
        // Salva os dados em uma NOVA coleção, apenas para as análises.
        await db.collection('game_logs').add({
            userId: user.uid,
            username: currentUsername,
            score: score,
            difficulty: currentDifficulty,
            map: currentMap,
            skin: currentSkin,
            foodCount: foodEatenThisGame,
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
    } catch (error) {
        console.error("Erro ao registrar log do jogo para análises:", error);
    }
}
    function gameLoop() {    
    processInput();
    updateGame();
    ctx.fillStyle = document.getElementById('gameBackgroundColor').value || '#11131e';
    ctx.fillRect(0, 0, canvas.width, canvas.height);       
    drawGame();           // Cobra e comida (desenhada por último, fica na frente)
}
    document.getElementById('upBtn').addEventListener('touchstart', (e) => { e.preventDefault(); queueDirection(0, -1); });
    document.getElementById('downBtn').addEventListener('touchstart', (e) => { e.preventDefault(); queueDirection(0, 1); });
    document.getElementById('leftBtn').addEventListener('touchstart', (e) => { e.preventDefault(); queueDirection(-1, 0); });
    document.getElementById('rightBtn').addEventListener('touchstart', (e) => { e.preventDefault(); queueDirection(1, 0); });
    const pvpUpBtn = document.querySelector('#pvpGameControls .up');
    const pvpDownBtn = document.querySelector('#pvpGameControls .down');
    const pvpLeftBtn = document.querySelector('#pvpGameControls .left');
    const pvpRightBtn = document.querySelector('#pvpGameControls .right');

    // Adiciona os listeners de toque (touchstart) para cada botão
    // Eles chamarão a função queuePvpDirection(), que é a correta para o modo PvP

    pvpUpBtn.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Previne comportamentos padrão do navegador (como zoom)
        queuePvpDirection(0, -1);
    });

    pvpDownBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        queuePvpDirection(0, 1);
    });

    pvpLeftBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        queuePvpDirection(-1, 0);
    });

    pvpRightBtn.addEventListener('touchstart', (e) => {
        e.preventDefault();
        queuePvpDirection(1, 0);
    });

    const gameControlsContainer = document.getElementById('gameControls');
    gameControlsContainer.addEventListener('touchstart', (e) => {
        if (e.target !== gameControlsContainer) {
            return;
        }
        e.preventDefault();

        const touch = e.touches[0];
        const touchX = touch.clientX;
        const touchY = touch.clientY;

        const buttons = {
            up: document.getElementById('upBtn'),
            down: document.getElementById('downBtn'),
            left: document.getElementById('leftBtn'),
            right: document.getElementById('rightBtn')
        };

        let nearestButton = null;
        let minDistance = Infinity;

        for (const [direction, buttonElement] of Object.entries(buttons)) {
            const rect = buttonElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const distanceSq = Math.pow(touchX - centerX, 2) + Math.pow(touchY - centerY, 2);

            if (distanceSq < minDistance) {
                minDistance = distanceSq;
                nearestButton = direction;
            }
        }

        if (nearestButton) {
            switch(nearestButton) {
                case 'up': queueDirection(0, -1); break;
                case 'down': queueDirection(0, 1); break;
                case 'left': queueDirection(-1, 0); break;
                case 'right': queueDirection(1, 0); break;
            }
        }
    }, { passive: false });

const pvpControlsContainer = document.getElementById('pvpGameControls');
    pvpControlsContainer.addEventListener('touchstart', (e) => {
        // Garante que a lógica só se aplique a toques no fundo do container, não nos botões
        if (e.target !== pvpControlsContainer) {
            return;
        }
        e.preventDefault();

        const touch = e.touches[0];
        const touchX = touch.clientX;
        const touchY = touch.clientY;

        // Mapeia os botões direcionais do PvP
        const pvpButtons = {
            up: document.querySelector('#pvpGameControls .up'),
            down: document.querySelector('#pvpGameControls .down'),
            left: document.querySelector('#pvpGameControls .left'),
            right: document.querySelector('#pvpGameControls .right')
        };

        let nearestButton = null;
        let minDistance = Infinity;

        // Calcula qual botão está mais próximo do local do toque
        for (const [direction, buttonElement] of Object.entries(pvpButtons)) {
            const rect = buttonElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const distanceSq = Math.pow(touchX - centerX, 2) + Math.pow(touchY - centerY, 2);

            if (distanceSq < minDistance) {
                minDistance = distanceSq;
                nearestButton = direction;
            }
        }

        // Aciona a função de movimento do PvP correspondente ao botão mais próximo
        if (nearestButton) {
            switch(nearestButton) {
                case 'up': queuePvpDirection(0, -1); break;
                case 'down': queuePvpDirection(0, 1); break;
                case 'left': queuePvpDirection(-1, 0); break;
                case 'right': queuePvpDirection(1, 0); break;
            }
        }
    }, { passive: false });

    canvas.addEventListener('click', handleCanvasInteraction);
    canvas.addEventListener('touchstart', handleCanvasInteraction, { passive: false });

    // Substitua o seu listener de keydown por este
document.addEventListener('keydown', (e) => {
    // Se o jogo PvP estiver rodando, o controle é dele
    if (pvpGameRunning) {
        switch(e.key) {
            case 'ArrowUp': queuePvpDirection(0, -1); break;
            case 'ArrowDown': queuePvpDirection(0, 1); break;
            case 'ArrowLeft': queuePvpDirection(-1, 0); break;
            case 'ArrowRight': queuePvpDirection(1, 0); break;
        }
        return; // Impede que o código continue para o controle single-player
    }

    // Controle do jogo single-player (como já estava)
    if (!gameRunning || !gameStarted) return;
    switch(e.key) {
        case 'ArrowUp': queueDirection(0, -1); break;
        case 'ArrowDown': queueDirection(0, 1); break;
        case 'ArrowLeft': queueDirection(-1, 0); break;
        case 'ArrowRight': queueDirection(1, 0); break;
        case ' ': togglePause(); break;
    }
});
    document.addEventListener('fullscreenchange', () => {
        const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
        if (!isFullscreen && gameRunning) { if (!gamePaused) { togglePause(); } reenterPrompt.style.display = 'flex';
        } else { reenterPrompt.style.display = 'none'; }
    });
    document.querySelector('#reenterFullscreenPrompt button').onclick = () => {
        enterFullScreen(document.documentElement);
        setTimeout(() => { if (gamePaused) { togglePause(); } }, 100);
    };
    let touchStartY = 0; window.addEventListener('touchstart', function(e) { if (e.touches.length !== 1) return; touchStartY = e.touches[0].clientY; }, { passive: false });
    window.addEventListener('touchmove', function(e) { const touchY = e.touches[0].clientY; const touchDiff = touchY - touchStartY; if (touchStartY < 10 && touchDiff > 10) { e.preventDefault(); } }, { passive: false });
    selectDifficulty('normal'); selectMap('normal');
    
    let joystickType = 'classic'; let joystickPosition = 'right';

    function toggleJoystick() {
        joystickType = document.getElementById('joystickModel').value;
        const classic = document.getElementById('gameControls');
        const floating = document.getElementById('floatingJoystick');
        
        if (joystickType === 'classic') { classic.style.display = 'grid'; floating.style.display = 'none';
        } else { classic.style.display = 'none'; floating.style.display = 'block'; updateJoystickPosition(); }
    }
    
    function updateJoystickPosition() { joystickPosition = document.getElementById('joystickPosition').value; const floatingJoystick = document.getElementById('floatingJoystick'); floatingJoystick.style.left = ''; floatingJoystick.style.right = ''; floatingJoystick.style.transform = ''; if (joystickPosition === 'left') { floatingJoystick.style.left = '40px'; } else if (joystickPosition === 'right') { floatingJoystick.style.right = '40px'; } else if (joystickPosition === 'center') { floatingJoystick.style.left = '50%'; floatingJoystick.style.transform = 'translateX(-50%)'; } }
    let origin = null;
    document.getElementById('floatingJoystick').addEventListener('touchstart', e => { const floatingJoystick = document.getElementById('floatingJoystick'); const touch = e.touches[0]; const rect = floatingJoystick.getBoundingClientRect(); const joystickCenterX = rect.left + rect.width / 2; const joystickCenterY = rect.top + rect.height / 2; const distance = Math.hypot(touch.clientX - joystickCenterX, touch.clientY - joystickCenterY); const maxDistanceToReposition = 100; if (distance < maxDistanceToReposition) { let newLeft = touch.clientX - rect.width / 2; let newTop = touch.clientY - rect.height / 2; newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - rect.width)); newTop = Math.max(0, Math.min(newTop, window.innerHeight - rect.height)); floatingJoystick.style.left = `${newLeft}px`; floatingJoystick.style.top = `${newTop}px`; floatingJoystick.style.right = 'auto'; floatingJoystick.style.transform = 'none'; origin = { x: touch.clientX, y: touch.clientY }; } else { origin = { x: touch.clientX, y: touch.clientY }; } }, { passive: false });
    document.getElementById('floatingJoystick').addEventListener('touchmove', e => {
        if (!origin) return; e.preventDefault();
        const touch = e.touches[0];
        const dxTouch = touch.clientX - origin.x;
        const dyTouch = touch.clientY - origin.y;
        const angle = Math.atan2(dyTouch, dxTouch);
        const distance = Math.min(Math.hypot(dxTouch, dyTouch), 40);
        const thumb = document.getElementById('joystickThumb');
        thumb.style.left = 40 + distance * Math.cos(angle) + 'px';
        thumb.style.top = 40 + distance * Math.sin(angle) + 'px';
        if (!gameRunning || !gameStarted) return;
        const sensitivity = parseInt(document.getElementById('sensitivityRange').value);
        const threshold = sensitivity * 2;
        if (Math.abs(dxTouch) > Math.abs(dyTouch)) {
            if (dxTouch > threshold) { queueDirection(1, 0); }
            if (dxTouch < -threshold) { queueDirection(-1, 0); }
        } else {
            if (dyTouch > threshold) { queueDirection(0, 1); }
            if (dyTouch < -threshold) { queueDirection(0, -1); }
        }
    }, { passive: false });
    document.getElementById('floatingJoystick').addEventListener('touchend', e => { origin = null; document.getElementById('joystickThumb').style.left = '40px'; document.getElementById('joystickThumb').style.top = '40px'; });
    
    function toggleSettings() { 
        document.getElementById('settingsMenu').style.display = 'block'; 
        showSettingsTab('general');
        drawSkinPreview(currentSkin);
    }
    function closeSettings() { 
        document.getElementById('settingsMenu').style.display = 'none'; 
        saveUserSettings(); 
        showSettingsTab('general'); 
    }
    
    const loginScreen = document.getElementById('loginScreen');
    const registerScreen = document.getElementById('registerScreen');
    const gameUI = document.getElementById('mainGame');
    const loggedUser = document.getElementById('loggedUser');
    let currentUsername = null; 
    let userSettings = {};
    let isAdmin = false;
    let inboxListener = null; // Listener para a caixa de entrada

    document.getElementById('loginPass').addEventListener('keydown', function(event) { if (event.key === 'Enter') { event.preventDefault(); handleLogin(); } });

    async function selectSkin(skinKey) {
    const skin = skins[skinKey];
    if (!skin) return;

    // Sempre atualiza o visualizador com a skin que foi clicada
    drawSkinPreview(skinKey);

    const buyBtn = document.getElementById('buySkinBtn');
    const isLocked = !unlockedSkins.includes(skinKey);

    // Mostra ou esconde o botão de compra
    if (isLocked && skin.unlockCoins) {
        buyBtn.style.display = 'block';
        // Adiciona um texto traduzível (vou usar 'Comprar por' como padrão)
        const buyText = translations[currentLanguage]['buy_for'] || 'Comprar por';
        buyBtn.textContent = `${buyText} ${skin.unlockCoins} SC 🪙`;
        buyBtn.dataset.skinToBuy = skinKey; // Armazena qual skin comprar
    } else {
        buyBtn.style.display = 'none';
    }

    // Se a skin selecionada já estiver desbloqueada, equipa ela
    if (!isLocked) {
        currentSkin = skinKey;
    }
    
    // Se a skin estiver bloqueada, a função agora só mostra o preview e o botão,
    // sem fazer mais nada, esperando o clique no botão "Comprar".
    const colorPickerContainer = document.getElementById('colorPickerContainer');
    colorPickerContainer.style.display = skinKey === 'custom' ? 'block' : 'none';
}

    function checkSkinUnlocks() {
        for (const key in skins) {
            const skin = skins[key];
            if (skin.unlockScore && (userHighScoresPerMap[currentMap] || 0) >= skin.unlockScore && !unlockedSkins.includes(key)) {
                unlockedSkins.push(key);
            }
        }
    }
    
    function populateSkinSelector() {
        const selector = document.getElementById('skinSelector');
        selector.innerHTML = '';
        
        for (const key in skins) {
            const skin = skins[key];
            const option = document.createElement('option');
            option.value = key;

            let displayName = translations[currentLanguage][`skin_${key}`] || skin.name_pt;
            let isLocked = !unlockedSkins.includes(key);

            if (isLocked) {
                if (skin.unlockScore) {
                    displayName = `🔒 ${displayName} (${skin.unlockScore} Pts)`;
                } else if (skin.unlockCoins) {
                    displayName = `🔒 ${displayName} (${skin.unlockCoins} SC)`;
                }
                option.style.color = '#aaa'; // Cor cinza para indicar que está bloqueada
            }
            
            option.textContent = displayName;
            // A linha abaixo é comentada para permitir a seleção e visualização
            // option.disabled = isLocked;
            selector.appendChild(option);
        }
        selector.value = currentSkin;
    }

    async function updateUserHighScore(newScore, map) {
        const user = auth.currentUser;
        if (user) {
            try {
                const updateData = {};
                updateData[`highScoresPerMap.${map}`] = newScore;
                await db.collection('users').doc(user.uid).update(updateData);
                userHighScoresPerMap[map] = newScore;
            } catch (error) {
                console.error("Erro ao atualizar high score por mapa:", error);
            }
        }
    }

    async function updateUserCoins(coins) {
        const user = auth.currentUser;
        if (user) {
            try {
                await db.collection('users').doc(user.uid).update({ snakeCoins: coins });
            } catch (error) {
                console.error("Erro ao atualizar Snake Coins:", error);
            }
        }
    }

    async function updateUserUnlockedSkins(skinsList) {
        const user = auth.currentUser;
        if (user) {
            try {
                await db.collection('users').doc(user.uid).update({ unlockedSkins: skinsList });
            } catch (error) {
                console.error("Erro ao atualizar skins desbloqueadas:", error);
            }
        }
    }


    async function saveUserSettings() {
        const user = auth.currentUser;
        if (user) {
            const settingsToSave = {
                skin: currentSkin,
                customSnakeColor: document.getElementById('snakeColorPicker').value,
                sensitivity: document.getElementById('sensitivityRange').value,
                joystickModel: document.getElementById('joystickModel').value,
                screenBackgroundColor: document.getElementById('screenBackgroundColor').value,
                gameBackgroundColor: document.getElementById('gameBackgroundColor').value,
                joystickPosition: document.getElementById('joystickPosition').value,
                language: currentLanguage
            };
            try { 
                await db.collection('users').doc(user.uid).set({ 
                    settings: settingsToSave, 
                    unlockedSkins: unlockedSkins,
                    highScoresPerMap: userHighScoresPerMap
                }, { merge: true }); 
            } catch (error) { console.error("Erro ao salvar configurações do usuário:", error); }
        }
    }

    async function loadUserSettings(uid) {
        try {
            const userDoc = await db.collection('users').doc(uid).get();
            isAdmin = false; 

            if (userDoc.exists) {
                const userData = userDoc.data();
                isAdmin = userData.isAdmin || false; 
                currentUsername = userData.username;
                userHighScoresPerMap = userData.highScoresPerMap || {};
                snakeCoins = userData.snakeCoins || 0;
                unlockedSkins = userData.unlockedSkins || ['default', 'custom'];
                userSettings = userData.settings || {};

                // Carrega o status de banimento
                if (userData.isBanned) {
                    alert("Sua conta foi banida.");
                    handleLogout();
                    return;
                }

                currentSkin = userSettings.skin || 'default';
                document.getElementById('snakeColorPicker').value = userSettings.customSnakeColor || '#00b894';
                document.getElementById('sensitivityRange').value = userSettings.sensitivity || '5';
                document.getElementById('joystickModel').value = userSettings.joystickModel || 'classic';
                document.getElementById('screenBackgroundColor').value = userSettings.screenBackgroundColor || '#1a1a1a';
                document.getElementById('gameBackgroundColor').value = userSettings.gameBackgroundColor || '#11131e';
                document.getElementById('joystickPosition').value = userSettings.joystickPosition || 'right';
                
                checkSkinUnlocks();
                populateSkinSelector();
                selectSkin(currentSkin);
                
                selectLanguage(userSettings.language || 'pt');
            } else {
                userSettings = { skin: 'default', customSnakeColor: '#00b894', sensitivity: '5', joystickModel: 'classic', screenBackgroundColor: '#1a1a1a', joystickPosition: 'right', language: 'pt' };
                snakeCoins = 0;
                unlockedSkins = ['default', 'custom'];
                userHighScoresPerMap = {};
                selectLanguage('pt');
            }
            
            const existingAdminBtn = document.getElementById('adminPanelBtn');
            if (isAdmin) {
                if (!existingAdminBtn) { 
                    const adminButton = document.createElement('button');
                    adminButton.id = 'adminPanelBtn';
                    adminButton.textContent = 'Painel Admin';
                    adminButton.className = 'btn btn-danger';
                    adminButton.style.marginTop = '10px';
                    adminButton.style.width = '100%';
                    adminButton.onclick = openAdminPanel;
                    const startScreenDiv = document.getElementById('startScreen');
                    startScreenDiv.appendChild(adminButton);
                }
            } else {
                if(existingAdminBtn) {
                    existingAdminBtn.remove();
                }
            }

            canvas.style.backgroundColor = document.getElementById('gameBackgroundColor').value;
            screenBackgroundColor = document.getElementById('screenBackgroundColor').value;
            document.getElementById('mainGame').style.background = screenBackgroundColor;
            loggedUser.textContent = `${translations[currentLanguage]['player_name_prefix']} ${currentUsername}`;
            totalSnakeCoinsElement.textContent = `🪙 ${snakeCoins} ${translations[currentLanguage]['total_coins_display']}`;
            userHighScoreDisplay.textContent = userHighScoresPerMap[currentMap] || 0;
            toggleJoystick();
            updateJoystickPosition();
            listenToInbox(uid); // Inicia o listener da caixa de entrada

        } catch (error) {
            console.error("Erro ao carregar dados do usuário:", error);
        }
    }
    
    // Carrega o anúncio global para o jogador
    async function loadAnnouncement() {
        const announcementEl = document.getElementById('globalAnnouncement');
        try {
            const doc = await db.collection('game_config').doc('announcement').get();
            if (doc.exists) {
                const data = doc.data();
                if (data.isActive && data.text) {
                    announcementEl.textContent = data.text;
                    announcementEl.style.display = 'block';
                } else {
                    announcementEl.style.display = 'none';
                }
            }
        } catch(error) {
            console.error("Erro ao carregar anúncio:", error);
            announcementEl.style.display = 'none';
        }
    }

    auth.onAuthStateChanged(async (user) => {
        if (user) {
            await loadUserSettings(user.uid);
            await loadAnnouncement(); // Carrega o anúncio para o usuário logado
            loginScreen.style.display = 'none';
            registerScreen.style.display = 'none';
            gameUI.style.display = 'block';
            await updateLeaderboardDisplay();
        } else {
            currentUsername = null;
            isAdmin = false;
            loginScreen.style.display = 'block';
            registerScreen.style.display = 'none';
            gameUI.style.display = 'none';
            
            const adminButton = document.getElementById('adminPanelBtn');
            if (adminButton) {
                adminButton.remove();
            }
            if(inboxListener) inboxListener(); // Remove o listener ao deslogar
        }
        updateContent();
    });
    
    window.onload = () => { updateContent(); };
    function showRegister() { loginScreen.style.display = 'none'; registerScreen.style.display = 'block'; }
    function showLogin() { registerScreen.style.display = 'none'; loginScreen.style.display = 'block'; }
    
    function validateEmail(email) { const re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/; return re.test(String(email).toLowerCase()); }
    function validatePassword(password) { const minLength = 6; const hasNumber = /[0-9]/.test(password); const hasLetter = /[a-zA-Z]/.test(password); if (password.length < minLength) { return translations[currentLanguage]['password_min_length'].replace('{minLength}', minLength); } if (!hasNumber) { return translations[currentLanguage]['password_needs_number']; } if (!hasLetter) { return translations[currentLanguage]['password_needs_letter']; } return null; }
    
    // CÓDIGO CORRIGIDO para a função isUsernameTaken
async function isUsernameTaken(username) {
    if (!username) return false;
    try {
        const usernameDoc = await db.collection('usernames').doc(username.toLowerCase()).get();
        return usernameDoc.exists; // Retorna true se o documento existir, false caso contrário
    } catch (error) {
        console.error("Erro ao verificar nome de usuário:", error);
        // Em caso de erro, é mais seguro assumir que o nome está indisponível.
        return true;
    }
}

    // CÓDIGO CORRIGIDO para a função handleRegister
async function handleRegister() {
    const email = document.getElementById('registerEmail').value.trim();
    const pass = document.getElementById('registerPass').value.trim();
    const passConfirm = document.getElementById('registerPassConfirm').value.trim(); // 1. Obtenha o valor da confirmação
    const username = document.getElementById('registerUsername').value.trim();
    const usernameLowercase = username.toLowerCase();

    // 2. Adicione o novo campo à verificação de preenchimento
    if (email === '' || pass === '' || username === '' || passConfirm === '') { 
        alert('Preencha todos os campos'); // Mensagem de exemplo
        return; 
    }

    // 3. Adicione a verificação para ver se as senhas coincidem
    if (pass !== passConfirm) {
        alert('As senhas não coincidem.'); // Mensagem de exemplo
        return;
    }

    if (!validateEmail(email)) { 
        alert('Por favor, insira um endereço de e-mail válido.'); // Mensagem de exemplo
        return; 
    }
    const passwordError = validatePassword(pass); 
    if (passwordError) { 
        alert(passwordError); 
        return; 
    }

    if (await isUsernameTaken(username)) {
        alert('Este nome de usuário já está em uso.'); // Mensagem de exemplo
        return;
    }

    try {
        const userCredential = await auth.createUserWithEmailAndPassword(email, pass);
        const user = userCredential.user;

        const userRef = db.collection('users').doc(user.uid);
        const usernameRef = db.collection('usernames').doc(usernameLowercase);

        const batch = db.batch();

        batch.set(userRef, {
            username,
            username_lowercase: usernameLowercase,
            email, 
            snakeCoins: 0,
            isBanned: false,
            unlockedSkins: ['default', 'custom'],
            highScoresPerMap: { "normal": 0, "no-walls": 0 },
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            settings: { skin: 'default', customSnakeColor: '#00b894' }
        });

        batch.set(usernameRef, {
            userId: user.uid
        });

        await batch.commit(); 

        alert('Cadastro realizado com sucesso!'); // Mensagem de exemplo
    } catch (error) {
        console.error("Erro no cadastro:", error);
        alert(error.code === 'auth/email-already-in-use' ? 'Este email já está cadastrado' : error.message);
    }
}
    
    async function handleLogin() {
        const email = document.getElementById('loginEmail').value.trim();
        const pass = document.getElementById('loginPass').value.trim();
        if (email === '' || pass === '') { alert(translations[currentLanguage]['alert_fill_all_fields']); return; }
        try { await auth.signInWithEmailAndPassword(email, pass); }
        catch (error) { console.error("Erro no login:", error); alert(translations[currentLanguage]['alert_invalid_credentials']); }
    }

    async function handlePasswordReset() {
        const email = document.getElementById('loginEmail').value.trim();
        if (email === '') { alert(translations[currentLanguage]['alert_enter_email_for_reset']); return; }
        try { await auth.sendPasswordResetEmail(email); alert(translations[currentLanguage]['alert_password_reset_success']); }
        catch (error) { console.error("Erro ao enviar email de recuperação:", error); alert(error.message); }
    }

    function handleLogout() {
        if(inboxListener) inboxListener(); // Desconecta o listener de inbox
        saveUserSettings(); auth.signOut().catch(error => console.error("Erro ao sair:", error));
    }

    function showSettingsTab(tabId) { document.querySelectorAll('.settings-tab-content').forEach(tab => { tab.style.display = 'none'; }); document.querySelectorAll('.tab-button').forEach(btn => { btn.classList.remove('selected'); }); document.getElementById(tabId + 'Settings').style.display = 'block'; document.querySelector(`.tab-button[onclick*="${tabId}"]`).classList.add('selected'); }
    
    async function reauthenticate(currentPassword) { const user = auth.currentUser; const cred = firebase.auth.EmailAuthProvider.credential(user.email, currentPassword); return user.reauthenticateWithCredential(cred); }
    
   // CÓDIGO CORRIGIDO para a função handleChangeUsername
async function handleChangeUsername() {
    const newUsername = document.getElementById('newUsername').value.trim();
    const currentPass = document.getElementById('currentPassForUsername').value.trim();
    const usernameChangeError = document.getElementById('usernameChangeError');
    usernameChangeError.textContent = '';
    const user = auth.currentUser;

    // ... (suas validações existentes) ...
    if (!user) { usernameChangeError.textContent = translations[currentLanguage]['alert_no_user_logged_in']; return; }
    if (newUsername === '') { usernameChangeError.textContent = translations[currentLanguage]['alert_username_empty']; return; }
    if (newUsername.toLowerCase() === currentUsername.toLowerCase()){ usernameChangeError.textContent = translations[currentLanguage]['alert_new_username_same_as_current']; return; }
    
    // A verificação agora usa a nova função e vai funcionar corretamente
    if (await isUsernameTaken(newUsername)) {
        usernameChangeError.textContent = translations[currentLanguage]['alert_username_taken'];
        return;
    }
    
    try {
        // Reautenticação do usuário continua sendo necessária
        await reauthenticate(currentPass);

        // Iniciar uma transação para garantir a consistência dos dados
        await db.runTransaction(async (transaction) => {
            const oldUsernameLowercase = currentUsername.toLowerCase();
            const newUsernameLowercase = newUsername.toLowerCase();

            const userRef = db.collection('users').doc(user.uid);
            const oldUsernameRef = db.collection('usernames').doc(oldUsernameLowercase);
            const newUsernameRef = db.collection('usernames').doc(newUsernameLowercase);
            
            // 1. Deleta o documento do nome de usuário antigo
            transaction.delete(oldUsernameRef);
            // 2. Cria o documento para o novo nome de usuário
            transaction.set(newUsernameRef, { userId: user.uid });
            // 3. Atualiza o nome de usuário no perfil do usuário
            transaction.update(userRef, {
                username: newUsername,
                username_lowercase: newUsernameLowercase
            });
        });

        // Se a transação for bem-sucedida, atualize o estado local
        currentUsername = newUsername;
        loggedUser.textContent = `${translations[currentLanguage]['player_name_prefix']} ${currentUsername}`;
        alert(translations[currentLanguage]['alert_username_changed_success']);
        document.getElementById('newUsername').value = '';
        document.getElementById('currentPassForUsername').value = '';

    } catch (error) {
        console.error("Erro ao mudar nome de usuário:", error);
        usernameChangeError.textContent = error.code === 'auth/wrong-password' 
            ? translations[currentLanguage]['alert_incorrect_current_password'] 
            : 'Erro: ' + error.message;
    }
}

    async function handleChangeEmail() {
        const newEmail = document.getElementById('newEmail').value.trim();
        const currentPass = document.getElementById('currentPassForEmail').value.trim();
        const emailChangeError = document.getElementById('emailChangeError');
        emailChangeError.textContent = '';
        const user = auth.currentUser;

        if (!user) { emailChangeError.textContent = translations[currentLanguage]['alert_no_user_logged_in']; return; }
        if (newEmail === '') { emailChangeError.textContent = translations[currentLanguage]['alert_new_email_empty']; return; }
        if (!validateEmail(newEmail)) { emailChangeError.textContent = translations[currentLanguage]['alert_invalid_email']; return; }
        if (newEmail.toLowerCase() === user.email.toLowerCase()) { emailChangeError.textContent = translations[currentLanguage]['alert_new_email_same_as_current']; return; }

        try {
            await reauthenticate(currentPass); await user.updateEmail(newEmail);
            await db.collection('users').doc(user.uid).update({ email: newEmail });
            alert(translations[currentLanguage]['alert_email_changed_success']);
            document.getElementById('newEmail').value = ''; document.getElementById('currentPassForEmail').value = '';
        } catch (error) {
            console.error("Erro ao mudar email:", error);
            if (error.code === 'auth/wrong-password') { emailChangeError.textContent = translations[currentLanguage]['alert_incorrect_current_password']; }
            else if (error.code === 'auth/email-already-in-use') { emailChangeError.textContent = translations[currentLanguage]['alert_email_taken']; }
            else { emailChangeError.textContent = 'Erro: ' + error.message; }
        }
    }
    
    async function handleChangePassword() {
        const oldPass = document.getElementById('oldPassword').value.trim();
        const newPass = document.getElementById('newPassword').value.trim();
        const confirmNewPass = document.getElementById('confirmNewPassword').value.trim();
        const passwordChangeError = document.getElementById('passwordChangeError');
        passwordChangeError.textContent = '';
        const user = auth.currentUser;

        if (!user) { passwordChangeError.textContent = translations[currentLanguage]['alert_no_user_logged_in']; return; }
        if (oldPass === '' || newPass === '' || confirmNewPass === '') { passwordChangeError.textContent = translations[currentLanguage]['alert_fill_all_password_fields']; return; }
        if (newPass !== confirmNewPass) { passwordChangeError.textContent = translations[currentLanguage]['alert_new_passwords_dont_match']; return; }
        const passwordError = validatePassword(newPass); if (passwordError) { passwordChangeError.textContent = passwordError; return; }
        if (oldPass === newPass) { passwordChangeError.textContent = translations[currentLanguage]['alert_new_password_same_as_old']; return; }

        try {
            await reauthenticate(oldPass); await user.updatePassword(newPass);
            alert(translations[currentLanguage]['alert_password_changed_success']);
            document.getElementById('oldPassword').value = ''; document.getElementById('newPassword').value = ''; document.getElementById('confirmNewPassword').value = '';
        } catch (error) {
            console.error("Erro ao mudar senha:", error);
            passwordChangeError.textContent = error.code === 'auth/wrong-password' ? translations[currentLanguage]['alert_old_password_incorrect'] : 'Erro: ' + error.message;
        }
    }
    
    async function handleSupportRequest() {
        const supportType = document.getElementById('supportType').value;
        const supportMessage = document.getElementById('supportMessage').value.trim();
        const successMessageElement = document.getElementById('supportSuccessMessage');
        const user = auth.currentUser;

        successMessageElement.textContent = '';

        if (!user) {
            alert(translations[currentLanguage]['alert_no_user_logged_in']);
            return;
        }
        if (supportMessage === '') {
            alert(translations[currentLanguage]['alert_support_message_empty']);
            return;
        }

        try {
            await db.collection('support_tickets').add({
                userId: user.uid,
                username: currentUsername,
                email: user.email,
                type: supportType,
                message: supportMessage,
                status: 'new',
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });

            successMessageElement.textContent = translations[currentLanguage]['alert_support_success'];
            document.getElementById('supportMessage').value = '';
            
            setTimeout(() => {
                successMessageElement.textContent = '';
            }, 5000);

        } catch (error) {
            console.error("Erro ao enviar ticket de suporte:", error);
            alert('Ocorreu um erro ao enviar sua mensagem. Tente novamente.');
        }
    }

    document.getElementById('snakeColorPicker').addEventListener('change', saveUserSettings); document.getElementById('sensitivityRange').addEventListener('change', saveUserSettings); document.getElementById('joystickModel').addEventListener('change', saveUserSettings); document.getElementById('screenBackgroundColor').addEventListener('change', saveUserSettings); document.getElementById('joystickPosition').addEventListener('change', saveUserSettings);
    
    document.getElementById('snakeColorPicker').addEventListener('input', () => {
        if (currentSkin === 'custom') {
            drawSkinPreview('custom');
        }
    });

    showSettingsTab('general');


    // ==================================================================
    // FUNÇÕES DO PAINEL DE ADMIN
    // ==================================================================
    
    function openAdminPanel() {
        document.getElementById('adminPanel').style.display = 'flex';
        showAdminTab('dashboard'); // Mostra a primeira aba por padrão
    }

    function closeAdminPanel() {
        document.getElementById('adminPanel').style.display = 'none';
    }

    function showAdminTab(tabId) {
        document.querySelectorAll('.admin-tab-content').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.admin-tab-button').forEach(btn => btn.classList.remove('selected'));
        
        document.getElementById(`admin${tabId.charAt(0).toUpperCase() + tabId.slice(1)}Tab`).classList.add('active');
        document.querySelector(`.admin-tab-button[onclick*="'${tabId}'"]`).classList.add('selected');

        // Carrega o conteúdo da aba selecionada
        if (tabId === 'dashboard') loadAdminDashboard();
        if (tabId === 'analytics') loadGameAnalytics();
        if (tabId === 'users') listAllUsers();
        if (tabId === 'leaderboard') loadFullLeaderboard(document.getElementById('leaderboardMapSelector').value);
        if (tabId === 'support') loadSupportTickets();
        if (tabId === 'announcements') loadCurrentAnnouncementForAdmin();
        if (tabId === 'collectiveActions') { /* Não precisa carregar nada ao abrir */ } 
    }

    // ABA 1: Dashboard
    async function loadAdminDashboard() {
        try {
            // Total de usuários
            const usersSnapshot = await db.collection('users').get();
            document.getElementById('totalUsersStat').textContent = usersSnapshot.size;

            // Novos usuários (últimas 24h)
            const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
            const newUsersSnapshot = await db.collection('users').where('createdAt', '>=', oneDayAgo).get();
            document.getElementById('newUsersStat').textContent = newUsersSnapshot.size;

            const statsDoc = await db.collection('game_stats').doc('counters').get();
        if (statsDoc.exists) {
            // Pega o valor do campo 'totalGamesPlayed'
            document.getElementById('totalScoresStat').textContent = statsDoc.data().totalGamesPlayed || 0;
        } else {
            document.getElementById('totalScoresStat').textContent = 0;
        }

            // Tickets de suporte abertos
            const ticketsSnapshot = await db.collection('support_tickets').where('status', '==', 'new').get();
            document.getElementById('openTicketsStat').textContent = ticketsSnapshot.size;
        } catch(error) {
            console.error("Erro ao carregar dashboard:", error);
            alert("Não foi possível carregar os dados do dashboard.");
        }
    }
    
// SUBSTITUA SUA FUNÇÃO INTEIRA PELA VERSÃO ABAIXO
async function loadGameAnalytics() {
    const mostUsedSkinStat = document.getElementById('mostUsedSkinStat');
    const mostPlayedMapStat = document.getElementById('mostPlayedMapStat');
    const mostUsedDifficultyStat = document.getElementById('mostUsedDifficultyStat');
    const skinUsageTableBody = document.querySelector('#skinUsageTable tbody');
    const difficultyChartContainer = document.getElementById('difficultyDistributionChart');
    const mostPlayedMapsList = document.getElementById('mostPlayedMapsList');

    // Resetar campos
    mostUsedSkinStat.textContent = "Calculando...";
    mostPlayedMapStat.textContent = "Calculando...";
    mostUsedDifficultyStat.textContent = "Calculando...";
    skinUsageTableBody.innerHTML = '<tr><td colspan="3">Calculando...</td></tr>';
    difficultyChartContainer.innerHTML = '<p>Calculando...</p>';
    mostPlayedMapsList.innerHTML = '<p>Calculando...</p>';

    try {
        const scoresSnapshot = await db.collection('game_logs').get();
        const totalScores = scoresSnapshot.size;

        const skinCounts = {};
        const mapCounts = {};
        const difficultyCounts = {};
        
        scoresSnapshot.forEach(doc => {
            const gameData = doc.data();
            const skin = gameData.skin || 'default';
            const map = gameData.map || 'normal';
            const diff = gameData.difficulty || 'normal';

            skinCounts[skin] = (skinCounts[skin] || 0) + 1;
            mapCounts[map] = (mapCounts[map] || 0) + 1;
            difficultyCounts[diff] = (difficultyCounts[diff] || 0) + 1;
        });
        
        skinUsageTableBody.innerHTML = '';
        Object.keys(skins).forEach(skinKey => {
            const count = skinCounts[skinKey] || 0;
            const percentage = totalScores > 0 ? ((count / totalScores) * 100).toFixed(1) : 0;
            const skinName = translations[currentLanguage][`skin_${skinKey}`] || skins[skinKey].name_pt;
            const row = `<tr>
                <td>${skinName}</td>
                <td>${count}</td>
                <td>${percentage}%</td>
            </tr>`;
            skinUsageTableBody.innerHTML += row;
        });

        // --- CORREÇÃO APLICADA ABAIXO ---

        // 1. Encontra a skin mais usada
        const mostUsedSkinKey = Object.keys(skinCounts).length > 0 ? Object.keys(skinCounts).reduce((a, b) => skinCounts[a] > skinCounts[b] ? a : b) : 'N/A';
        // VERIFICA SE A SKIN REALMENTE EXISTE ANTES DE MOSTRAR
        if (mostUsedSkinKey !== 'N/A' && skins[mostUsedSkinKey]) {
            mostUsedSkinStat.textContent = translations[currentLanguage][`skin_${mostUsedSkinKey}`] || skins[mostUsedSkinKey].name_pt;
        } else {
            mostUsedSkinStat.textContent = 'N/A';
        }

        // 2. Encontra o mapa mais jogado
        const mostPlayedMapKey = Object.keys(mapCounts).length > 0 ? Object.keys(mapCounts).reduce((a, b) => mapCounts[a] > mapCounts[b] ? a : b) : 'N/A';
        // VERIFICA SE O MAPA REALMENTE EXISTE ANTES DE MOSTRAR
        if (mostPlayedMapKey !== 'N/A' && maps[mostPlayedMapKey]) {
            mostPlayedMapStat.textContent = maps[mostPlayedMapKey]['name_' + currentLanguage];
        } else {
            mostPlayedMapStat.textContent = 'N/A';
        }

        // 3. Encontra a dificuldade mais usada
        const mostUsedDifficultyKey = Object.keys(difficultyCounts).length > 0 ? Object.keys(difficultyCounts).reduce((a, b) => difficultyCounts[a] > difficultyCounts[b] ? a : b) : 'N/A';
        // VERIFICA SE A DIFICULDADE REALMENTE EXISTE ANTES DE MOSTRAR
        if (mostUsedDifficultyKey !== 'N/A' && difficulties[mostUsedDifficultyKey]) {
            mostUsedDifficultyStat.textContent = difficulties[mostUsedDifficultyKey]['name_' + currentLanguage];
        } else {
            mostUsedDifficultyStat.textContent = 'N/A';
        }
        
        // O restante da função continua igual
        difficultyChartContainer.innerHTML = '';
        Object.keys(difficulties).forEach(diffKey => {
            const count = difficultyCounts[diffKey] || 0;
            const percentage = totalScores > 0 ? ((count / totalScores) * 100).toFixed(1) : 0;
            const diffName = difficulties[diffKey]['name_' + currentLanguage];
            const chartItem = `
                <div class="bar-chart-item">
                    <div class="bar-chart-label">${diffName}</div>
                    <div class="bar-chart-bar-bg">
                        <div class="bar-chart-bar" style="width: ${percentage}%;"></div>
                    </div>
                    <div class="bar-chart-value">${count}</div>
                </div>`;
            difficultyChartContainer.innerHTML += chartItem;
        });
        
        mostPlayedMapsList.innerHTML = '';
        const sortedMaps = Object.entries(mapCounts).sort(([,a],[,b]) => b-a);
        sortedMaps.forEach(([mapKey, count]) => {
            // Adiciona uma verificação aqui também por segurança
            const mapName = maps[mapKey] ? maps[mapKey]['name_' + currentLanguage] : 'Mapa Desconhecido';
            const listItem = `<p>${mapName}: <strong>${count} partidas</strong></p>`;
            mostPlayedMapsList.innerHTML += listItem;
        });

    } catch (error) {
        console.error("Erro ao carregar análises detalhadas:", error);
        mostUsedSkinStat.textContent = "Erro";
        mostPlayedMapStat.textContent = "Erro";
        mostUsedDifficultyStat.textContent = "Erro";
        skinUsageTableBody.innerHTML = '<tr><td colspan="3">Erro ao carregar.</td></tr>';
        difficultyChartContainer.innerHTML = '<p>Erro ao carregar.</p>';
        mostPlayedMapsList.innerHTML = '<p>Erro ao carregar.</p>';
    }
}
  
    async function listAllUsers(query = db.collection('users').orderBy('username_lowercase')) {
        const tableBody = document.querySelector('#usersTable tbody');
        tableBody.innerHTML = '<tr><td colspan="5">Carregando...</td></tr>';
        try {
            const snapshot = await query.get();
            if (snapshot.empty) {
                tableBody.innerHTML = '<tr><td colspan="5">Nenhum usuário encontrado.</td></tr>';
                return;
            }
            tableBody.innerHTML = '';
            snapshot.forEach(doc => {
                const user = doc.data();
                const row = `
                    <tr>
                        <td>${user.username}</td>
                        <td>${user.email}</td>
                        <td>${user.snakeCoins || 0}</td>
                        <td>${user.isBanned ? '<span style="color:red;">Banido</span>' : '<span style="color:limegreen;">Ativo</span>'}</td>
                        <td>
                            <button class="btn btn-primary" onclick="openEditUserModal('${doc.id}')">Editar</button>
                        </td>
                    </tr>
                `;
                tableBody.innerHTML += row;
            });
        } catch(error) {
            console.error("Erro ao listar usuários:", error);
            tableBody.innerHTML = '<tr><td colspan="5">Erro ao carregar usuários.</td></tr>';
        }
    }

    function searchUser() {
        const searchTerm = document.getElementById('userSearchInput').value.trim().toLowerCase();
        if (searchTerm === '') {
            listAllUsers();
            return;
        }
        const query = db.collection('users').where('username_lowercase', '==', searchTerm);
        listAllUsers(query);
    }
    
    async function openEditUserModal(userId) {
        try {
            const userDoc = await db.collection('users').doc(userId).get();
            if (!userDoc.exists) {
                alert("Usuário não encontrado.");
                return;
            }
            const userData = userDoc.data();

            document.getElementById('editUserId').value = userId;
            document.getElementById('editUserTitle').textContent = `Editar ${userData.username}`;
            document.getElementById('editUserCoins').value = userData.snakeCoins || 0;
            document.getElementById('editUserBanned').checked = userData.isBanned || false;
            
            document.getElementById('editUserModal').style.display = 'flex';
        } catch(error) {
            console.error("Erro ao buscar dados do usuário:", error);
            alert("Erro ao abrir editor.");
        }
    }

    function closeEditUserModal() {
        document.getElementById('editUserModal').style.display = 'none';
    }

    async function handleUpdateUser() {
        const userId = document.getElementById('editUserId').value;
        const coins = parseInt(document.getElementById('editUserCoins').value);
        const isBanned = document.getElementById('editUserBanned').checked;

        if (!userId) return;

        try {
            await db.collection('users').doc(userId).update({
                snakeCoins: coins,
                isBanned: isBanned
            });
            alert("Usuário atualizado com sucesso!");
            closeEditUserModal();
            listAllUsers(); // Recarrega a lista
        } catch(error) {
            console.error("Erro ao atualizar usuário:", error);
            alert("Falha ao atualizar o usuário.");
        }
    }

    // ABA 4: Moderação do Leaderboard
    async function loadFullLeaderboard(map) {
    const tableBody = document.querySelector('#leaderboardTable tbody');
    // ATUALIZE O COLSPAN PARA 7 (por causa da nova coluna)
    tableBody.innerHTML = '<tr><td colspan="7">Carregando...</td></tr>'; 
    const difficultyEmojis = { easy: '🐌', normal: '🐍', hard: '🚀', insane: '💀' };
    try {
        const snapshot = await db.collection('scores').where('map', '==', map).orderBy('score', 'desc').limit(50).get();
        if (snapshot.empty) {
            // ATUALIZE O COLSPAN PARA 7
            tableBody.innerHTML = `<tr><td colspan="7">Nenhuma pontuação para o mapa "${map}".</td></tr>`;
            return;
        }
        tableBody.innerHTML = '';
        let rank = 1;
        snapshot.forEach(doc => {
            const score = doc.data();
            const date = score.timestamp ? score.timestamp.toDate().toLocaleDateString('pt-BR') : 'N/A';
            
            // Pega a contagem de comida. Se o recorde for antigo e não tiver o dado, exibe '?'
            const foodCount = score.foodCount || '?';

            // ATUALIZE A LINHA DA TABELA PARA INCLUIR A NOVA CÉLULA
            const row = `
                <tr>
                    <td>${rank++}</td>
                    <td>${score.name}</td>
                    <td>${score.score}</td>
                    <td>${foodCount}</td> <td>${difficultyEmojis[score.difficulty] || ''}</td>
                    <td>${date}</td>
                    <td>
                        <button class="btn btn-danger" onclick="deleteScore('${doc.id}', '${map}')">Excluir</button>
                    </td>
                </tr>
            `;
            tableBody.innerHTML += row;
        });
    } catch(error) {
        console.error("Erro ao carregar leaderboard:", error);
        // ATUALIZE O COLSPAN PARA 7
        tableBody.innerHTML = '<tr><td colspan="7">Erro ao carregar pontuações.</td></tr>';
    }
}

    async function deleteScore(scoreId, map) {
        if(confirm("Tem certeza que deseja excluir esta pontuação? A ação não pode ser desfeita.")) {
            try {
                await db.collection('scores').doc(scoreId).delete();
                alert("Pontuação excluída com sucesso.");
                loadFullLeaderboard(map); // Recarrega a lista
            } catch(error) {
                console.error("Erro ao excluir pontuação:", error);
                alert("Falha ao excluir a pontuação.");
            }
        }
    }

    // ABA 5: Suporte ao Jogador
    async function loadSupportTickets() {
        const status = document.getElementById('supportStatusFilter').value;
        const listEl = document.getElementById('supportTicketsList');
        listEl.innerHTML = '<p>Carregando tickets...</p>';

        try {
            const snapshot = await db.collection('support_tickets').where('status', '==', status).orderBy('timestamp', 'desc').get();
            if (snapshot.empty) {
                listEl.innerHTML = '<p>Nenhum ticket encontrado com este status.</p>';
                return;
            }
            listEl.innerHTML = '';
            snapshot.forEach(doc => {
                const ticket = doc.data();
                const date = ticket.timestamp ? ticket.timestamp.toDate().toLocaleString('pt-BR') : 'N/A';
                const ticketHTML = `
                    <div class="stat-card" style="text-align: left;">
                        <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong style="font-size: 14px;">${ticket.username} (${ticket.type})</strong>
                            <span style="font-size: 11px; opacity: 0.7;">${date}</span>
                        </div>
                        <p style="font-size: 13px; font-weight: normal; margin-bottom: 15px;">${ticket.message}</p>
                        <div class="filter-controls">
                             <button class="btn btn-secondary" style="font-size: 10px;" onclick="updateTicketStatus('${doc.id}', 'new')">Novo</button>
                             <button class="btn btn-primary" style="font-size: 10px;" onclick="updateTicketStatus('${doc.id}', 'in_progress')">Em Andamento</button>
                             <button class="btn" style="background-color: #00b894; font-size: 10px;" onclick="updateTicketStatus('${doc.id}', 'resolved')">Resolvido</button>
                        </div>
                    </div>
                `;
                listEl.innerHTML += ticketHTML;
            });
        } catch(error) {
            console.error("Erro ao carregar tickets:", error);
            listEl.innerHTML = '<p>Erro ao carregar os tickets de suporte.</p>';
        }
    }

    async function updateTicketStatus(ticketId, newStatus) {
        try {
            await db.collection('support_tickets').doc(ticketId).update({ status: newStatus });
            alert(`Status do ticket alterado para "${newStatus}"!`);
            loadSupportTickets();
        } catch(error) {
            console.error("Erro ao atualizar status do ticket:", error);
            alert("Falha ao atualizar o status.");
        }
    }

    // ABA 6: Anúncios Globais
    async function loadCurrentAnnouncementForAdmin() {
        try {
            const doc = await db.collection('game_config').doc('announcement').get();
            if (doc.exists) {
                const data = doc.data();
                document.getElementById('announcementText').value = data.text || '';
                document.getElementById('announcementActive').checked = data.isActive || false;
            }
        } catch (error) {
            console.error("Erro ao carregar anúncio para admin:", error);
        }
    }

    async function saveAnnouncement() {
        const text = document.getElementById('announcementText').value.trim();
        const isActive = document.getElementById('announcementActive').checked;
        try {
            await db.collection('game_config').doc('announcement').set({ text, isActive }, { merge: true });
            alert("Anúncio salvo com sucesso!");
        } catch(error) {
            console.error("Erro ao salvar anúncio:", error);
            alert("Falha ao salvar o anúncio.");
        }
    }

    // ABA 7 - Ações Coletivas (MODIFICADA)
    async function sendCollectiveReward() {
        const amountInput = document.getElementById('collectiveCoinsAmount');
        const messageInput = document.getElementById('collectiveRewardMessage');
        
        const amount = parseInt(amountInput.value) || 0; // Garante que é um número
        const customMessage = messageInput.value.trim();

        if (amount < 0) {
            alert("A quantidade de moedas não pode ser negativa.");
            return;
        }
        if (customMessage === '') {
            alert("Por favor, escreva uma mensagem para a recompensa.");
            return;
        }

        try {
            const batch = db.batch();
            const usersSnapshot = await db.collection('users').get();
            
            if (!confirm(`Você tem certeza que deseja enviar ${amount} moedas e uma mensagem para TODOS os ${usersSnapshot.size} jogadores? Esta ação não pode ser desfeita.`)) {
                return;
            }

            usersSnapshot.forEach(doc => {
                const userRef = db.collection('users').doc(doc.id);
                const inboxRef = userRef.collection('inbox').doc();

                // MODIFICADO: Cria a mensagem final para o usuário
                let finalMessage = '';
                if (amount > 0) {
                    finalMessage += `Você recebeu ${amount} Snake Coins! 🪙\n\n`;
                }
                finalMessage += customMessage; // Adiciona a mensagem do admin

                // Adiciona a atualização de moedas (se houver)
                if (amount > 0) {
                    batch.update(userRef, { snakeCoins: firebase.firestore.FieldValue.increment(amount) });
                }

                // Adiciona a mensagem formatada à caixa de entrada do usuário
                batch.set(inboxRef, {
                    message: finalMessage, // Salva a mensagem completa
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    isRead: false
                });
            });

            await batch.commit();

            alert(`Sucesso! ${amount} moedas e uma mensagem foram enviadas para ${usersSnapshot.size} jogadores.`);
            amountInput.value = '';
            messageInput.value = '';

        } catch (error) {
            console.error("Erro ao enviar recompensa coletiva:", error);
            alert("Ocorreu um erro ao enviar a recompensa. Verifique o console para mais detalhes.");
        }
    }

    // ==================================================================
    // FUNÇÕES DA CAIXA DE ENTRADA DO JOGADOR
    // ==================================================================
    let unreadMessagesCount = 0;

    function listenToInbox(userId) {
        if(inboxListener) inboxListener(); // Remove o listener antigo se houver

        inboxListener = db.collection('users').doc(userId).collection('inbox')
            .onSnapshot(snapshot => {
                unreadMessagesCount = 0;
                snapshot.forEach(doc => {
                    if (!doc.data().isRead) {
                        unreadMessagesCount++;
                    }
                });
                updateInboxNotification();
            }, error => {
                console.error("Erro ao escutar a caixa de entrada: ", error);
            });
    }

    function updateInboxNotification() {
        const notification = document.getElementById('inboxNotification');
        if (unreadMessagesCount > 0) {
            notification.textContent = unreadMessagesCount;
            notification.style.display = 'flex';
        } else {
            notification.style.display = 'none';
        }
    }

    async function openInbox() {
        const user = auth.currentUser;
        if (!user) return;

        const inboxList = document.getElementById('inboxList');
        inboxList.innerHTML = '<p>Carregando mensagens...</p>';
        document.getElementById('inboxModal').style.display = 'flex';

        const messagesRef = db.collection('users').doc(user.uid).collection('inbox').orderBy('timestamp', 'desc');
        const snapshot = await messagesRef.get();
        
        if (snapshot.empty) {
            inboxList.innerHTML = `<p style="text-align: center; opacity: 0.7;">${translations[currentLanguage]['inbox_empty']}</p>`;
            return;
        }

        inboxList.innerHTML = '';
        const batch = db.batch();
        snapshot.forEach(doc => {
            const message = doc.data();
            const date = message.timestamp ? message.timestamp.toDate().toLocaleDateString('pt-BR') : '';
            
            const messageEl = document.createElement('div');
            messageEl.className = 'inbox-message';
            // MODIFICADO: Simplificado para exibir a mensagem que já vem completa
            messageEl.innerHTML = `
                <div class="inbox-message-header">
                    <strong>Mensagem do Sistema</strong>
                    <span>${date}</span>
                </div>
                <p>${message.message}</p>
                <button class="btn btn-danger" style="float: right; margin-top: 10px;" onclick="deleteInboxMessage('${doc.id}')">Apagar</button>
            `;
            inboxList.appendChild(messageEl);

            // Marca como lida se não estiver
            if (!message.isRead) {
                const docRef = db.collection('users').doc(user.uid).collection('inbox').doc(doc.id);
                batch.update(docRef, { isRead: true });
            }
        });

        await batch.commit(); // Executa todas as atualizações de 'isRead'
    }

    function closeInbox() {
        document.getElementById('inboxModal').style.display = 'none';
    }
    
    async function deleteInboxMessage(messageId) {
        if (!confirm(translations[currentLanguage]['inbox_delete_confirm'])) return;
        
        const user = auth.currentUser;
        if (!user) return;

        try {
            await db.collection('users').doc(user.uid).collection('inbox').doc(messageId).delete();
            openInbox(); // Recarrega a caixa de entrada para mostrar a mudança
        } catch(error) {
            console.error("Erro ao apagar mensagem:", error);
            alert("Não foi possível apagar a mensagem.");
        }
    }
    
    // ==================================================================
    // FUNÇÕES DO PAINEL PVP
    // ==================================================================
    function openPvPPanel() {
        document.getElementById('pvpPanel').style.display = 'flex';
    }

    function resumePvpGame() {
    // Limpa o timer de 4 segundos para evitar que ele feche o modal novamente
    if (quitConfirmTimeout) {
        clearTimeout(quitConfirmTimeout);
        quitConfirmTimeout = null;
    }
    // Esconde o modal de confirmação
    document.getElementById('quitPvpConfirmModal').style.display = 'none';
    // Desativa o estado de pausa
    isPvpPausedForQuit = false;
}

function requestQuitPvp() {
    // Se o jogo NÃO estiver rodando (ou seja, está procurando ou na contagem regressiva)
    if (!pvpGameRunning) {
        // Se a contagem regressiva estiver ativa, trata como uma desistência imediata.
        if (isCountdownActive) {
            confirmQuitPvp(); // Chama a função que encerra a partida e limpa tudo.
        } 
        // Se estiver apenas procurando uma partida, cancela a busca.
        else if (isSearching) {
            document.getElementById('pvpPanel').style.display = 'none';
            cancelSearch();
        } 
        // Se o painel estiver apenas aberto, sem ação, simplesmente fecha.
        else {
            document.getElementById('pvpPanel').style.display = 'none';
        }
        return; // Encerra a execução aqui para os casos acima.
    }

    // --- A lógica abaixo só será executada se o jogo já estiver rodando ---

    // Não faz nada se a pergunta de sair já estiver na tela.
    if (isPvpPausedForQuit) return;

    // Ativa o estado de pausa para a confirmação.
    isPvpPausedForQuit = true;
    
    // Mostra o modal de confirmação.
    document.getElementById('quitPvpConfirmModal').style.display = 'flex';

    // Inicia um timer de 4 segundos para resumir o jogo automaticamente se não houver resposta.
    quitConfirmTimeout = setTimeout(() => {
        resumePvpGame(); 
    }, 4000);
}

// 3. Função chamada pelo botão "Sim, Sair" do novo modal
async function confirmQuitPvp() {
    // Limpa o timer de 4 segundos imediatamente para não conflitar
    if (quitConfirmTimeout) {
        clearTimeout(quitConfirmTimeout);
        quitConfirmTimeout = null;
    }

    // --- BLOCO DE SEGURANÇA ADICIONADO ---
    // Verifica se temos todas as informações necessárias antes de prosseguir.
    if (!auth.currentUser || !activeRoomId || !activeRoomData || !opponentPlayerKey || !activeRoomData[opponentPlayerKey] || !activeRoomData[opponentPlayerKey].id) {
        console.error("Tentativa de desistir sem dados válidos.", {
            hasUser: !!auth.currentUser,
            hasRoomId: !!activeRoomId,
            hasRoomData: !!activeRoomData,
            hasOpponentKey: !!opponentPlayerKey
        });
        alert("Não foi possível processar a desistência. Verifique sua conexão e tente novamente.");
        
        // Reseta a interface para um estado seguro
        document.getElementById('quitPvpConfirmModal').style.display = 'none';
        isPvpPausedForQuit = false;
        return; // Interrompe a execução da função aqui.
    }
    // --- FIM DO BLOCO DE SEGURANÇA ---

    try {
        const roomRef = db.collection('gameRooms').doc(activeRoomId);
        await roomRef.update({
            status: 'opponent_left',
            quitterId: auth.currentUser.uid
        });

        // O código abaixo agora é seguro, pois já foi verificado acima
        const opponentId = activeRoomData[opponentPlayerKey].id;
        const outcome = { 
            winnerId: opponentId, 
            loserId: auth.currentUser.uid, 
            localPlayerId: auth.currentUser.uid 
        };
        
        endPvpGame("Você saiu da partida.", outcome);

        document.getElementById('quitPvpConfirmModal').style.display = 'none';
        // A linha abaixo pode ser desnecessária, pois o resetPvpPanel já deve ser chamado
        // document.getElementById('pvpPanel').style.display = 'none';

    } catch (error) {
        console.error("Erro ao desistir da partida:", error);
        alert("Ocorreu um erro ao tentar sair. Verifique sua conexão.");
    }
}
// ==================================================================
// FUNÇÕES DAS NOVAS CONFIGURAÇÕES DO PVP
// ==================================================================

// --- Variáveis de estado e elementos ---
let pvpDifficulty = 'normal';
let pvpMap = 'normal';
const pvpSettingsPanel = document.getElementById('pvpSettingsPanel');
const pvpSkinPreviewCanvas = document.getElementById('skinPreviewCanvasPvp');
const pvpPreviewCtx = pvpSkinPreviewCanvas.getContext('2d');
const pvpTileCountX = 25; // 25 quadrados na horizontal (400px / 16px)
const pvpTileCountY = 16; // 16 quadrados na vertical (256px / 16px)

// --- Funções do Modal e Abas ---

function openPvPSettings() {
    pvpSettingsPanel.style.display = 'flex';
    showPvPSettingsTab('pvpGeneral'); 

    populatePvpSkinSelector();
    populateSabotageDescriptions();
    selectPvpSkin(currentSkin); 
}

function closePvPSettings() {
    pvpSettingsPanel.style.display = 'none';
    saveUserSettings(); 
}
function populateSabotageDescriptions() {
    const container = document.getElementById('sabotage-list-container');
    if (!container) return;
    container.innerHTML = ''; // Limpa a lista antes de preencher

    // Loop através do nosso objeto 'sabotages'
    for (const key in sabotages) {
        const sabotage = sabotages[key];
        
        // Cria o HTML para cada item da lista
        const itemHTML = `
            <div class="sabotage-item">
                <div class="sabotage-item-icon">${sabotage.icon}</div>
                <div class="sabotage-item-details">
                    <h5>${sabotage.name_pt}</h5>
                    <p>${sabotage.description_pt}</p>
                </div>
            </div>
        `;
        
        container.innerHTML += itemHTML;
    }
}

function showPvPSettingsTab(tabId) {
    pvpSettingsPanel.querySelectorAll('.settings-tab-content').forEach(tab => {
        tab.style.display = 'none';
    });
    pvpSettingsPanel.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.remove('selected');
    });

    document.getElementById(tabId + 'Settings').style.display = 'block';
    pvpSettingsPanel.querySelector(`.tab-button[onclick*="${tabId}"]`).classList.add('selected');
}

// --- Funções da Aba "Geral" (Skins e Cores) ---

function populatePvpSkinSelector() {
    const selector = document.getElementById('skinSelectorPvp');
    selector.innerHTML = ''; 
    
    for (const key in skins) {
        const skin = skins[key];
        const option = document.createElement('option');
        option.value = key;

        let displayName = translations[currentLanguage][`skin_${key}`] || skin.name_pt;
        let isLocked = !unlockedSkins.includes(key);

        if (isLocked) {
            let costText = '';
            if (skin.unlockCoins) {
                costText = `(${skin.unlockCoins} SC)`;
            } else if (skin.unlockScore) {
                costText = `(${skin.unlockScore} Pts)`;
            }
            displayName = `🔒 ${displayName} ${costText}`;
            option.style.color = '#aaa';
        }
        
        option.textContent = displayName;
        selector.appendChild(option);
    }
    selector.value = currentSkin;
}

// ESTA É A VERSÃO COMPLETA E CORRETA DA FUNÇÃO DE DESENHO
function drawPvpSkinPreview(skinKey) {
    if (!pvpPreviewCtx) return;

    const previewGridSize = 20;
    const previewCanvasWidth = pvpSkinPreviewCanvas.width;
    const previewCanvasHeight = pvpSkinPreviewCanvas.height;

    pvpPreviewCtx.clearRect(0, 0, previewCanvasWidth, previewCanvasHeight);
    pvpPreviewCtx.fillStyle = '#11131e';
    pvpPreviewCtx.fillRect(0, 0, previewCanvasWidth, previewCanvasHeight);

    const previewSnake = [
        { x: 4, y: 1 }, { x: 3, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 1 }, { x: 0, y: 1 }
    ];
    const offsetX = 10;
    const skinOptions = skins[skinKey] || skins['default'];
    
    const drawPreviewWebPattern = (x, y) => {
        pvpPreviewCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        pvpPreviewCtx.lineWidth = 1;
        pvpPreviewCtx.beginPath();
        pvpPreviewCtx.moveTo(x + previewGridSize / 3, y);
        pvpPreviewCtx.lineTo(x + previewGridSize / 3, y + previewGridSize);
        pvpPreviewCtx.moveTo(x + (previewGridSize / 3) * 2, y);
        pvpPreviewCtx.lineTo(x + (previewGridSize / 3) * 2, y + previewGridSize);
        pvpPreviewCtx.moveTo(x, y + previewGridSize / 3);
        pvpPreviewCtx.lineTo(x + previewGridSize, y + previewGridSize / 3);
        pvpPreviewCtx.moveTo(x, y + (previewGridSize / 3) * 2);
        pvpPreviewCtx.lineTo(x + previewGridSize, y + (previewGridSize / 3) * 2);
        pvpPreviewCtx.stroke();
    };

    for (let i = previewSnake.length - 1; i >= 0; i--) {
        const segment = previewSnake[i];
        const segmentX = segment.x * previewGridSize + offsetX;
        const segmentY = segment.y * previewGridSize;
        const isHead = (i === 0);

        if (skinKey === 'default' || skinKey === 'custom') {
            let color;
            if (isHead) {
                color = (skinKey === 'custom') ? shadeColor(document.getElementById('snakeColorPickerPvp').value, -20) : skinOptions.headColor;
            } else {
                color = (skinKey === 'custom') ? document.getElementById('snakeColorPickerPvp').value : skinOptions.bodyColor;
            }
            pvpPreviewCtx.fillStyle = color;
            pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
        
        } else if (skinKey === 'pharaoh') {
            const goldColor = '#FFD700', blueColor = '#00008B';
            if (isHead) {
                const eyeWhiteColor = '#FFFFFF', eyePupilColor = '#000000';
                pvpPreviewCtx.save();
                pvpPreviewCtx.translate(segmentX + previewGridSize / 2, segmentY + previewGridSize / 2);
                pvpPreviewCtx.rotate(Math.PI / 2);
                const halfGrid = previewGridSize / 2;
                pvpPreviewCtx.fillStyle = blueColor; pvpPreviewCtx.fillRect(-halfGrid, -halfGrid, previewGridSize, previewGridSize);
                pvpPreviewCtx.fillStyle = goldColor; pvpPreviewCtx.fillRect(-halfGrid, -halfGrid, previewGridSize, halfGrid * 0.2);
                pvpPreviewCtx.fillRect(-halfGrid, -halfGrid * 0.2, previewGridSize, halfGrid * 0.2);
                pvpPreviewCtx.fillRect(-halfGrid, halfGrid * 0.6, previewGridSize, halfGrid * 0.2);
                pvpPreviewCtx.fillStyle = goldColor; pvpPreviewCtx.fillRect(-halfGrid * 0.6, -halfGrid * 0.8, halfGrid * 1.2, halfGrid * 0.8);
                const eyeY = -halfGrid * 0.5, eyeX = -halfGrid * 0.2;
                pvpPreviewCtx.fillStyle = eyeWhiteColor; pvpPreviewCtx.fillRect(eyeX - (previewGridSize * 0.2), eyeY, previewGridSize * 0.4, previewGridSize * 0.2);
                pvpPreviewCtx.fillRect(-eyeX - (previewGridSize * 0.2), eyeY, previewGridSize * 0.4, previewGridSize * 0.2);
                pvpPreviewCtx.fillStyle = eyePupilColor; pvpPreviewCtx.fillRect(eyeX - (previewGridSize * 0.05), eyeY, previewGridSize * 0.1, previewGridSize * 0.2);
                pvpPreviewCtx.fillRect(-eyeX - (previewGridSize * 0.05), eyeY, previewGridSize * 0.1, previewGridSize * 0.2);
                const beardYStart = halfGrid * 0.1; const beardHeight = halfGrid * 0.8;
                pvpPreviewCtx.fillStyle = blueColor; pvpPreviewCtx.fillRect(-previewGridSize * 0.15, beardYStart, previewGridSize * 0.3, beardHeight);
                pvpPreviewCtx.fillStyle = goldColor;
                for (let j = 0; j < 3; j++) { pvpPreviewCtx.fillRect(-previewGridSize * 0.15, beardYStart + (j * 0.3) * beardHeight, previewGridSize * 0.3, beardHeight * 0.15); }
                pvpPreviewCtx.restore();
            } else {
                const prevSegment = previewSnake[i - 1];
                const segmentDx = segment.x - prevSegment.x;
                const halfGridSize = previewGridSize / 2;
                if (segmentDx === 1) { 
                    pvpPreviewCtx.fillStyle = goldColor; pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize, halfGridSize);
                    pvpPreviewCtx.fillStyle = blueColor; pvpPreviewCtx.fillRect(segmentX, segmentY + halfGridSize, previewGridSize, halfGridSize);
                } else { 
                    pvpPreviewCtx.fillStyle = blueColor; pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize, halfGridSize);
                    pvpPreviewCtx.fillStyle = goldColor; pvpPreviewCtx.fillRect(segmentX, segmentY + halfGridSize, previewGridSize, halfGridSize);
                }
                if (i % 2 === 0) {
                    const dotSize = 1;
                    pvpPreviewCtx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                    pvpPreviewCtx.fillRect(segmentX + previewGridSize * 0.2, segmentY + previewGridSize * 0.2, dotSize, dotSize);
                    pvpPreviewCtx.fillRect(segmentX + previewGridSize * 0.7, segmentY + previewGridSize * 0.8, dotSize, dotSize);
                    pvpPreviewCtx.fillStyle = 'rgba(0, 0, 139, 0.8)';
                    pvpPreviewCtx.fillRect(segmentX + previewGridSize * 0.8, segmentY + previewGridSize * 0.3, dotSize, dotSize);
                    pvpPreviewCtx.fillRect(segmentX + previewGridSize * 0.3, segmentY + previewGridSize * 0.7, dotSize, dotSize);
                }
            }
        } else if (skinKey === 'spider') {
            if (isHead) {
                pvpPreviewCtx.fillStyle = skinOptions.redColor;
                pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                drawPreviewWebPattern(segmentX, segmentY);
                const eyeXOffset = previewGridSize * 0.2, eyeYOffset = previewGridSize * 0.2;
                const eyeWidth = previewGridSize * 0.25, eyeHeight = previewGridSize * 0.5;
                pvpPreviewCtx.fillStyle = 'white';
                pvpPreviewCtx.fillRect(segmentX + eyeXOffset, segmentY + eyeYOffset, eyeWidth, eyeHeight);
                pvpPreviewCtx.fillRect(segmentX + previewGridSize - 2 - eyeXOffset - eyeWidth, segmentY + eyeYOffset, eyeWidth, eyeHeight);
                pvpPreviewCtx.strokeStyle = 'black';
                pvpPreviewCtx.lineWidth = 1.5;
                pvpPreviewCtx.strokeRect(segmentX + eyeXOffset, segmentY + eyeYOffset, eyeWidth, eyeHeight);
                pvpPreviewCtx.strokeRect(segmentX + previewGridSize - 2 - eyeXOffset - eyeWidth, segmentY + eyeYOffset, eyeWidth, eyeHeight);
            } else {
                const isRedSegment = i % 2 === 0;
                pvpPreviewCtx.fillStyle = isRedSegment ? skinOptions.redColor : skinOptions.blueColor;
                pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                if (isRedSegment) drawPreviewWebPattern(segmentX, segmentY);
            }
        } else if (skinKey === 'coral') {
    const [c1, c2, c3] = skinOptions.colors;
    if (isHead) {
        pvpPreviewCtx.fillStyle = c2;
        pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
        const mouthSize = Math.max(2, Math.floor(previewGridSize / 6));
        pvpPreviewCtx.fillStyle = c3;
        pvpPreviewCtx.fillRect(segmentX + previewGridSize - 2 - mouthSize, segmentY + mouthSize, mouthSize, previewGridSize - 2 - (2 * mouthSize));
    } else {
        const patternIndex = (i - 1) % 4;
        const halfSize = (previewGridSize - 2) / 2;
        switch (patternIndex) {
            case 0:
                pvpPreviewCtx.fillStyle = c1;
                pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                break;
            case 1:
            case 2:
                const firstColor = c3;
                const secondColor = c2;
                pvpPreviewCtx.fillStyle = firstColor;
                pvpPreviewCtx.fillRect(segmentX, segmentY, halfSize, previewGridSize - 2); // Metade esquerda
                pvpPreviewCtx.fillStyle = secondColor;
                pvpPreviewCtx.fillRect(segmentX + halfSize, segmentY, halfSize, previewGridSize - 2); // Metade direita
                break;
            case 3:
                pvpPreviewCtx.fillStyle = c2;
                pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                break;
        }
    }
        } else if (skinKey === 'windowsClassic') {
           const blueScreenColor = '#0000AA';
           const folderColor = '#FFD700';
           const textColor = '#FFFFFF';

           if (isHead) {
               const growth = 2;
               const baseSize = previewGridSize - 2;
               const headY = segmentY + (previewGridSize * 0.1) - (growth / 2);
               const headX = segmentX - (growth / 2);
               const headSize = baseSize + growth;

               const bezelColor = '#DCDCDC';
               const shadowColor = '#888888';
               const highlightColor = '#FFFFFF';

               pvpPreviewCtx.fillStyle = bezelColor;
               pvpPreviewCtx.fillRect(headX, headY, headSize, headSize);
               pvpPreviewCtx.fillStyle = highlightColor;
               pvpPreviewCtx.fillRect(headX, headY, headSize, 1);
               pvpPreviewCtx.fillRect(headX, headY, 1, headSize);
               pvpPreviewCtx.fillStyle = shadowColor;
               pvpPreviewCtx.fillRect(headX, headY + headSize - 1, headSize, 1);
               pvpPreviewCtx.fillRect(headX + headSize - 1, headY, 1, headSize);

               const screenX = headX + 3;
               const screenY = headY + 3;
               const screenSize = headSize - 6;
               const skyColor = '#4595E7';
               const hillColor = '#58B435';
               const cloudColor = '#FFFFFF';

               pvpPreviewCtx.fillStyle = skyColor;
               pvpPreviewCtx.fillRect(screenX, screenY, screenSize, screenSize);
               pvpPreviewCtx.fillStyle = hillColor;
               pvpPreviewCtx.beginPath();
               pvpPreviewCtx.moveTo(screenX, screenY + screenSize * 0.5);
               pvpPreviewCtx.quadraticCurveTo(screenX + screenSize / 2, screenY + screenSize * 0.4, screenX + screenSize, screenY + screenSize * 0.6);
               pvpPreviewCtx.lineTo(screenX + screenSize, screenY + screenSize);
               pvpPreviewCtx.lineTo(screenX, screenY + screenSize);
               pvpPreviewCtx.closePath();
               pvpPreviewCtx.fill();
               pvpPreviewCtx.fillStyle = cloudColor;
               pvpPreviewCtx.fillRect(screenX + screenSize * 0.55, screenY + screenSize * 0.15, screenSize * 0.3, screenSize * 0.1);
               pvpPreviewCtx.fillRect(screenX + screenSize * 0.2, screenY + screenSize * 0.25, screenSize * 0.35, screenSize * 0.1);
           } else {
               // Ícone de pasta na pré-visualização do PvP
               const backColor = '#FBC02D';
               const frontColor = '#FFF176';
               const handleColor = '#64B5F6';
               const size = previewGridSize;

               pvpPreviewCtx.fillStyle = backColor;
               pvpPreviewCtx.beginPath();
               pvpPreviewCtx.rect(segmentX + 1, segmentY + size * 0.2, size - 2, size * 0.8 - 1);
               pvpPreviewCtx.rect(segmentX + 1, segmentY + size * 0.1, size * 0.4, size * 0.2);
               pvpPreviewCtx.fill();
               
               pvpPreviewCtx.fillStyle = frontColor;
               pvpPreviewCtx.fillRect(segmentX + 1, segmentY + size * 0.3, size - 2, size * 0.7 - 1);

               pvpPreviewCtx.fillStyle = handleColor;
               const handleY = segmentY + size * 0.55;
               const handleHeight = size * 0.4;
               const legWidth = size * 0.2;
               pvpPreviewCtx.fillRect(segmentX + size * 0.15, handleY, legWidth, handleHeight);
               pvpPreviewCtx.fillRect(segmentX + size - size * 0.15 - legWidth, handleY, legWidth, handleHeight);
               pvpPreviewCtx.fillRect(segmentX + size * 0.15, handleY + handleHeight - legWidth, size - (size * 0.15 * 2), legWidth);
           }
       } else if (skinKey === 'galaxy') {
            if (isHead) {
                pvpPreviewCtx.fillStyle = skinOptions.headColor;
            } else {
                pvpPreviewCtx.fillStyle = skinOptions.colors[i % skinOptions.colors.length];
            }
            pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
            pvpPreviewCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            pvpPreviewCtx.fillRect(segmentX + Math.random()*(previewGridSize-2), segmentY + Math.random()*(previewGridSize-2), isHead ? 1.5 : 1, isHead ? 1.5 : 1);
       } else if (skinKey === 'camo') {
            if (isHead) {
                pvpPreviewCtx.fillStyle = skinOptions.headColor;
            } else {
                pvpPreviewCtx.fillStyle = skinOptions.colors[i % skinOptions.colors.length];
            }
            pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);

       } else if (skinKey === 'christmas') {
            const currentGridSize = previewGridSize;
            const segX = segment.x * currentGridSize + 10;
            const segY = segment.y * currentGridSize;
            const centerX = segX + currentGridSize / 2;
            const centerY = segY + currentGridSize / 2;
            const radius = (currentGridSize / 2) + 1;

            pvpPreviewCtx.shadowColor = skinOptions.glowColor;
            pvpPreviewCtx.shadowBlur = 8;
            
            pvpPreviewCtx.fillStyle = skinOptions.shadowColor;
            pvpPreviewCtx.beginPath();
            pvpPreviewCtx.arc(centerX, centerY + 1, radius - 1.5, 0, 2 * Math.PI);
            pvpPreviewCtx.fill();
            pvpPreviewCtx.fillStyle = skinOptions.bodyColor;
            pvpPreviewCtx.beginPath();
            pvpPreviewCtx.arc(centerX, centerY, radius - 1.5, 0, 2 * Math.PI);
            pvpPreviewCtx.fill();

            pvpPreviewCtx.strokeStyle = skinOptions.outlineColor;
            pvpPreviewCtx.lineWidth = 2;
            pvpPreviewCtx.beginPath();
            pvpPreviewCtx.arc(centerX, centerY, radius - 1.5, 0, 2 * Math.PI);
            pvpPreviewCtx.stroke();
            
            pvpPreviewCtx.shadowColor = 'transparent';
            pvpPreviewCtx.shadowBlur = 0;

            if (isHead) {
                pvpPreviewCtx.save();
                pvpPreviewCtx.translate(centerX, centerY);
                let rotation = Math.PI / 2; // Preview sempre para a direita
                pvpPreviewCtx.rotate(rotation);
                pvpPreviewCtx.fillStyle = skinOptions.eyeColor;
                const eyeRadius = currentGridSize / 12;
                pvpPreviewCtx.beginPath();
                pvpPreviewCtx.arc(-radius / 2.5, -radius / 2.5, eyeRadius, 0, 2 * Math.PI);
                pvpPreviewCtx.arc(radius / 2.5, -radius / 2.5, eyeRadius, 0, 2 * Math.PI);
                pvpPreviewCtx.fill();
                const mouthDotRadius = currentGridSize / 20;
                for (let j = 0; j < 5; j++) {
                    const angle = Math.PI * 0.6 + (j * Math.PI * 0.2) / 4;
                    const mouthX = Math.cos(angle) * radius * 0.6;
                    const mouthY = Math.sin(angle) * radius * 0.6;
                    pvpPreviewCtx.beginPath();
                    pvpPreviewCtx.arc(mouthX, mouthY, mouthDotRadius, 0, 2 * Math.PI);
                    pvpPreviewCtx.fill();
                }
                pvpPreviewCtx.fillStyle = skinOptions.noseColor;
                pvpPreviewCtx.beginPath();
                pvpPreviewCtx.moveTo(0, -eyeRadius);
                pvpPreviewCtx.lineTo(0, eyeRadius);
                pvpPreviewCtx.lineTo(radius * 0.7, 0);
                pvpPreviewCtx.closePath();
                pvpPreviewCtx.fill();
                pvpPreviewCtx.restore();
            } else {
                const prevSegment = previewSnake[i - 1];
                const prevSegX = prevSegment.x * currentGridSize + 10;
                const prevSegY = prevSegment.y * currentGridSize;
                const prevCenterX = prevSegX + currentGridSize / 2;
                const prevCenterY = prevSegY + currentGridSize / 2;
                const segDx_preview = segment.x - prevSegment.x;
                
                pvpPreviewCtx.strokeStyle = skinOptions.wireColor;
                pvpPreviewCtx.lineWidth = 1.5;
                pvpPreviewCtx.beginPath();
                pvpPreviewCtx.moveTo(prevCenterX, prevCenterY);
                pvpPreviewCtx.lineTo(centerX, centerY);
                pvpPreviewCtx.stroke();
                
                let entryPoint, exitPoint, controlPoint, remainingArc;
                if (segDx_preview === 1) { entryPoint = { x: centerX - radius, y: centerY }; exitPoint = { x: prevCenterX + radius, y: prevCenterY }; controlPoint = { x: (centerX + prevCenterX) / 2, y: centerY + radius / 1.5 }; remainingArc = { start: Math.PI / 2, end: -Math.PI / 2 }; } 
                else if (segDx_preview === -1) { entryPoint = { x: centerX + radius, y: centerY }; exitPoint = { x: prevCenterX - radius, y: prevCenterY }; controlPoint = { x: (centerX + prevCenterX) / 2, y: centerY - radius / 1.5 }; remainingArc = { start: -Math.PI / 2, end: Math.PI / 2 }; }
                else if (segment.y > prevSegment.y) { entryPoint = { x: centerX, y: centerY - radius }; exitPoint = { x: prevCenterX, y: prevCenterY + radius }; controlPoint = { x: centerX - radius / 1.5, y: (centerY + prevCenterY) / 2 }; remainingArc = { start: 0, end: Math.PI }; } 
                else { entryPoint = { x: centerX, y: centerY + radius }; exitPoint = { x: prevCenterX, y: prevCenterY - radius }; controlPoint = { x: centerX + radius / 1.5, y: (centerY + prevCenterY) / 2 }; remainingArc = { start: Math.PI, end: 0 }; }

                pvpPreviewCtx.strokeStyle = skinOptions.wireColor;
                pvpPreviewCtx.lineWidth = 2.5;
                pvpPreviewCtx.beginPath();
                pvpPreviewCtx.moveTo(exitPoint.x, exitPoint.y);
                pvpPreviewCtx.quadraticCurveTo(controlPoint.x, controlPoint.y, entryPoint.x, entryPoint.y);
                pvpPreviewCtx.stroke();
                pvpPreviewCtx.beginPath();
                pvpPreviewCtx.arc(centerX, centerY, radius - 1.5, remainingArc.start, remainingArc.end, segDx_preview === -1);
                pvpPreviewCtx.stroke();
            }
        } else if (skinKey === 'halloween') {
            const pumpkinColor = skinOptions.headColor;
            const bodyBlack = skinOptions.bodyColor1;
            const bodyPurple = skinOptions.bodyColor2;
            const lineOrange = skinOptions.lineColor;

            if (isHead) {
                pvpPreviewCtx.fillStyle = pumpkinColor;
                pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize, previewGridSize);
                pvpPreviewCtx.fillStyle = '#000000';
                const pg_half = previewGridSize / 2;
                pvpPreviewCtx.beginPath();
                pvpPreviewCtx.moveTo(segmentX + previewGridSize * 0.2, segmentY + previewGridSize * 0.2);
                pvpPreviewCtx.lineTo(segmentX + previewGridSize * 0.4, segmentY + previewGridSize * 0.4);
                pvpPreviewCtx.lineTo(segmentX + previewGridSize * 0.2, segmentY + previewGridSize * 0.4);
                pvpPreviewCtx.closePath(); pvpPreviewCtx.fill();
                pvpPreviewCtx.beginPath();
                pvpPreviewCtx.moveTo(segmentX + previewGridSize * 0.8, segmentY + previewGridSize * 0.2);
                pvpPreviewCtx.lineTo(segmentX + previewGridSize * 0.6, segmentY + previewGridSize * 0.4);
                pvpPreviewCtx.lineTo(segmentX + previewGridSize * 0.8, segmentY + previewGridSize * 0.4);
                pvpPreviewCtx.closePath(); pvpPreviewCtx.fill();
                pvpPreviewCtx.beginPath();
                pvpPreviewCtx.moveTo(segmentX + pg_half, segmentY + pg_half - (pg_half * 0.1));
                pvpPreviewCtx.lineTo(segmentX + pg_half - (pg_half * 0.2), segmentY + pg_half + (pg_half * 0.2));
                pvpPreviewCtx.lineTo(segmentX + pg_half + (pg_half * 0.2), segmentY + pg_half + (pg_half * 0.2));
                pvpPreviewCtx.closePath(); pvpPreviewCtx.fill();
                const mouthY_abs = segmentY + pg_half + (pg_half * 0.4);
                pvpPreviewCtx.fillRect(segmentX + pg_half - (pg_half * 0.8), mouthY_abs, pg_half * 1.6, pg_half * 0.2);
                pvpPreviewCtx.fillRect(segmentX + pg_half - (pg_half * 0.5), mouthY_abs - (pg_half * 0.2), pg_half * 0.2, pg_half * 0.2);
                pvpPreviewCtx.fillRect(segmentX + pg_half + (pg_half * 0.3), mouthY_abs - (pg_half * 0.2), pg_half * 0.2, pg_half * 0.2);
            } else {
                pvpPreviewCtx.fillStyle = bodyPurple;
                pvpPreviewCtx.fillRect(segmentX, segmentY, previewGridSize, previewGridSize);
                pvpPreviewCtx.fillStyle = bodyBlack;
                pvpPreviewCtx.fillRect(segmentX + 0, segmentY + 1, previewGridSize + 3, previewGridSize + 3);
                const fillSize = previewGridSize - 2;
                const fillX = segmentX + 1;
                const fillY = segmentY + 1;
                const halfFillSize = fillSize / 2;
                const lineSize = 2;
                pvpPreviewCtx.fillStyle = bodyBlack;
                pvpPreviewCtx.fillRect(fillX, fillY, fillSize, halfFillSize - (lineSize/2));
                pvpPreviewCtx.fillStyle = bodyPurple;
                pvpPreviewCtx.fillRect(fillX, fillY + halfFillSize + (lineSize/2), fillSize, halfFillSize - (lineSize/2));
                pvpPreviewCtx.fillStyle = lineOrange;
                pvpPreviewCtx.fillRect(fillX, fillY + halfFillSize - (lineSize/2), fillSize, lineSize);
            }
        }
    }
    if (skinKey === 'halloween') {
        const lineOrange = skins.halloween.lineColor;
        const bodyBlack = skins.halloween.bodyColor1;
        const bodyPurple = skins.halloween.bodyColor2;
        const lineSize = 2;
        for (let i = 1; i < previewSnake.length; i++) {
            const curr = previewSnake[i];
            const connX = (curr.x * previewGridSize) + offsetX - 1;
            const connY = curr.y * previewGridSize + 1;
            const connW = 2;
            const connH = previewGridSize - 2;
            const halfSize = connH / 2;
            pvpPreviewCtx.fillStyle = bodyBlack;
            pvpPreviewCtx.fillRect(connX, connY, connW, halfSize - lineSize / 2);
            pvpPreviewCtx.fillStyle = bodyPurple;
            pvpPreviewCtx.fillRect(connX, connY + halfSize + lineSize / 2, connW, halfSize - lineSize / 2);
            pvpPreviewCtx.fillStyle = lineOrange;
            pvpPreviewCtx.fillRect(connX, connY + halfSize - lineSize / 2, connW, lineSize);
        }
    }
}

function selectPvpSkin(skinKey) {
    const skin = skins[skinKey];
    if (!skin) return;

    drawPvpSkinPreview(skinKey);

    const buyBtn = document.getElementById('buySkinBtnPvp');
    const isLocked = !unlockedSkins.includes(skinKey);

    if (isLocked && skin.unlockCoins) {
        buyBtn.style.display = 'block';
        const buyText = translations[currentLanguage]['confirm_buy_skin'] || 'Comprar por';
        buyBtn.textContent = `${buyText.split(' ')[0]} ${skin.unlockCoins} SC 🪙`;
        buyBtn.dataset.skinToBuy = skinKey;
    } else {
        buyBtn.style.display = 'none';
    }

    if (!isLocked) {
        currentSkin = skinKey;
    }
    
    const colorPickerContainer = document.getElementById('colorPickerContainerPvp');
    colorPickerContainer.style.display = skinKey === 'custom' ? 'block' : 'none';
}

// --- Funções da Aba "Partida" (Dificuldade e Mapa) ---

function selectPvpDifficulty(difficulty) {
    pvpDifficulty = difficulty;
    const buttons = document.querySelectorAll('#pvpDifficultySelection .difficulty-btn');
    buttons.forEach(btn => btn.classList.remove('selected'));
    document.querySelector(`#pvpDifficultySelection .difficulty-btn.${difficulty}`).classList.add('selected');
    console.log(`Dificuldade PvP selecionada: ${pvpDifficulty}`);
}

function selectPvpMap(map) {
    pvpMap = map;
    const buttons = document.querySelectorAll('#pvpMapSelection .difficulty-btn');
    buttons.forEach(btn => {
        btn.classList.remove('selected');
        if (btn.getAttribute('onclick').includes(`'${map}'`)) {
            btn.classList.add('selected');
        }
    });
    console.log(`Mapa PvP selecionado: ${pvpMap}`);
}

// ==================================================================
// FASE 2: LÓGICA DE MATCHMAKING E INTERFACE PVP
// ==================================================================

// --- Variáveis de estado para o matchmaking ---
let isSearching = false;
let matchmakingListener = null; // Para "escutar" a fila
let userQueueDocId = null; // Para saber qual documento apagar se o jogador cancelar
let waitTimeInterval = null; // Para o cronômetro de tempo de espera

const searchMatchBtn = document.getElementById('searchMatchBtn');
const waitTimeDisplay = document.getElementById('waitTimeDisplay');

// Função principal chamada pelo botão "Procurar Partida"
async function handleSearchMatch() {
    // Pega o custo da partida com base na dificuldade selecionada
    const requiredCoins = pvpRewards[pvpDifficulty];
    
    // Log no console para ajudar em futuras depurações
    console.log(`--- Verificando Saldo PvP ---`);
    console.log(`Saldo Atual (snakeCoins): ${snakeCoins} (Tipo: ${typeof snakeCoins})`);
    console.log(`Dificuldade Selecionada (pvpDifficulty): '${pvpDifficulty}'`);
    console.log(`Custo da Partida (requiredCoins): ${requiredCoins} (Tipo: ${typeof requiredCoins})`);
    console.log(`-----------------------------`);

    // Verificação de segurança para garantir que os dados de saldo e custo foram carregados corretamente
    if (typeof snakeCoins !== 'number' || typeof requiredCoins !== 'number') {
        showCustomAlert("Erro", "Não foi possível verificar seu saldo. Seus dados ainda podem estar carregando. Por favor, tente novamente em alguns segundos.");
        console.error("Verificação de saldo falhou porque um dos valores não era um número.", { saldo: snakeCoins, custo: requiredCoins });
        return;
    }

    // Verificação principal de saldo insuficiente
    if (snakeCoins < requiredCoins) {
        const title = "Saldo Insuficiente";
        const message = `Você precisa de ${requiredCoins} SC 🪙 para entrar em uma partida na dificuldade '${pvpDifficulty}', mas você possui apenas ${snakeCoins} SC 🪙.`;
        showCustomAlert(title, message);
        return;
    }
    
    // Verificações padrão de estado do jogo e do usuário
    const user = auth.currentUser;
    if (!user || !currentUsername) {
        showCustomAlert("Aguarde", "Seus dados ainda estão carregando. Por favor, tente novamente em um momento.");
        return;
    }
    if (isSearching) return;

    // Inicia o processo de busca
    isSearching = true;
    updateSearchUI(true);

    try {
        const queueRef = db.collection('matchmakingQueue').doc();
        userQueueDocId = queueRef.id;

        // Adiciona o jogador à fila no Firebase
        await queueRef.set({
            userId: user.uid,
            username: currentUsername,
            difficulty: pvpDifficulty,
            map: pvpMap,
            skin: currentSkin,
            status: 'waiting',
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        findOpponent(user.uid);
        listenForMyMatch(userQueueDocId);

    } catch (error) {
        console.error("Erro ao entrar na fila de matchmaking:", error);
        showCustomAlert("Erro de Conexão", "Ocorreu um erro ao procurar partida. Tente novamente.");
        await cancelSearch();
    }
}

// Função que procura por um oponente compatível na fila
async function findOpponent(currentUserId) {
    matchmakingListener = db.collection('matchmakingQueue')
        .where('status', '==', 'waiting')
        .where('difficulty', '==', pvpDifficulty)
        .where('map', '==', pvpMap)
        .onSnapshot(async (snapshot) => {
            const potentialOpponents = [];
            snapshot.forEach(doc => {
                if (doc.data().userId !== currentUserId) {
                    potentialOpponents.push({ id: doc.id, ...doc.data() });
                }
            });

            if (potentialOpponents.length > 0) {
                if (matchmakingListener) {
                    matchmakingListener();
                    matchmakingListener = null;
                }
                await createGameRoom(currentUserId, potentialOpponents[0]);
            }
        }, (error) => {
             console.error("Erro no listener do matchmaking:", error);
             alert("Ocorreu um erro de conexão com a fila. Verifique se o índice do Firestore foi criado corretamente.");
             cancelSearch();
        });
}

// Função que cria a sala de jogo para os dois jogadores
async function createGameRoom(player1Id, opponent) {
    try {
        const roomRef = db.collection('gameRooms').doc();
        const roomId = roomRef.id;

        const player1InitialSnake = [{ x: Math.floor(pvpTileCountX / 4), y: Math.floor(pvpTileCountY / 2) }];
        const player2InitialSnake = [{ x: Math.floor(pvpTileCountX * 3 / 4), y: Math.floor(pvpTileCountY / 2) }];

        const player1InitialFood = { x: Math.floor(Math.random() * pvpTileCountX), y: Math.floor(Math.random() * pvpTileCountY) };
        const player2InitialFood = { x: Math.floor(Math.random() * pvpTileCountX), y: Math.floor(Math.random() * pvpTileCountY) };

        await roomRef.set({
            player1: { id: player1Id, username: currentUsername, score: 0, skin: currentSkin, snake: player1InitialSnake, food: player1InitialFood, direction: {dx: 0, dy: 0}, lastUpdate: firebase.firestore.FieldValue.serverTimestamp() },
            player2: { id: opponent.userId, username: opponent.username, score: 0, skin: opponent.skin, snake: player2InitialSnake, food: player2InitialFood, direction: {dx: 0, dy: 0}, lastUpdate: firebase.firestore.FieldValue.serverTimestamp() },
            map: pvpMap,
            difficulty: pvpDifficulty,
            status: 'starting',
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        const batch = db.batch();
        batch.update(db.collection('matchmakingQueue').doc(userQueueDocId), { status: 'matched', roomId: roomId });
        batch.update(db.collection('matchmakingQueue').doc(opponent.id), { status: 'matched', roomId: roomId });
        await batch.commit();
        
        matchFound(roomId);

    } catch (error) {
        console.error("Erro ao criar a sala de jogo:", error);
        await cancelSearch();
    }
}

// Função para cancelar a busca
async function cancelSearch() {
    // Para o listener que busca oponentes
    if (matchmakingListener) {
        matchmakingListener();
        matchmakingListener = null;
    }

    // Remove o jogador da fila no Firebase
    if (userQueueDocId) {
        try {
            await db.collection('matchmakingQueue').doc(userQueueDocId).delete();
        } catch(e) { console.error("Falha ao remover da fila (pode já ter sido removido):", e)}
        userQueueDocId = null;
    }

    // Reseta o estado da busca
    isSearching = false;
    updateSearchUI(false); // Chama a função para atualizar a interface
}

// Função para atualizar a UI durante a busca
function updateSearchUI(isSearchingUpdate) {
    // Adiciona uma referência ao botão de cancelar
    const cancelSearchBtn = document.getElementById('cancelSearchBtn');

    if (isSearchingUpdate) {
        // Esconde o botão de procurar e mostra o de cancelar
        searchMatchBtn.style.display = 'none';
        cancelSearchBtn.style.display = 'block'; 

        // Inicia o cronômetro de espera
        let seconds = 0;
        waitTimeDisplay.textContent = `Procurando... 0s`;
        if (waitTimeInterval) clearInterval(waitTimeInterval);
        waitTimeInterval = setInterval(() => {
            seconds++;
            waitTimeDisplay.textContent = `Procurando... ${seconds}s`;
        }, 1000);
    } else {
        // Esconde o botão de cancelar e mostra o de procurar
        searchMatchBtn.style.display = 'block';
        cancelSearchBtn.style.display = 'none';

        // Para e reseta o cronômetro de espera
        if (waitTimeInterval) clearInterval(waitTimeInterval);
        waitTimeDisplay.textContent = "Tempo de Espera: --";
    }
}

// ==================================================================
// FASE 2 & 3: LÓGICA PVP COMPLETA (VERSÃO FINAL COM SKINS E MOVIMENTO CORRIGIDOS)
// ==================================================================

// --- Variáveis de estado do Jogo PvP ---
let activeRoomListener = null;
let pvpGameLoopInterval = null;
let pvpGameTimerInterval = null;
let activeRoomId = null;
let localPlayerKey = null;
let pvpCountdownInterval = null;
let opponentPlayerKey = null;
let activeRoomData = {};
let isGameEnding = false;

const pvpLocalCanvas = document.getElementById('localPlayerPvPCanvas');
const pvpLocalCtx = pvpLocalCanvas.getContext('2d');
const pvpOpponentCanvas = document.getElementById('opponentCanvas');
const pvpOpponentCtx = pvpOpponentCanvas.getContext('2d');
const opponentOverlay = document.querySelector('.opponent-overlay');

// Estado do jogo local
let pvpLocalSnake = [];
let pvpLocalDirection = { dx: 0, dy: 0 };
let pvpLocalInputQueue = [];
let pvpLocalScore = 0;
let pvpGameRunning = false;
let pvpLocalSkin = 'default';
let pvpLocalFood = {};
let isCountdownActive = false;
let localPlayerSabotages = [];
let controlsInverted = false;
let pvpLocalObstacles = [];
let isAccelerated = false;
let pvpLocalPoisonFood = {};
let isPoisonFoodActive = false;
let poisonFoodEats = 0;
let isFoodRepellentActive = false;
let originalPvpSpeed = 0;

// Estado do oponente
let pvpOpponentSnake = [];
let pvpOpponentScore = 0;
let pvpOpponentSkin = 'default';
let pvpOpponentFood = {};
let pvpOpponentDirection = { dx: 0, dy: 0 };
let isPvpPausedForQuit = false; // Controla se o jogo está pausado para a decisão
let quitConfirmTimeout = null; // Armazena o ID do timer de 4 segundos


// --- Funções de Matchmaking ---

async function handleSearchMatch() {
    // PASSO 1: O "INVESTIGADOR" - Mostra os valores no console para diagnóstico.
    const requiredCoins = pvpRewards[pvpDifficulty];
    console.log(`--- Verificando Saldo PvP ---`);
    console.log(`Saldo Atual (snakeCoins): ${snakeCoins} (Tipo: ${typeof snakeCoins})`);
    console.log(`Dificuldade Selecionada (pvpDifficulty): '${pvpDifficulty}'`);
    console.log(`Custo da Partida (requiredCoins): ${requiredCoins} (Tipo: ${typeof requiredCoins})`);
    console.log(`-----------------------------`);

    // PASSO 2: O "GUARDA-COSTAS" - Uma verificação mais robusta.
    // Primeiro, garante que temos números válidos para comparar.
    if (typeof snakeCoins !== 'number' || typeof requiredCoins !== 'number') {
        alert(`Ocorreu um erro ao verificar seu saldo. Seus dados ainda podem estar carregando. Por favor, tente novamente em alguns segundos.`);
        // Mostra um erro mais detalhado para nos ajudar a depurar
        console.error("Verificação de saldo falhou porque um dos valores não era um número.", {
            saldo: snakeCoins,
            custo: requiredCoins
        });
        return; // Bloqueia a busca
    }

    // Se ambos são números, faz a comparação normal.
    if (snakeCoins < requiredCoins) {
        alert(`Você não tem moedas suficientes para entrar nesta partida.\n\nDificuldade ${pvpDifficulty}: Requer ${requiredCoins} SC 🪙\nVocê tem: ${snakeCoins} SC 🪙`);
        return; // Bloqueia a busca.
    }
    // --- Fim do novo bloco de verificação ---

    // O resto da função continua como estava...
    const user = auth.currentUser;
    if (!user || !currentUsername) {
        alert("Seus dados ainda estão carregando. Por favor, aguarde um momento e tente novamente.");
        return;
    }
    if (isSearching) return;

    isSearching = true;
    updateSearchUI(true);

    try {
        const queueRef = db.collection('matchmakingQueue').doc();
        userQueueDocId = queueRef.id;

        await queueRef.set({
            userId: user.uid,
            username: currentUsername,
            difficulty: pvpDifficulty,
            map: pvpMap,
            skin: currentSkin,
            status: 'waiting',
            timestamp: firebase.firestore.FieldValue.serverTimestamp()
        });
        
        findOpponent(user.uid);
        listenForMyMatch(userQueueDocId);

    } catch (error) {
        console.error("Erro ao entrar na fila de matchmaking:", error);
        alert("Ocorreu um erro ao procurar partida. Tente novamente.");
        await cancelSearch();
    }
}

function findOpponent(currentUserId) {
    if (matchmakingListener) matchmakingListener();
    
    matchmakingListener = db.collection('matchmakingQueue')
        .where('status', '==', 'waiting')
        .where('difficulty', '==', pvpDifficulty)
        .where('map', '==', pvpMap)
        .onSnapshot(async (snapshot) => {
            const potentialOpponents = [];
            snapshot.forEach(doc => {
                if (doc.data().userId !== currentUserId) {
                    potentialOpponents.push({ id: doc.id, ...doc.data() });
                }
            });

            if (potentialOpponents.length > 0) {
                const opponent = potentialOpponents[0];
                if (currentUserId < opponent.userId) {
                    if (matchmakingListener) {
                        matchmakingListener();
                        matchmakingListener = null;
                    }
                    await createGameRoom(currentUserId, opponent);
                }
            }
        });
}

function listenForMyMatch(myQueueId) {
    if (activeRoomListener) activeRoomListener();

    activeRoomListener = db.collection('matchmakingQueue').doc(myQueueId)
        .onSnapshot((doc) => {
            if (doc.exists && doc.data().status === 'matched') {
                const roomId = doc.data().roomId;
                if (roomId) {
                    if (matchmakingListener) {
                        matchmakingListener();
                        matchmakingListener = null;
                    }
                    isSearching = false;
                    matchFound(roomId);
                }
            }
        });
}

async function createGameRoom(player1Id, opponent) {
    try {
        const roomRef = db.collection('gameRooms').doc();
        const roomId = roomRef.id;

        // Posições iniciais ajustadas para serem mais centrais
        const player1InitialSnake = [{ x: Math.floor(pvpTileCountX / 4), y: Math.floor(pvpTileCountY / 2) }];
        const player2InitialSnake = [{ x: Math.floor(pvpTileCountX * 3 / 4), y: Math.floor(pvpTileCountY / 2) }];

        // Comidas iniciais ajustadas para o novo mapa retangular
        const player1InitialFood = { x: Math.floor(Math.random() * pvpTileCountX), y: Math.floor(Math.random() * pvpTileCountY) };
        const player2InitialFood = { x: Math.floor(Math.random() * pvpTileCountX), y: Math.floor(Math.random() * pvpTileCountY) };

        await roomRef.set({
            player1: { id: player1Id, username: currentUsername, score: 0, skin: currentSkin, snake: player1InitialSnake, food: player1InitialFood, direction: {dx: 0, dy: 0} },
            player2: { id: opponent.userId, username: opponent.username, score: 0, skin: opponent.skin, snake: player2InitialSnake, food: player2InitialFood, direction: {dx: 0, dy: 0} },
            map: pvpMap,
            difficulty: pvpDifficulty,
            status: 'starting',
            createdAt: firebase.firestore.FieldValue.serverTimestamp()
        });

        const batch = db.batch();
        batch.update(db.collection('matchmakingQueue').doc(userQueueDocId), { status: 'matched', roomId: roomId });
        batch.update(db.collection('matchmakingQueue').doc(opponent.id), { status: 'matched', roomId: roomId });
        await batch.commit();
        
        matchFound(roomId);

    } catch (error) {
        console.error("Erro ao criar a sala de jogo:", error);
        await cancelSearch();
    }
}


// --- Funções de Controle da Partida ---

function matchFound(roomId) {
    if (matchmakingListener) matchmakingListener();
    if (activeRoomListener) activeRoomListener();
    matchmakingListener = null;
    activeRoomListener = null;

    console.log(`Partida encontrada! Entrando na sala: ${roomId}`);
    if (waitTimeInterval) clearInterval(waitTimeInterval);
    
    waitTimeDisplay.textContent = "Partida Encontrada!";
    searchMatchBtn.style.display = 'none';
    activeRoomId = roomId;
    enterGameRoom(roomId);
}

function enterGameRoom(roomId) {
    const roomRef = db.collection('gameRooms').doc(roomId);
    if (activeRoomListener) activeRoomListener(); // Limpa qualquer listener antigo

    let lastSabotageTimestamp = null;

    activeRoomListener = roomRef.onSnapshot(doc => {
        // Se a sala for deletada, o jogo já acabou. Apenas limpa a UI.
        if (!doc.exists) {
            endPvpGame("A partida foi encerrada.");
            return;
        }

        const roomData = doc.data();
        activeRoomData = roomData;
        const user = auth.currentUser;

        if (!user) {
            endPvpGame("Erro de autenticação.");
            return;
        }
        
        const isPlayer1 = user.uid === roomData.player1.id;
        localPlayerKey = isPlayer1 ? 'player1' : 'player2';
        opponentPlayerKey = isPlayer1 ? 'player2' : 'player1';

        // --- NOVO VIGIA PARA O FIM DA PARTIDA ---
        // Esta é agora a verificação principal para o fim de jogo por tempo.
        // Ambos os jogadores verão o status 'finished' e reagirão a ele.
        if (roomData.status === 'finished' && roomData.result) {
            const outcome = {
                ...roomData.result, // Pega o resultado (winnerId, loserId, etc.) do Firebase
                localPlayerId: user.uid // Adiciona o ID local para a lógica da UI
            };
            endPvpGame("O tempo acabou!", outcome);
            return; // Encerra a execução do listener aqui.
        }
        
        // A lógica abaixo continua a tratar de casos onde o jogo não termina por tempo.

        // Cenário de desistência
        if (roomData.status === 'opponent_left' && roomData.quitterId !== user.uid) {
            const outcome = { winnerId: user.uid, loserId: roomData.quitterId, localPlayerId: user.uid };
            endPvpGame("O oponente saiu da partida.", outcome);
            return;
        }

        // Cenário de desconexão (timeout)
        if (pvpGameRunning && roomData[opponentPlayerKey].lastUpdate) {
            const timeDifference = Date.now() - roomData[opponentPlayerKey].lastUpdate.toMillis();
            if (timeDifference > 5000) { // 5 segundos
                const outcome = { winnerId: user.uid, loserId: roomData[opponentPlayerKey].id, localPlayerId: user.uid };
                endPvpGame("O adversário perdeu a conexão.", outcome);
                return;
            }
        }
        
        // Recebimento de sabotagens
        if (roomData.lastSabotage) {
            const sabotageInfo = roomData.lastSabotage;
            if (sabotageInfo.target === localPlayerKey && sabotageInfo.timestamp?.toMillis() !== lastSabotageTimestamp) {
                lastSabotageTimestamp = sabotageInfo.timestamp?.toMillis();
                handleIncomingSabotage(sabotageInfo.type);
            }
        }

        // Sincronização do estado do oponente (posições, placar, etc.)
        pvpOpponentSnake = roomData[opponentPlayerKey].snake || [];
        pvpOpponentScore = roomData[opponentPlayerKey].score || 0;
        pvpOpponentSkin = roomData[opponentPlayerKey].skin;
        pvpOpponentFood = roomData[opponentPlayerKey].food || {};
        pvpOpponentDirection = roomData[opponentPlayerKey].direction || { dx: 0, dy: 0 };
        pvpOpponentPoisonFood = roomData[opponentPlayerKey].poisonFood || {};
        document.getElementById('localScoreDisplay').textContent = `Sua Pontuação: ${roomData[localPlayerKey].score || 0}`;
        document.getElementById('opponentScoreDisplay').textContent = `Oponente: ${roomData[opponentPlayerKey].score || 0}`;

        // Início da contagem regressiva
        if ((roomData.status === 'starting' || roomData.status === 'countdown') && !pvpGameRunning && !isCountdownActive) {
            startCountdown(roomData[localPlayerKey], roomData[opponentPlayerKey]);
            if (localPlayerKey === 'player1') {
                roomRef.update({ status: 'countdown' });
            }
        }
    });
}

function handleIncomingSabotage(sabotageType) {
    const sabotageData = sabotages[sabotageType];
    if (!sabotageData) return;

    showSabotageFeedback(sabotageData.icon);

    switch (sabotageType) {
        case 'invertControls':
            controlsInverted = true;
            setTimeout(() => {
                controlsInverted = false;
            }, sabotageData.duration);
            break;       
        
        case 'addObstacles':
            pvpLocalObstacles = [];
            for (let i = 0; i < 8; i++) {
                let obstaclePos;
                let validPosition = false;                
                while (!validPosition) {
                    obstaclePos = {
                        x: Math.floor(Math.random() * pvpTileCountX),
                        y: Math.floor(Math.random() * pvpTileCountY)
                    };
                    if (!pvpLocalSnake.some(seg => seg.x === obstaclePos.x && seg.y === obstaclePos.y)) {
                        validPosition = true;
                    }
                }
                pvpLocalObstacles.push(obstaclePos);
            }
            
            // ==================================================================
            // ======================= ALTERAÇÃO PRINCIPAL AQUI =================
            // Adiciona o timer para limpar os obstáculos após o tempo definido.
            setTimeout(() => {
                pvpLocalObstacles = []; // Esvazia o array de obstáculos
            }, sabotageData.duration); // Usa a duração de 10000ms que definimos
            // ==================================================================
            // ==================================================================

            break;

        case 'forcedAcceleration':
            if (isAccelerated) return;
            isAccelerated = true;                    
            const fasterSpeed = originalPvpSpeed / 1.25;            
            clearInterval(pvpGameLoopInterval);            
            pvpGameLoopInterval = setInterval(pvpGameLoop, fasterSpeed);            
            setTimeout(() => {                
                clearInterval(pvpGameLoopInterval);                
                pvpGameLoopInterval = setInterval(pvpGameLoop, originalPvpSpeed);
                isAccelerated = false;
            }, sabotageData.duration);
            break;

        case 'smokeScreen':
            const smokeOverlay = document.getElementById('smoke-overlay');
            smokeOverlay.style.opacity = '1';
            setTimeout(() => {
                smokeOverlay.style.opacity = '0';
            }, sabotageData.duration);
            break;

        case 'poisonedFood':
            isPoisonFoodActive = true;
            poisonFoodEats = 0;
            generatePvpFood();
            generateSinglePoisonFood();
            break;

        case 'foodRepellent':
            isFoodRepellentActive = true;
            setTimeout(() => {
                isFoodRepellentActive = false;
            }, sabotageData.duration);
            break;
    }
}
function showSabotageFeedback(icon) {
    const feedbackEl = document.getElementById('sabotage-feedback');
    if (!feedbackEl) return;

    feedbackEl.textContent = icon;
    
    // Reinicia a animação removendo e adicionando a classe
    feedbackEl.classList.remove('show');
    // Força o navegador a "repintar" o elemento, necessário para reiniciar a animação
    void feedbackEl.offsetWidth; 
    feedbackEl.classList.add('show');
}
function startCountdown(localPlayerData, opponentPlayerData) {
    isCountdownActive = true; // ATIVA A TRAVA
    opponentOverlay.style.visibility = 'hidden';
    const countdownElement = document.getElementById('pvpCountdown');
    countdownElement.style.display = 'block';
    let count = 5;
    countdownElement.textContent = count;

    // Lembre-se de usar a variável global aqui, como na correção anterior
    pvpCountdownInterval = setInterval(() => {
        count--;
        if (count > 0) {
            countdownElement.textContent = count;
        } else {
            clearInterval(pvpCountdownInterval);
            countdownElement.style.display = 'none';
            if (!pvpGameRunning) {
                 startPvpGame(localPlayerData, opponentPlayerData);
            }
        }
    }, 1000);
}

function startPvpGame(localPlayerData, opponentPlayerData) {
    isCountdownActive = false;
    console.log("A PARTIDA COMEÇOU COM OS DADOS CORRETOS!");
    const timerElement = document.getElementById('pvpGameTimer');
    timerElement.style.visibility = 'visible';
    pvpGameRunning = true;
    pvpLocalSnake = localPlayerData.snake;
    pvpLocalFood = localPlayerData.food;
    pvpLocalSkin = localPlayerData.skin;
    pvpLocalDirection = { dx: 0, dy: 0 };
    pvpLocalInputQueue = [];
    pvpLocalScore = 0;
    
    const allSabotageKeys = Object.keys(sabotages);
    const shuffledKeys = allSabotageKeys.sort(() => 0.5 - Math.random());
    localPlayerSabotages = shuffledKeys.slice(0, 3);
    displaySabotageButtons();
    
    let gameTime = 90;
    const initialMinutes = Math.floor(gameTime / 60).toString().padStart(2, '0');
    const initialSeconds = (gameTime % 60).toString().padStart(2, '0');
    timerElement.textContent = `${initialMinutes}:${initialSeconds}`;    
    
    pvpGameTimerInterval = setInterval(() => {
        gameTime--;
        const minutes = Math.floor(gameTime / 60).toString().padStart(2, '0');
        const seconds = (gameTime % 60).toString().padStart(2, '0');
        timerElement.textContent = `${minutes}:${seconds}`;
        
        // --- MUDANÇA PRINCIPAL AQUI ---
        // Quando o tempo acaba, o 'player1' apenas atualiza a sala com o resultado.
        if (gameTime <= 0 && localPlayerKey === 'player1') {
            clearInterval(pvpGameTimerInterval); // Para o timer para não executar de novo

            const opponentScore = pvpOpponentScore || 0;
            let result = {};

            if (pvpLocalScore > opponentScore) {
                result = { winnerId: auth.currentUser.uid, loserId: activeRoomData[opponentPlayerKey].id };
            } else if (opponentScore > pvpLocalScore) {
                result = { winnerId: activeRoomData[opponentPlayerKey].id, loserId: auth.currentUser.uid };
            } else {
                result = { isDraw: true };
            }

            // Atualiza o status da sala no Firebase para 'finished' e adiciona o resultado.
            db.collection('gameRooms').doc(activeRoomId).update({
                status: 'finished',
                result: result
            }).catch(err => console.error("Erro ao finalizar a partida:", err));
        }
    }, 1000);

    const gameSpeed = difficulties[pvpDifficulty] ? difficulties[pvpDifficulty].speed : 120;
    originalPvpSpeed = gameSpeed;
    if (pvpGameLoopInterval) clearInterval(pvpGameLoopInterval);
    pvpGameLoopInterval = setInterval(pvpGameLoop, originalPvpSpeed);
}

function displaySabotageButtons() {
    const container = document.getElementById('sabotageControls');
    container.innerHTML = ''; // Limpa botões anteriores

    localPlayerSabotages.forEach(sabotageId => {
        const sabotageData = sabotages[sabotageId];
        if (!sabotageData) return;

        const button = document.createElement('button');
        button.className = 'sabotage-btn';
        button.innerHTML = sabotageData.icon;
        button.title = sabotageData.name_pt; // Dica ao passar o mouse
        button.dataset.sabotageId = sabotageId; // Guarda o ID da sabotagem
        button.onclick = () => activateSabotage(button);

        container.appendChild(button);
    });
}

function activateSabotage(buttonElement) {
    const sabotageId = buttonElement.dataset.sabotageId;
    if (!sabotageId || !activeRoomId || !localPlayerKey) return;

    // Desabilita o botão para uso único
    buttonElement.disabled = true;

    // Determina quem é o alvo (sempre o outro jogador)
    const opponentPlayerKey = localPlayerKey === 'player1' ? 'player2' : 'player1';

    // Envia a informação para o Firebase
    const roomRef = db.collection('gameRooms').doc(activeRoomId);
    roomRef.update({
        lastSabotage: {
            target: opponentPlayerKey, // O alvo
            type: sabotageId,          // O tipo de sabotagem
            timestamp: firebase.firestore.FieldValue.serverTimestamp() // Para evitar repetições
        }
    }).catch(err => console.error("Erro ao ativar sabotagem:", err));
}

function pvpGameLoop() {
    if (!pvpGameRunning) return;
    
    // Lógica para o efeito "Repelente de Comida" (🧲)
    if (isFoodRepellentActive && pvpLocalSnake.length > 0) {
        const head = pvpLocalSnake[0];
        // Calcula a distância entre a cabeça da cobra e a comida
        const distance = Math.hypot(head.x - pvpLocalFood.x, head.y - pvpLocalFood.y);
        
        // Se a cobra chegar perto (a menos de 4 quadrados de distância),
        // a comida "foge" para uma nova posição aleatória.
        if (distance < 4) {
            generatePvpFood(); 
        }
    }
    
    // Se o jogo NÃO estiver pausado para o jogador decidir se quer sair, executa a lógica de movimento.
    if (!isPvpPausedForQuit) {
        processPvpInput();
        updatePvpGame();
        sendDataToFirebase();
    }

    // O desenho dos tabuleiros acontece sempre, para que a tela não congele.
    drawPvpBoards();
}

function updatePvpGame() {
    // Se a cobra está parada, não faz nada.
    if (pvpLocalDirection.dx === 0 && pvpLocalDirection.dy === 0) return;

    // A lógica de aceleração já está inclusa aqui.
    const moves = 1;
    for (let i = 0; i < moves; i++) {

        if (pvpLocalSnake.length === 0) return;

        const head = { x: pvpLocalSnake[0].x + pvpLocalDirection.dx, y: pvpLocalSnake[0].y + pvpLocalDirection.dy };
        const mapConfig = maps[pvpMap] || maps['normal'];

        // 1. LÓGICA DE COLISÕES (PAREDES, OBSTÁCULOS, AUTOCOLISÃO)
        if (!mapConfig.wrapAround && (head.x < 0 || head.x >= pvpTileCountX || head.y < 0 || head.y >= pvpTileCountY)) {
            pvpLocalScore = Math.max(0, pvpLocalScore - 1);
            document.getElementById('localScoreDisplay').textContent = `Sua Pontuação: ${pvpLocalScore}`;
            pvpLocalDirection = { dx: 0, dy: 0 };
            if (pvpLocalSnake.length > 3) { pvpLocalSnake.pop(); pvpLocalSnake.pop(); }
            return;
        } else if (mapConfig.wrapAround) {
            if (head.x < 0) head.x = pvpTileCountX - 1; else if (head.x >= pvpTileCountX) head.x = 0;
            if (head.y < 0) head.y = pvpTileCountY - 1; else if (head.y >= pvpTileCountY) head.y = 0;
        }

        for (let j = 0; j < pvpLocalObstacles.length; j++) {
            if (head.x === pvpLocalObstacles[j].x && head.y === pvpLocalObstacles[j].y) {
                pvpLocalScore = Math.max(0, pvpLocalScore - 1);
                document.getElementById('localScoreDisplay').textContent = `Sua Pontuação: ${pvpLocalScore}`;
                pvpLocalObstacles.splice(j, 1);
                pvpLocalDirection = { dx: 0, dy: 0 };
                if (pvpLocalSnake.length > 3) { pvpLocalSnake.pop(); pvpLocalSnake.pop(); }
                return;
            }
        }
        for (let j = 1; j < pvpLocalSnake.length; j++) {
            if (head.x === pvpLocalSnake[j].x && head.y === pvpLocalSnake[j].y) {
                pvpLocalScore = Math.max(0, pvpLocalScore - 2);
                document.getElementById('localScoreDisplay').textContent = `Sua Pontuação: ${pvpLocalScore}`;
                pvpLocalDirection = { dx: 0, dy: 0 };
                if (pvpLocalSnake.length > 3) { pvpLocalSnake.pop(); pvpLocalSnake.pop(); }
                return;
            }
        }

        // --- INÍCIO DA LÓGICA DA SABOTAGEM "COMIDA ENVENENADA" ---
        let tailShouldBePopped = true; // Por padrão, a cobra se move (não cresce)

        if (isPoisonFoodActive) {
            // Se comeu a COMIDA ORIGINAL durante a sabotagem
            if (head.x === pvpLocalFood.x && head.y === pvpLocalFood.y) {
                pvpLocalScore += 2; // Ponto dobrado!
                poisonFoodEats++;
                tailShouldBePopped = false; // Cobra cresce

                if (poisonFoodEats >= 3) { // Se foi a 3ª comida, termina a sabotagem
                    isPoisonFoodActive = false;
                    pvpLocalPoisonFood = {}; // Remove a comida falsa
                    generatePvpFood(); // Gera uma comida normal final
                } else {
                    generatePvpFood(); // Gera a próxima dupla
                    generateSinglePoisonFood();
                }
            }
            // Se comeu a COMIDA FALSA durante a sabotagem
            else if (pvpLocalPoisonFood.x !== undefined && head.x === pvpLocalPoisonFood.x && head.y === pvpLocalPoisonFood.y) {
                pvpLocalScore = Math.max(0, pvpLocalScore - 2); // Perde 2 pontos
                poisonFoodEats++;
                // tailShouldBePopped continua true, então a cobra não cresce

                if (poisonFoodEats >= 3) { // Se foi a 3ª comida, termina a sabotagem
                    isPoisonFoodActive = false;
                    pvpLocalPoisonFood = {}; // Remove a comida falsa
                    generatePvpFood(); // Gera uma comida normal final
                } else {
                    generatePvpFood(); // Gera a próxima dupla
                    generateSinglePoisonFood();
                }
            }
        } else {
            // Comportamento NORMAL do jogo (quando a sabotagem não está ativa)
            if (head.x === pvpLocalFood.x && head.y === pvpLocalFood.y) {
                pvpLocalScore++;
                generatePvpFood();
                tailShouldBePopped = false;
            }
        }

        document.getElementById('localScoreDisplay').textContent = `Sua Pontuação: ${pvpLocalScore}`;
        
        pvpLocalSnake.unshift(head);
        if (tailShouldBePopped) {
            pvpLocalSnake.pop();
        }
        // --- FIM DA LÓGICA DE COMIDA ---
    }
}

function generatePvpFood() {
    let newFoodPosition;
    let validPosition = false;
    
    while (!validPosition) {
        // Gera comida dentro dos limites do novo mapa retangular
        newFoodPosition = { 
            x: Math.floor(Math.random() * pvpTileCountX), 
            y: Math.floor(Math.random() * pvpTileCountY) 
        };
        validPosition = true;
        // Verifica se a nova comida não está na cobra do jogador local
        for (const segment of pvpLocalSnake) {
            if (segment.x === newFoodPosition.x && segment.y === newFoodPosition.y) {
                validPosition = false;
                break;
            }
        }
    }
    pvpLocalFood = newFoodPosition;
}
function generateSinglePoisonFood() {
    let newPoisonPosition;
    let validPosition = false;
    
    while (!validPosition) {
        newPoisonPosition = { 
            x: Math.floor(Math.random() * pvpTileCountX), 
            y: Math.floor(Math.random() * pvpTileCountY) 
        };
        validPosition = true;
        
        // Verifica se não está na cobra do jogador
        for (const segment of pvpLocalSnake) {
            if (segment.x === newPoisonPosition.x && segment.y === newPoisonPosition.y) {
                validPosition = false;
                break;
            }
        }
        
        // Verifica se não está no mesmo lugar que a comida original
        if (validPosition && newPoisonPosition.x === pvpLocalFood.x && newPoisonPosition.y === pvpLocalFood.y) {
            validPosition = false;
        }
    }
    pvpLocalPoisonFood = newPoisonPosition;
}
function sendDataToFirebase() {
    if (!activeRoomId || !localPlayerKey) return;
    const updateData = {};
    updateData[`${localPlayerKey}.snake`] = pvpLocalSnake;
    updateData[`${localPlayerKey}.score`] = pvpLocalScore;
    updateData[`${localPlayerKey}.food`] = pvpLocalFood;
    updateData[`${localPlayerKey}.direction`] = pvpLocalDirection;
    updateData[`${localPlayerKey}.lastUpdate`] = firebase.firestore.FieldValue.serverTimestamp(); // ADICIONE ESTA LINHA

    if (isPoisonFoodActive) {
        updateData[`${localPlayerKey}.poisonFood`] = pvpLocalPoisonFood;
    } else {
        updateData[`${localPlayerKey}.poisonFood`] = firebase.firestore.FieldValue.delete();
    }

    db.collection('gameRooms').doc(activeRoomId).update(updateData).catch(err => {
        if (err.code !== 'not-found') {
            console.error("Erro ao sincronizar dados:", err);
        }
    });
}

// ESTA É A ÚNICA FUNÇÃO DE DESENHO QUE VOCÊ PRECISA. COLE-A NO SEU CÓDIGO.
// ESTA É A VERSÃO CORRETA E COMPLETA DA FUNÇÃO DE DESENHO
function drawSnakeOnCanvas(ctx, snake, skinKey, direction, customColor = '#00b894') {
    if (!snake || snake.length === 0) return;

    const isPreview = (ctx.canvas.id.includes('Preview'));
    const currentGridSize = isPreview ? 20 : gridSize;
    const skinOptions = skins[skinKey] || skins['default'];
    const dx = direction ? direction.dx : 0;
    const dy = direction ? direction.dy : 0;
    const offsetX = isPreview ? 10 : 0;

    const drawWebPattern = (x, y) => {
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        ctx.lineWidth = 1;
        ctx.beginPath();
        ctx.moveTo(x + currentGridSize / 3, y);
        ctx.lineTo(x + currentGridSize / 3, y + currentGridSize);
        ctx.moveTo(x + (currentGridSize / 3) * 2, y);
        ctx.lineTo(x + (currentGridSize / 3) * 2, y + currentGridSize);
        ctx.moveTo(x, y + currentGridSize / 3);
        ctx.lineTo(x + currentGridSize, y + currentGridSize / 3);
        ctx.moveTo(x, y + (currentGridSize / 3) * 2);
        ctx.lineTo(x + currentGridSize, y + (currentGridSize / 3) * 2);
        ctx.stroke();
    };

    // Laço principal para desenhar cada segmento da cobra
    for (let i = 0; i < snake.length; i++) {
        const segment = snake[i];
        const segX = segment.x * currentGridSize + offsetX;
        const segY = segment.y * currentGridSize;
        const isHead = (i === 0);

        if (skinKey === 'default' || skinKey === 'custom') {
            let color;
            const skinData = skins[skinKey];
            if (isHead) {
                color = (skinKey === 'custom') ? shadeColor(customColor, -20) : skinData.headColor;
            } else {
                color = (skinKey === 'custom') ? customColor : skinData.bodyColor;
            }
            ctx.fillStyle = color;
            ctx.fillRect(segX, segY, currentGridSize - 2, currentGridSize - 2);
        } else if (skinKey === 'pharaoh') {
            const goldColor = skinOptions.bodyColor1;
            const blueColor = skinOptions.headColor;

            if (isHead) {
                ctx.save();
                ctx.translate(segX + currentGridSize / 2, segY + currentGridSize / 2);
                let rotation = 0;
                if (dx === 1) rotation = Math.PI / 2;
                else if (dx === -1) rotation = -Math.PI / 2;
                else if (dy === 1) rotation = Math.PI;
                ctx.rotate(rotation);

                const halfGrid = currentGridSize / 2;
                ctx.fillStyle = blueColor;
                ctx.fillRect(-halfGrid, -halfGrid, currentGridSize, currentGridSize);
                ctx.fillStyle = goldColor;
                ctx.fillRect(-halfGrid, -halfGrid, currentGridSize, currentGridSize * 0.2);
                ctx.fillRect(-halfGrid, -halfGrid * 0.2, currentGridSize, currentGridSize * 0.2);
                ctx.fillRect(-halfGrid, halfGrid * 0.6, currentGridSize, currentGridSize * 0.2);
                ctx.fillStyle = goldColor;
                ctx.fillRect(-halfGrid * 0.6, -halfGrid * 0.8, currentGridSize * 0.6, currentGridSize * 0.8);
                const eyeY = -halfGrid * 0.5;
                const eyeX = -halfGrid * 0.2;
                ctx.fillStyle = '#FFFFFF';
                ctx.fillRect(eyeX - (currentGridSize * 0.2), eyeY, currentGridSize * 0.4, currentGridSize * 0.2);
                ctx.fillRect(-eyeX - (currentGridSize * 0.2), eyeY, currentGridSize * 0.4, currentGridSize * 0.2);
                ctx.fillStyle = '#000000';
                ctx.fillRect(eyeX - (currentGridSize * 0.05), eyeY, currentGridSize * 0.1, currentGridSize * 0.2);
                ctx.fillRect(-eyeX - (currentGridSize * 0.05), eyeY, currentGridSize * 0.1, currentGridSize * 0.2);
                const beardYStart = halfGrid * 0.1;
                const beardHeight = halfGrid * 0.8;
                ctx.fillStyle = blueColor;
                ctx.fillRect(-currentGridSize * 0.15, beardYStart, currentGridSize * 0.3, beardHeight);
                ctx.fillStyle = goldColor;
                for (let j = 0; j < 3; j++) {
                    ctx.fillRect(-currentGridSize * 0.15, beardYStart + (j * 0.3) * beardHeight, currentGridSize * 0.3, beardHeight * 0.15);
                }
                ctx.restore();
            } else {
                const prevSegment = snake[i - 1];
                const segmentDx = prevSegment.x - segment.x;
                const segmentDy = prevSegment.y - segment.y;
                const halfGridSize = currentGridSize / 2;

                if (segmentDy === -1) {
                    ctx.fillStyle = goldColor; ctx.fillRect(segX, segY, halfGridSize, currentGridSize);
                    ctx.fillStyle = blueColor; ctx.fillRect(segX + halfGridSize, segY, halfGridSize, currentGridSize);
                } else if (segmentDy === 1) {
                    ctx.fillStyle = blueColor; ctx.fillRect(segX, segY, halfGridSize, currentGridSize);
                    ctx.fillStyle = goldColor; ctx.fillRect(segX + halfGridSize, segY, halfGridSize, currentGridSize);
                } else if (segmentDx === -1) {
                    ctx.fillStyle = blueColor; ctx.fillRect(segX, segY, currentGridSize, halfGridSize);
                    ctx.fillStyle = goldColor; ctx.fillRect(segX, segY + halfGridSize, currentGridSize, halfGridSize);
                } else {
                    ctx.fillStyle = goldColor; ctx.fillRect(segX, segY, currentGridSize, halfGridSize);
                    ctx.fillStyle = blueColor; ctx.fillRect(segX, segY + halfGridSize, currentGridSize, halfGridSize);
                }

                if (i % 2 === 0) {
                    const dotSize = 1;
                    if (segmentDx !== 0) {
                        const topDotColor = (segmentDx === -1) ? goldColor : blueColor;
                        const bottomDotColor = (segmentDx === -1) ? blueColor : goldColor;
                        ctx.fillStyle = topDotColor;
                        ctx.fillRect(segX + currentGridSize * 0.25, segY + halfGridSize * 0.5 - dotSize / 2, dotSize, dotSize);
                        ctx.fillStyle = bottomDotColor;
                        ctx.fillRect(segX + currentGridSize * 0.75, segY + halfGridSize * 1.5 - dotSize / 2, dotSize, dotSize);
                    } else {
                        const rightDotColor = (segmentDy === 1) ? blueColor : goldColor;
                        const leftDotColor = (segmentDy === 1) ? goldColor : blueColor;
                        ctx.fillStyle = rightDotColor;
                        ctx.fillRect(segX + halfGridSize * 1.5 - dotSize / 2, segY + currentGridSize * 0.25, dotSize, dotSize);
                        ctx.fillStyle = leftDotColor;
                        ctx.fillRect(segX + halfGridSize * 0.5 - dotSize / 2, segY + currentGridSize * 0.75, dotSize, dotSize);
                    }
                }
            }
        } else if (skinKey === 'spider') {
             if(isHead) {
                ctx.fillStyle = skinOptions.redColor; ctx.fillRect(segX, segY, currentGridSize - 2, currentGridSize - 2);
                drawWebPattern(segX, segY);
                const eyeX=currentGridSize*0.2, eyeY=currentGridSize*0.2, eyeW=currentGridSize*0.25, eyeH=currentGridSize*0.5;
                ctx.fillStyle='white'; ctx.fillRect(segX+eyeX, segY+eyeY, eyeW, eyeH); ctx.fillRect(segX+currentGridSize-2-eyeX-eyeW, segY+eyeY, eyeW, eyeH);
                ctx.strokeStyle='black'; ctx.lineWidth=1.5; ctx.strokeRect(segX+eyeX, segY+eyeY, eyeW, eyeH); ctx.strokeRect(segX+currentGridSize-2-eyeX-eyeW, segY+eyeY, eyeW, eyeH);
             } else {
                const isRed = i % 2 === 0;
                ctx.fillStyle = isRed ? skinOptions.redColor : skinOptions.blueColor;
                ctx.fillRect(segX, segY, currentGridSize - 2, currentGridSize - 2);
                if (isRed) drawWebPattern(segX, segY);
             }
        } else if (skinKey === 'coral') {
            const [c1, c2, c3] = skinOptions.colors;
            if (isHead) {
                ctx.fillStyle = c2;
                ctx.fillRect(segX, segY, currentGridSize - 2, currentGridSize - 2);
                const mSize = Math.max(2, Math.floor(currentGridSize / 6));
                ctx.fillStyle = c3;
                if (dx > 0) { ctx.fillRect(segX + currentGridSize - 2 - mSize, segY + mSize, mSize, currentGridSize - 2 - (2 * mSize)); }
                else if (dx < 0) { ctx.fillRect(segX, segY + mSize, mSize, currentGridSize - 2 - (2 * mSize)); }
                else if (dy > 0) { ctx.fillRect(segX + mSize, segY + currentGridSize - 2 - mSize, currentGridSize - 2 - (2 * mSize), mSize); }
                else { ctx.fillRect(segX + mSize, segY, currentGridSize - 2 - (2 * mSize), mSize); }
            } else {
                const prevSegment = snake[i - 1]; const segmentDx = segment.x - prevSegment.x; const segmentDy = segment.y - prevSegment.y;
                const patternIndex = (i - 1) % 4; const halfSize = (currentGridSize - 2) / 2;
                switch (patternIndex) {
                    case 0: ctx.fillStyle = c1; ctx.fillRect(segX, segY, currentGridSize - 2, currentGridSize - 2); break;
                    case 1: case 2:
                        const isPositiveDirection = (segmentDx > 0 || segmentDy > 0); const firstColor = isPositiveDirection ? c2 : c3; const secondColor = isPositiveDirection ? c3 : c2;
                        if (segmentDx === 0) { ctx.fillStyle = firstColor; ctx.fillRect(segX, segY, currentGridSize - 2, halfSize); ctx.fillStyle = secondColor; ctx.fillRect(segX, segY + halfSize, currentGridSize - 2, halfSize);
                        } else { ctx.fillStyle = firstColor; ctx.fillRect(segX, segY, halfSize, currentGridSize - 2); ctx.fillStyle = secondColor; ctx.fillRect(segX + halfSize, segY, halfSize, currentGridSize - 2); }
                        break;
                    case 3: ctx.fillStyle = c2; ctx.fillRect(segX, segY, currentGridSize - 2, currentGridSize - 2); break;
                }
            }
        } else if (skinKey === 'halloween') {
            if (isHead) {
    const pumpkinColor = skinOptions.headColor;
    const centerX = segX + currentGridSize / 2;
    const centerY = segY + currentGridSize / 2;
    const radiusX = currentGridSize / 2 * 1.1; // Um pouco mais larga
    const radiusY = currentGridSize / 2 * 0.95; // Um pouco mais baixa

    // Desenha o corpo principal da abóbora
    ctx.fillStyle = pumpkinColor;
    ctx.beginPath();
    ctx.ellipse(centerX, centerY, radiusX, radiusY, 0, 0, 2 * Math.PI);
    ctx.fill();

    // Desenha as linhas de segmento
    ctx.strokeStyle = "rgba(0,0,0,0.4)";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(centerX, centerY - radiusY);
    ctx.quadraticCurveTo(centerX - radiusX * 0.7, centerY, centerX, centerY + radiusY);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(centerX, centerY - radiusY);
    ctx.quadraticCurveTo(centerX + radiusX * 0.7, centerY, centerX, centerY + radiusY);
    ctx.stroke();

    // Desenha o talo
    ctx.fillStyle = '#6A4B24';
    ctx.beginPath();
    ctx.moveTo(centerX - 2, segY + 2);
    ctx.lineTo(centerX - 3, segY - 3);
    ctx.lineTo(centerX + 3, segY - 3);
    ctx.lineTo(centerX + 2, segY + 2);
    ctx.closePath();
    ctx.fill();

    // Salva o estado para rotacionar apenas o rosto
    ctx.save();
    ctx.translate(centerX, centerY);
    
    // Rotaciona o rosto com base na direção da cobra
    let rotation = 0;
    if (dx === 1) { rotation = Math.PI / 2; }
    else if (dx === -1) { rotation = -Math.PI / 2; }
    else if (dy === 1) { rotation = Math.PI; }
    ctx.rotate(rotation);

    const hG = currentGridSize / 2;
    // Usa um amarelo brilhante para as partes "esculpidas"
    ctx.fillStyle = '#FFD700';
    ctx.shadowColor = '#FFD700';
    ctx.shadowBlur = 6;

    // Olhos (triângulos)
    ctx.beginPath();
    ctx.moveTo(-hG * 0.6, -hG * 0.5);
    ctx.lineTo(-hG * 0.2, -hG * 0.2);
    ctx.lineTo(-hG * 0.7, -hG * 0.1);
    ctx.closePath();
    ctx.fill();

    ctx.beginPath();
    ctx.moveTo(hG * 0.6, -hG * 0.5);
    ctx.lineTo(hG * 0.2, -hG * 0.2);
    ctx.lineTo(hG * 0.7, -hG * 0.1);
    ctx.closePath();
    ctx.fill();
    
    // Reseta o brilho para a boca
    ctx.shadowBlur = 0;

    // Boca (formato de sorriso)
    ctx.beginPath();
    ctx.moveTo(-hG * 0.8, hG * 0.3);
    ctx.quadraticCurveTo(0, hG * 0.8, hG * 0.8, hG * 0.3);
    ctx.lineTo(hG * 0.6, hG * 0.5);
    ctx.quadraticCurveTo(0, hG * 1.1, -hG * 0.6, hG * 0.5);
    ctx.closePath();
    ctx.fill();

    // Restaura o estado do canvas
    ctx.restore();
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;
} else {
                // 1. Desenha o corpo listrado (para TODOS os segmentos)
                const prevSeg = snake[i - 1];
                const segDx = segment.x - prevSeg.x;
                const fillS = currentGridSize - 2,
                    halfF = fillS / 2,
                    lineS = 2;
                ctx.fillStyle = skinOptions.bodyColor2;
                ctx.fillRect(segX, segY, currentGridSize, currentGridSize);
                ctx.fillStyle = skinOptions.bodyColor1;
                ctx.fillRect(segX + 1, segY + 1, fillS, fillS);
                if (segDx === 0) {
                    ctx.fillStyle = skinOptions.bodyColor1;
                    ctx.fillRect(segX + 1, segY + 1, halfF - lineS / 2, fillS);
                    ctx.fillStyle = skinOptions.bodyColor2;
                    ctx.fillRect(segX + 1 + halfF + lineS / 2, segY + 1, halfF - lineS / 2, fillS);
                    ctx.fillStyle = skinOptions.lineColor;
                    ctx.fillRect(segX + 1 + halfF - lineS / 2, segY + 1, lineS, fillS);
                } else {
                    ctx.fillStyle = skinOptions.bodyColor1;
                    ctx.fillRect(segX + 1, segY + 1, fillS, halfF - lineS / 2);
                    ctx.fillStyle = skinOptions.bodyColor2;
                    ctx.fillRect(segX + 1, segY + 1 + halfF + lineS / 2, fillS, halfF - lineS / 2);
                    ctx.fillStyle = skinOptions.lineColor;
                    ctx.fillRect(segX + 1, segY + 1 + halfF - lineS / 2, fillS, lineS);
                }
                
                // `i` é o índice do segmento, o corpo começa em i=1.
                if (i <= 4) {
                    ctx.globalCompositeOperation = 'lighter';

                    const auraCenterX = segX + currentGridSize / 2;
                    const auraCenterY = segY + currentGridSize / 2;
                    
                    const particleCount = 10;
                    const maxOffset = currentGridSize * 0.7;
                    const maxInitialSize = 7;

                    for (let j = 0; j < particleCount; j++) {
                        const particleX = auraCenterX + (Math.random() - 0.5) * maxOffset;
                        const particleY = auraCenterY + (Math.random() - 0.5) * maxOffset;
                        const size = Math.random() * maxInitialSize;
                        const opacity = Math.random() * 0.3 + 0.1;
                        
                        const transitionLength = 3;
                        const fireColor = [255, 120, 0];
                        const smokeColor = [90, 80, 100];
                        const t = Math.min(1, (i - 1) / (transitionLength - 1));

                        const r = Math.round(fireColor[0] * (1 - t) + smokeColor[0] * t);
                        const g = Math.round(fireColor[1] * (1 - t) + smokeColor[1] * t);
                        const b = Math.round(fireColor[2] * (1 - t) + smokeColor[2] * t);

                        const particleColor = `${r}, ${g}, ${b}`;

                        ctx.fillStyle = `rgba(${particleColor}, ${opacity})`;
                        ctx.beginPath();
                        ctx.arc(particleX, particleY, size, 0, Math.PI * 2);
                        ctx.fill();
                    }

                    ctx.globalCompositeOperation = 'source-over';
                }
            }
       } else if (skinKey === 'windowsClassic') {
           if (isHead) {
                const growth = 2;
                const baseSize = currentGridSize - 2;
                const headY = segY + (currentGridSize * 0.1) - (growth / 2);
                const headX = segX - (growth / 2);
                const headSize = baseSize + growth;
                const bezelColor = '#DCDCDC';
                const shadowColor = '#888888';
                const highlightColor = '#FFFFFF';
                ctx.fillStyle = bezelColor;
                ctx.fillRect(headX, headY, headSize, headSize);
                ctx.fillStyle = highlightColor;
                ctx.fillRect(headX, headY, headSize, 1);
                ctx.fillRect(headX, headY, 1, headSize);
                ctx.fillStyle = shadowColor;
                ctx.fillRect(headX, headY + headSize - 1, headSize, 1);
                ctx.fillRect(headX + headSize - 1, headY, 1, headSize);
                const screenX = headX + 3;
                const screenY = headY + 3;
                const screenSize = headSize - 6;
                const skyColor = '#4595E7';
                const hillColor = '#58B435';
                const cloudColor = '#FFFFFF';
                ctx.fillStyle = skyColor;
                ctx.fillRect(screenX, screenY, screenSize, screenSize);
                ctx.fillStyle = hillColor;
                ctx.beginPath();
                ctx.moveTo(screenX, screenY + screenSize * 0.5);
                ctx.quadraticCurveTo(screenX + screenSize / 2, screenY + screenSize * 0.4, screenX + screenSize, screenY + screenSize * 0.6);
                ctx.lineTo(screenX + screenSize, screenY + screenSize);
                ctx.lineTo(screenX, screenY + screenSize);
                ctx.closePath();
                ctx.fill();
                ctx.fillStyle = cloudColor;
                ctx.fillRect(screenX + screenSize * 0.55, screenY + screenSize * 0.15, screenSize * 0.3, screenSize * 0.1);
                ctx.fillRect(screenX + screenSize * 0.2, screenY + screenSize * 0.25, screenSize * 0.35, screenSize * 0.1);
            } else {
                const backColor = '#FBC02D';
                const frontColor = '#FFF176';
                const handleColor = '#64B5F6';
                const size = currentGridSize;
                ctx.fillStyle = backColor;
                ctx.beginPath();
                ctx.rect(segX + 1, segY + size * 0.2, size - 2, size * 0.8 -1);
                ctx.rect(segX + 1, segY + size * 0.1, size * 0.4, size * 0.2);
                ctx.fill();
                ctx.fillStyle = frontColor;
                ctx.fillRect(segX + 1, segY + size * 0.3, size - 2, size * 0.7 - 1);
                ctx.fillStyle = handleColor;
                const handleY = segY + size * 0.55;
                const handleHeight = size * 0.4;
                const legWidth = size * 0.2;
                ctx.fillRect(segX + size * 0.15, handleY, legWidth, handleHeight);
                ctx.fillRect(segX + size - size * 0.15 - legWidth, handleY, legWidth, handleHeight);
                ctx.fillRect(segX + size * 0.15, handleY + handleHeight - legWidth, size - (size * 0.15 * 2), legWidth);
            }
       } else if (skinKey === 'galaxy') {
           // Lógica de desenho para a skin Galáxia
           if(isHead){
               ctx.fillStyle = skinOptions.headColor;
           } else {
               ctx.fillStyle = skinOptions.colors[(i-1) % skinOptions.colors.length];
           }
           ctx.fillRect(segX, segY, currentGridSize - 2, currentGridSize - 2);
           
           // Efeito especial de "estrela" piscando
           ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
           ctx.fillRect(segX + Math.random() * (currentGridSize - 2), segY + Math.random() * (currentGridSize - 2), 1, 1);

       } else if (skinKey === 'camo') {
           // Lógica de desenho para a skin Camuflada
           if(isHead){
               ctx.fillStyle = skinOptions.headColor;
           } else {
               ctx.fillStyle = skinOptions.colors[(i-1) % skinOptions.colors.length];
           }
           ctx.fillRect(segX, segY, currentGridSize - 2, currentGridSize - 2);
           // (Você pode adicionar efeitos especiais para a Camu aqui)

       } else if (skinKey === 'christmas') {
    const isPreview = ctx.canvas.id.includes('Preview');
    const currentGridSize = isPreview ? 20 : gridSize;
    const segX = segment.x * currentGridSize + (isPreview ? 10 : 0);
    const segY = segment.y * currentGridSize;

    const centerX = segX + currentGridSize / 2;
    const centerY = segY + currentGridSize / 2;
    const radius = (currentGridSize / 2) + 1;

    // Efeito de brilho para a bola de neve
    ctx.shadowColor = skinOptions.glowColor;
    ctx.shadowBlur = 8;

    // --- DESENHA A BASE DE BOLA DE NEVE ---
    ctx.fillStyle = skinOptions.shadowColor;
    ctx.beginPath();
    ctx.arc(centerX, centerY + 1, radius - 1.5, 0, 2 * Math.PI);
    ctx.fill();
    ctx.fillStyle = skinOptions.bodyColor;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius - 1.5, 0, 2 * Math.PI);
    ctx.fill();

    // Contorno
    ctx.strokeStyle = skinOptions.outlineColor;
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.arc(centerX, centerY, radius - 1.5, 0, 2 * Math.PI);
    ctx.stroke();

    // Reseta o brilho para não afetar os fios e luzes
    ctx.shadowColor = 'transparent';
    ctx.shadowBlur = 0;

    if (isHead) {
        // --- DESENHA O ROSTO DO BONECO DE NEVE ---
        ctx.save();
        ctx.translate(centerX, centerY);
        let rotation = (dx === 1) ? Math.PI / 2 : (dx === -1) ? -Math.PI / 2 : (dy === 1) ? Math.PI : 0;
        ctx.rotate(rotation);

        ctx.fillStyle = skinOptions.eyeColor;
        const eyeRadius = currentGridSize / 12;
        ctx.beginPath();
        ctx.arc(-radius / 2.5, -radius / 2.5, eyeRadius, 0, 2 * Math.PI);
        ctx.arc(radius / 2.5, -radius / 2.5, eyeRadius, 0, 2 * Math.PI);
        ctx.fill();

        const mouthDotRadius = currentGridSize / 20;
        for (let j = 0; j < 5; j++) {
            const angle = Math.PI * 0.6 + (j * Math.PI * 0.2) / 4;
            const mouthX = Math.cos(angle) * radius * 0.6;
            const mouthY = Math.sin(angle) * radius * 0.6;
            ctx.beginPath();
            ctx.arc(mouthX, mouthY, mouthDotRadius, 0, 2 * Math.PI);
            ctx.fill();
        }

        ctx.fillStyle = skinOptions.noseColor;
        ctx.beginPath();
        ctx.moveTo(0, -eyeRadius);
        ctx.lineTo(0, eyeRadius);
        ctx.lineTo(radius * 0.7, 0);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
     } else {
        // --- LÓGICA COMBINADA PARA O CORPO (COM A CORREÇÃO) ---
        const prevSegment = snake[i - 1];
  
        // Verifica se a distância entre os segmentos é maior que 1,
        // o que indica um teleporte (wrap-around). Se for, pula o desenho do fio.
        const distanceX = Math.abs(segment.x - prevSegment.x);
        const distanceY = Math.abs(segment.y - prevSegment.y);
        if (distanceX > 1 || distanceY > 1) {
            continue; // Pula para o próximo segmento do loop, não desenhando o fio
        }
     
        const prevSegX = prevSegment.x * currentGridSize + (isPreview ? 10 : 0);
        const prevSegY = prevSegment.y * currentGridSize;
        const prevCenterX = prevSegX + currentGridSize / 2;
        const prevCenterY = prevSegY + currentGridSize / 2;

        const segDx = segment.x - prevSegment.x;
        const segDy = segment.y - prevSegment.y;

        // Fio reto de conexão central
        ctx.strokeStyle = skinOptions.wireColor;
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.moveTo(prevCenterX, prevCenterY);
        ctx.lineTo(centerX, centerY);
        ctx.stroke();

        // Fio que envolve a bola por fora
        let entryPoint, exitPoint, controlPoint, remainingArc;
        if (segDx === 1) { /* Direita */ entryPoint = { x: centerX - radius, y: centerY }; exitPoint = { x: prevCenterX + radius, y: prevCenterY }; controlPoint = { x: (centerX + prevCenterX) / 2, y: centerY + radius / 1.5 }; remainingArc = { start: Math.PI / 2, end: -Math.PI / 2 };
        } else if (segDx === -1) { /* Esquerda */ entryPoint = { x: centerX + radius, y: centerY }; exitPoint = { x: prevCenterX - radius, y: prevCenterY }; controlPoint = { x: (centerX + prevCenterX) / 2, y: centerY - radius / 1.5 }; remainingArc = { start: -Math.PI / 2, end: Math.PI / 2 };
        } else if (segDy === 1) { /* Baixo */ entryPoint = { x: centerX, y: centerY - radius }; exitPoint = { x: prevCenterX, y: prevCenterY + radius }; controlPoint = { x: centerX - radius / 1.5, y: (centerY + prevCenterY) / 2 }; remainingArc = { start: 0, end: Math.PI };
        } else { /* Cima */ entryPoint = { x: centerX, y: centerY + radius }; exitPoint = { x: prevCenterX, y: prevCenterY - radius }; controlPoint = { x: centerX + radius / 1.5, y: (centerY + prevCenterY) / 2 }; remainingArc = { start: Math.PI, end: 0 };
        }

        ctx.strokeStyle = skinOptions.wireColor;
        ctx.lineWidth = 2.5;
        ctx.beginPath();
        ctx.moveTo(exitPoint.x, exitPoint.y);
        ctx.quadraticCurveTo(controlPoint.x, controlPoint.y, entryPoint.x, entryPoint.y);
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius - 1.5, remainingArc.start, remainingArc.end, segDx === -1 || segDy === 0);
        ctx.stroke();

        // PISCA-PISCAS MULTICOLORIDOS COM BRILHO INDIVIDUAL
        const lightCount = 6;
        const lightRadius = currentGridSize / 11;
        const seededRandom = (seed) => { let x = Math.sin(seed) * 10000; return x - Math.floor(x); };

        for (let j = 0; j < lightCount; j++) {
            const blinkSeed = j + segment.x - segment.y * 2;
            const isOn = (Math.floor(Date.now() / 400) + blinkSeed) % 2 === 0;

            const angleSeed = j + segment.x;
            const angle = remainingArc.start + seededRandom(angleSeed) * (remainingArc.end - remainingArc.start);
            const lightX = centerX + Math.cos(angle) * (radius - 1.5);
            const lightY = centerY + Math.sin(angle) * (radius - 1.5);
            
            let lightColor;
            if (isOn) {
                const colorSeed = j + segment.y;
                const colorIndex = Math.floor(seededRandom(colorSeed) * skinOptions.lightColors.length);
                lightColor = skinOptions.lightColors[colorIndex];
                
                // LÓGICA DO BRILHO PARA CADA LUZ
                ctx.shadowColor = lightColor;
                ctx.shadowBlur = 10;
            } else {
                lightColor = skinOptions.lightOffColor;
            }
            
            ctx.fillStyle = lightColor;
            ctx.beginPath();
            ctx.arc(lightX, lightY, lightRadius, 0, 2 * Math.PI);
            ctx.fill();

            // Limpa o brilho para a próxima luz não ser afetada
            ctx.shadowColor = 'transparent';
            ctx.shadowBlur = 0;
        }
    }
       }
    }

    // Código executado após o laço para desenhar partes complexas (conectores, cabeças)
    if (skinKey === 'halloween') {
        if (snake.length > 1) {
            for (let i = 1; i < snake.length; i++) {
                const curr = snake[i], prev = snake[i - 1]; const lineS = 2;
                let cX, cY, cW, cH, isH;
                if (curr.x === prev.x) { // Conector Vertical
                    isH = false; cW = currentGridSize - 2; cH = 2;
                    cX = curr.x * currentGridSize + offsetX + 1;
                    cY = (curr.y > prev.y) ? curr.y * currentGridSize - 1 : prev.y * currentGridSize - 1;
                } else { // Conector Horizontal
                    isH = true; cW = 2; cH = currentGridSize - 2;
                    cY = curr.y * currentGridSize + 1;
                    cX = (curr.x > prev.x) ? curr.x * currentGridSize - 1 : prev.x * currentGridSize - 1;
                }
                const halfS = isH ? cH / 2 : cW / 2;
                if (isH) {
                    ctx.fillStyle = skinOptions.bodyColor1; ctx.fillRect(cX, cY, cW, halfS - lineS / 2);
                    ctx.fillStyle = skinOptions.bodyColor2; ctx.fillRect(cX, cY + halfS + lineS / 2, cW, halfS - lineS / 2);
                    ctx.fillStyle = skinOptions.lineColor; ctx.fillRect(cX, cY + halfS - lineS / 2, cW, lineS);
                } else {
                    ctx.fillStyle = skinOptions.bodyColor1; ctx.fillRect(cX, cY, halfS - lineS / 2, cH);
                    ctx.fillStyle = skinOptions.bodyColor2; ctx.fillRect(cX + halfS + lineS / 2, cY, halfS - lineS / 2, cH);
                    ctx.fillStyle = skinOptions.lineColor; ctx.fillRect(cX + halfS - lineS / 2, cY, lineS, cH);
                }
            }
        }
        // Desenha a cabeça da abóbora por último
        const headX=snake[0].x*currentGridSize+offsetX, headY=snake[0].y*currentGridSize;
        ctx.fillStyle=skinOptions.headColor;
        ctx.fillRect(headX,headY,currentGridSize,currentGridSize);
        ctx.save();
        ctx.translate(headX+currentGridSize/2,headY+currentGridSize/2);
        let r=0; if(dx===1){r=Math.PI/2;} else if(dx===-1){r=-Math.PI/2;} else if(dy===1){r=Math.PI;}
        ctx.rotate(r);
        const hG=currentGridSize/2;
        ctx.fillStyle='#000000';
        ctx.beginPath(); ctx.moveTo(-hG*0.6,-hG*0.6); ctx.lineTo(-hG*0.2,-hG*0.2); ctx.lineTo(-hG*0.6,-hG*0.2); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(hG*0.6,-hG*0.6); ctx.lineTo(hG*0.2,-hG*0.2); ctx.lineTo(hG*0.6,-hG*0.2); ctx.closePath(); ctx.fill();
        ctx.beginPath(); ctx.moveTo(0,-hG*0.1); ctx.lineTo(-hG*0.2,hG*0.2); ctx.lineTo(hG*0.2,hG*0.2); ctx.closePath(); ctx.fill();
        const mY=hG*0.4;
        ctx.fillRect(-hG*0.8,mY,hG*1.6,hG*0.2); ctx.fillRect(-hG*0.5,mY-hG*0.2,hG*0.2,hG*0.2); ctx.fillRect(hG*0.3,mY-hG*0.2,hG*0.2,hG*0.2);
        ctx.restore();
    }
}
// Modifique sua função drawPvpBoards()
function drawPvpBoards() {
    // --- 1. DESENHA O SEU PRÓPRIO TABULEIRO (TELA LOCAL) ---
    pvpLocalCtx.fillStyle = '#11131e';
    pvpLocalCtx.fillRect(0, 0, pvpLocalCanvas.width, pvpLocalCanvas.height);
    
    drawSnakeOnCanvas(pvpLocalCtx, pvpLocalSnake, pvpLocalSkin, pvpLocalDirection);
    drawPvpFood(pvpLocalCtx, pvpLocalFood);
    pvpLocalCtx.fillStyle = '#8395a7';
    pvpLocalObstacles.forEach(obstacle => {
        pvpLocalCtx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize);
    });

    // Lógica para a TELA LOCAL: Se VOCÊ está sabotado, vê as duas comidas com a MESMA COR.
    if (isPoisonFoodActive && pvpLocalPoisonFood.x !== undefined) {
        pvpLocalCtx.fillStyle = '#fd79a8'; // Cor normal da comida
        pvpLocalCtx.fillRect(pvpLocalPoisonFood.x * gridSize, pvpLocalPoisonFood.y * gridSize, gridSize - 2, gridSize - 2);
    }

    // --- 2. DESENHA O TABULEIRO DO OPONENTE ---
    pvpOpponentCtx.fillStyle = '#11131e';
    pvpOpponentCtx.fillRect(0, 0, pvpOpponentCanvas.width, pvpOpponentCanvas.height);
    
    drawSnakeOnCanvas(pvpOpponentCtx, pvpOpponentSnake, pvpOpponentSkin, pvpOpponentDirection);

    // Lógica para a TELA DO OPONENTE: Verifica se ELE está sabotado.
    const opponentIsSabotaged = pvpOpponentPoisonFood && pvpOpponentPoisonFood.x !== undefined;

    if (opponentIsSabotaged) {
        // Se o oponente está sabotado, VOCÊ vê as comidas dele com cores diferentes.
        
        // A comida VERDADEIRA dele é desenhada com a cor normal.
        pvpOpponentCtx.fillStyle = '#fd79a8'; // Cor normal
        if (pvpOpponentFood.x !== undefined) {
            pvpOpponentCtx.fillRect(pvpOpponentFood.x * gridSize, pvpOpponentFood.y * gridSize, gridSize - 2, gridSize - 2);
        }
        
        // A comida FALSA dele é desenhada na cor VERDE.
        pvpOpponentCtx.fillStyle = '#2ecc71'; // Verde
        if (pvpOpponentPoisonFood.x !== undefined) {
            pvpOpponentCtx.fillRect(pvpOpponentPoisonFood.x * gridSize, pvpOpponentPoisonFood.y * gridSize, gridSize - 2, gridSize - 2);
        }
    } else {
        // Se o oponente não está sabotado, apenas desenha a comida normal dele.
        drawPvpFood(pvpOpponentCtx, pvpOpponentFood);
    }
}

function drawPvpFood(ctx, food) {
    if (food.x === undefined) return;
    ctx.fillStyle = '#fd79a8';
    ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);
}


// Adicione esta função ao seu script
function queuePvpDirection(newDx, newDy) {
    // Só funciona se a partida PvP estiver rolando
    if (!pvpGameRunning) return;
    if (controlsInverted) {
        newDx *= -1;
        newDy *= -1;
    }
    // Impede que a cobra ande para trás
    let lastDirection = pvpLocalDirection;
    if (pvpLocalInputQueue.length > 0) {
        lastDirection = pvpLocalInputQueue[pvpLocalInputQueue.length - 1];
    }
    
    // Se a cobra estiver parada, permite o primeiro movimento
    if (lastDirection.dx === 0 && lastDirection.dy === 0) {
        pvpLocalInputQueue.push({ dx: newDx, dy: newDy });
        return;
    }

    // Impede o movimento contrário direto
    if ((newDx !== 0 && newDx === -lastDirection.dx) || (newDy !== 0 && newDy === -lastDirection.dy)) {
        return;
    }

    // Limita a fila para no máximo 2 movimentos para evitar "engasgos"
    if (pvpLocalInputQueue.length < 2) {
        pvpLocalInputQueue.push({ dx: newDx, dy: newDy });
    }
}
function showPvpResultModal(title, message, coinMessage, errorDetails = null) {
    document.getElementById('pvpResultTitle').textContent = title;

    let finalMessage = message;
    // Se houver detalhes do erro, anexa à mensagem principal
    if (errorDetails && errorDetails.message) {
        finalMessage += `\n\nDetalhe do erro: ${errorDetails.message}`;
    }

    document.getElementById('pvpResultMessage').textContent = finalMessage;
    document.getElementById('pvpResultCoins').textContent = coinMessage;
    document.getElementById('pvpResultModal').style.display = 'flex';
}

function closePvpResultModal() {
    document.getElementById('pvpResultModal').style.display = 'none';
    // Apenas depois de fechar o resultado, o painel é resetado para um novo jogo.
    if (localPlayerKey === 'player1' && activeRoomId) {
        db.collection('gameRooms').doc(activeRoomId).delete().catch(e => {});
    }
    resetPvpPanel();
}
async function endPvpGame(reason, outcome = {}) {
    // 1. O "Cadeado de Ferro": Impede que a função seja executada múltiplas vezes no mesmo cliente.
    if (isGameEnding) {
        console.log("endPvpGame bloqueada: processo de encerramento já em andamento.");
        return; 
    }
    isGameEnding = true; // Tranca o cadeado.

    console.log("endPvpGame chamado com:", { reason, outcome });

    // 2. Limpeza Imediata: Para todos os processos do jogo.
    isCountdownActive = false;
    pvpGameRunning = false;
    clearInterval(pvpGameLoopInterval);
    clearInterval(pvpGameTimerInterval);
    if (pvpCountdownInterval) clearInterval(pvpCountdownInterval);
    if (activeRoomListener) activeRoomListener(); // Desativa o "vigia" da sala.
    pvpCountdownInterval = null;
    activeRoomListener = null;

    const coinChange = pvpRewards[pvpDifficulty] || 25;
    let title, message, coinMessage = '';

    try {
        // 3. Lógica Principal: Executada por ambos os jogadores.
        if (outcome.winnerId && outcome.loserId && outcome.localPlayerId) {
            
            // 4. AÇÃO RESTRITA AO PLAYER 1: Apenas o "juiz" executa a transação de moedas.
            if (localPlayerKey === 'player1') {
                const winnerRef = db.collection('users').doc(outcome.winnerId);
                const loserRef = db.collection('users').doc(outcome.loserId);
                
                await db.runTransaction(async (transaction) => {
                    const winnerDoc = await transaction.get(winnerRef);
                    const loserDoc = await transaction.get(loserRef);
                    if (!winnerDoc.exists || !loserDoc.exists) throw new Error("Um dos jogadores não foi encontrado no banco de dados.");
                    
                    const winnerData = winnerDoc.data();
                    const loserData = loserDoc.data();
                    const newWinnerCoins = (winnerData.snakeCoins || 0) + coinChange;
                    const newLoserCoins = Math.max(0, (loserData.snakeCoins || 0) - coinChange);
                    
                    transaction.update(winnerRef, { snakeCoins: newWinnerCoins });
                    transaction.update(loserRef, { snakeCoins: newLoserCoins });
                });
            }

            // 5. Lógica da Interface: Executada por ambos para mostrar o resultado correto.
            if (outcome.localPlayerId === outcome.winnerId) {
                title = "🎉 Você Venceu! 🎉";
                message = reason;
                coinMessage = `+${coinChange} 🪙`;
            } else {
                title = "😕 Fim de Jogo 😕";
                message = reason;
                coinMessage = `-${coinChange} 🪙`;
            }

        } else if (outcome.isDraw) {
            title = "Empate!";
            message = "A partida terminou em empate.";
            coinMessage = `±0 🪙`;
        } else {
            // Caso a função seja chamada sem um resultado (ex: sala deletada), apenas mostra a razão.
            title = "Fim de Jogo";
            message = reason;
        }
        
        showPvpResultModal(title, message, coinMessage);

    } catch (error) {
        // Bloco de erro com diagnóstico na tela (para o caso de algo ainda falhar).
        console.error("Erro detalhado ao processar recompensas:", error);
        showPvpResultModal(
            "Ocorreu um Erro", 
            `Fim de Jogo! ${reason}.`, 
            "Não foi possível atualizar as moedas.",
            error
        );
    }
}
function resetPvpPanel() {
    // --- Redefine os Elementos da Interface ---
    // Garante que apenas o botão de procurar partida esteja visível
    document.getElementById('searchMatchBtn').style.display = 'block';
    document.getElementById('cancelSearchBtn').style.display = 'none';

    // Restaura o overlay do oponente e o texto de espera
    document.querySelector('.opponent-overlay').style.visibility = 'visible';
    document.getElementById('waitTimeDisplay').textContent = "Tempo de Espera: --";

    // Esconde o timer e o placar da partida anterior
    document.getElementById('pvpGameTimer').style.visibility = 'hidden';
    document.getElementById('localScoreDisplay').textContent = 'Sua Pontuação: 0';
    document.getElementById('opponentScoreDisplay').textContent = 'Oponente: 0';

    // Limpa completamente os desenhos dos canvases
    const pvpLocalCanvas = document.getElementById('localPlayerPvPCanvas');
    const pvpLocalCtx = pvpLocalCanvas.getContext('2d');
    pvpLocalCtx.clearRect(0, 0, pvpLocalCanvas.width, pvpLocalCanvas.height);

    const pvpOpponentCanvas = document.getElementById('opponentCanvas');
    const pvpOpponentCtx = pvpOpponentCanvas.getContext('2d');
    pvpOpponentCtx.clearRect(0, 0, pvpOpponentCanvas.width, pvpOpponentCanvas.height);
    const feedbackEl = document.getElementById('sabotage-feedback');
    if (feedbackEl) {
        feedbackEl.classList.remove('show'); // Interrompe qualquer animação em andamento
        feedbackEl.textContent = '';         // Remove o emoji do elemento
    }

    // --- Redefine as Variáveis de Estado do Jogo ---
    // Limpa as informações da partida anterior para não afetar a próxima
    activeRoomId = null;
    localPlayerKey = null;
    pvpLocalSnake = [];
    pvpOpponentSnake = [];
    pvpLocalScore = 0;
    pvpOpponentScore = 0;
    pvpLocalDirection = { dx: 0, dy: 0 };
    pvpLocalInputQueue = [];
    isSearching = false;

    // Limpa qualquer estado de sabotagem ativo
    controlsInverted = false;
    isAccelerated = false;
    pvpLocalObstacles = [];
    localPlayerSabotages = [];
    document.getElementById('sabotageControls').innerHTML = '';

    // ATUALIZAÇÃO: "DESTRAVA" O CADEADO NO FINAL DO PROCESSO DE RESET
    isGameEnding = false; 
}
function showCustomAlert(title, message) {
    document.getElementById('customAlertTitle').textContent = title;
    document.getElementById('customAlertMessage').textContent = message;
    document.getElementById('customAlertModal').style.display = 'flex';
}

function closeCustomAlert() {
    document.getElementById('customAlertModal').style.display = 'none';
}
function processPvpInput() {
    // Se o jogo não estiver rodando ou não houver comandos na fila, não faz nada.
    if (!pvpGameRunning || pvpLocalInputQueue.length === 0) {
        return;
    }

    // Pega o próximo movimento da fila.
    const nextMove = pvpLocalInputQueue.shift();
    
    // Se a cobra estiver parada, qualquer primeiro movimento é válido.
    // Isso ignora a checagem de "anti-reversão" para o movimento inicial.
    if (pvpLocalDirection.dx === 0 && pvpLocalDirection.dy === 0) {
        pvpLocalDirection = { dx: nextMove.dx, dy: nextMove.dy };
        return; // Sai da função após registrar o primeiro movimento.
    }   

    // Checagem "anti-reversão" (agora só para cobras já em movimento)
    if ((nextMove.dx !== 0 && nextMove.dx === -pvpLocalDirection.dx) || (nextMove.dy !== 0 && nextMove.dy === -pvpLocalDirection.dy)) {
        // Se o movimento inválido foi bloqueado, tenta processar o próximo da fila
        if (pvpLocalInputQueue.length > 0) {
            processPvpInput();
        }
        return;
    }

    // Se o movimento for válido, atualiza a direção da cobra.
    pvpLocalDirection = { dx: nextMove.dx, dy: nextMove.dy };
}
</script> 
</body>
</html>