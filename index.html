<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Jogo da Cobrinha</title>
<link rel="icon" type="image/png" href="https://i.imgur.com/Y0hwK0g.png">
<style>
        /* --- GERAL & RESET --- */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background: linear-gradient(135deg, #1a1d2d 0%, #11131e 100%);
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
            touch-action: none;
            user-select: none;
            overflow: hidden;
        }

        /* --- CONTAINER PRINCIPAL --- */
        .game-container {
            text-align: center;
            background: rgba(255, 255, 255, 0.05);
            backdrop-filter: blur(12px);
            border-radius: 24px;
            padding: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
            width: 95%;
            max-width: 400px;
            max-height: 95vh;
            overflow-y: auto;
        }
        /* Custom scrollbar for webkit browsers */
        .game-container::-webkit-scrollbar {
            width: 5px;
        }
        .game-container::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        .game-container::-webkit-scrollbar-track {
            background: transparent;
        }


        /* --- TIPOGRAFIA --- */
        .main-title {
            font-size: 2.5em;
            color: #ffffff;
            font-weight: 700;
            margin-bottom: 25px;
        }

        .login-logo {
            width: 120px; /* Ajuste a largura conforme necessário */
            height: auto;
            margin-bottom: 15px;
        }
        
        .leaderboard-logo {
            width: 50px; /* Ajuste o tamanho conforme preferir */
            height: auto;
            margin-bottom: 10px;
        }

        h1, h2, h3, h4 {
            color: #ffffff;
            margin-bottom: 15px;
            font-weight: 600;
        }

        p, label {
            color: #d1d1d1;
            font-size: 14px;
        }

        a {
            color: #4a72ff;
            text-decoration: none;
            font-weight: 600;
        }

        a:hover {
            text-decoration: underline;
        }
        
        .selection-title {
            color: #ffffff;
            margin-top: 15px;
            margin-bottom: 10px;
            font-size: 14px;
            font-weight: 500;
            width: 100%;
            text-align: center;
        }

        /* --- BOTÕES --- */
        .btn {
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            cursor: pointer;
            padding: 12px 24px;
            transition: all 0.2s ease;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            font-weight: 600;
        }

        .btn-primary {
            background-color: #4a72ff;
            box-shadow: 0 4px 15px rgba(74, 114, 255, 0.2);
        }

        .btn-primary:hover {
            background-color: #5a82ff;
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(74, 114, 255, 0.3);
        }

        .btn-primary:active {
            transform: scale(0.98);
        }

        .btn-primary:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        .btn-secondary {
            background-color: rgba(255, 255, 255, 0.1);
        }
        .btn-secondary:hover {
            background-color: rgba(255, 255, 255, 0.2);
        }

        .btn-danger {
            background: #d63031;
        }
        .btn-danger:hover {
            background: #e17055;
        }

        .start-btn {
            width: 100%;
            margin-bottom: 20px;
        }

        .restart-btn {
            margin-top: 15px;
        }

        /* --- FORMULÁRIOS E INPUTS --- */
        .name-input, #skinSelector, #supportType, #supportMessage {
            background: rgba(0, 0, 0, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 12px;
            color: white;
            font-size: 16px;
            text-align: center;
            margin-bottom: 10px;
            width: 100%;
            transition: border-color 0.2s, background-color 0.2s;
        }
        #skinSelector, #supportType {
            text-align: left; /* Alinha o texto do select à esquerda */
            -webkit-appearance: none; /* Remove a aparência padrão no Chrome/Safari */
            -moz-appearance: none; /* Remove a aparência padrão no Firefox */
            appearance: none; /* Remove a aparência padrão */
            background-image: url('data:image/svg+xml;charset=US-ASCII,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%22292.4%22%20height%3D%22292.4%22%3E%3Cpath%20fill%3D%22%23ffffff%22%20d%3D%22M287%2069.4a17.6%2017.6%200%200%200-13-5.4H18.4c-5%200-9.3%201.8-12.9%205.4A17.6%2017.6%200%200%200%200%2082.2c0%205%201.8%209.3%205.4%2012.9l128%20127.9c3.6%203.6%207.8%205.4%2012.8%205.4s9.2-1.8%2012.8-5.4L287%2095c3.5-3.5%205.4-7.8%205.4-12.8%200-5-1.9-9.2-5.5-12.8z%22/%3E%3C/svg%3E');
            background-repeat: no-repeat;
            background-position: right 12px top 50%;
            background-size: .65em auto;
            padding-right: 30px; /* Espaço para a seta */
        }
        #skinSelector option, #supportType option {
            background-color: #1a1d2d;
            color: white;
        }
        
        .name-input::placeholder {
            color: rgba(255, 255, 255, 0.5);
            text-transform: none;
        }

        .name-input:focus, #skinSelector:focus, #supportType:focus, #supportMessage:focus {
            outline: none;
            border-color: #4a72ff;
            background-color: rgba(0, 0, 0, 0.3);
        }


        /* --- TELA PRINCIPAL DO JOGO --- */
        #mainGame { display: none; position: relative; }

        canvas {
            border: 2px solid rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            background: #11131e;
            width: 100%;
            max-width: 360px;
            height: auto;
            margin: 15px 0;
        }

        .player-score-container {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
            margin-top: 15px;
            padding: 0 5px;
            font-size: 16px;
            color: white;
        }

        .current-difficulty {
            color: white;
            font-size: 14px;
            margin-top: 10px;
            opacity: 0.8;
        }

        /* --- LEADERBOARD --- */
        .leaderboard {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 10px;
            color: white;
            position: relative; /* Adicionado para posicionamento absoluto do personal-record */
        }
        .leaderboard h3 {
            margin: 0 0 10px 0;
            font-size: 16px;
        }
        .leaderboard-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin: 5px 0;
            padding: 8px;
            border-radius: 8px;
            background: rgba(0, 0, 0, 0.1);
            font-size: 14px;
            transition: background-color 0.3s;
        }
        .leaderboard-difficulty {
            font-size: 12px;
            opacity: 0.8;
            margin-left: 8px;
        }

        /* Estilo para o recorde pessoal */
        .personal-record {
            text-align: left;
            color: #ffffff; /* Cor branca para o texto */
            font-size: 11px;
            font-weight: 500;
            margin-bottom: 10px; /* Espaçamento abaixo */
            display: flex;
            justify-content: flex-start;
            align-items: center;
            gap: 3px;
            /* Posicionamento para ficar à esquerda do TOP 3 */
            position: absolute;
            top: 100px; /* Ajuste conforme a altura da logo e do h3 */
            left: 20px; /* Ajuste para espaçamento da borda */
            transform: translateY(-50%); /* Centraliza verticalmente com o TOP 3 se necessário */
            white-space: nowrap; /* Impede quebra de linha */
            background: transparent; /* Sem fundo */
            padding: 0; /* Sem padding */
        }
        .personal-record strong {
            color: #ffffff; /* Cor branca para o valor do recorde */
            font-weight: 500; /* Mantém o mesmo peso da fonte do texto normal */
        }
        .leaderboard-logo + .personal-record { /* Ajuste de posição quando a logo está presente */
            top: 105px; /* Ajuste para ficar abaixo da logo */
        }
        .leaderboard h3 {
             /* Ajusta margem para dar espaço ao recorde pessoal */
            margin-top: 5px; 
            text-align: center;
        }


        /* --- SELEÇÃO DE DIFICULDADE E MAPA --- */
        .difficulty-selection, .map-selection {
            display: flex;
            justify-content: center;
            gap: 8px;
        }
        
        .difficulty-selection {
            flex-wrap: nowrap;
            overflow-x: auto;
            padding-bottom: 5px;
            -ms-overflow-style: none;
            scrollbar-width: none;
        }
        .difficulty-selection::-webkit-scrollbar {
            display: none;
        }
        
        .map-selection {
             flex-wrap: wrap;
        }

        .difficulty-btn {
            background: rgba(255, 255, 255, 0.1);
            color: white;
            border: 1px solid transparent;
            border-radius: 10px;
            font-size: 14px;
            cursor: pointer;
            padding: 5px;
            transition: all 0.2s ease;
            flex-shrink: 0; 
            width: 68px;
            height: 68px;
            line-height: 1.3;
            text-align: center;
        }

        .difficulty-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        .difficulty-btn.selected {
            background: #4a72ff;
            border-color: transparent;
            color: white;
            font-weight: 600;
            box-shadow: 0 0 15px rgba(74, 114, 255, 0.3);
        }
        
        .difficulty-info {
            color: #d1d1d1;
            font-size: 12px;
            margin-top: 8px;
            width: 100%;
            text-align: center;
            min-height: 28px;
        }

        /* --- CONTROLES --- */
        .controls {
            margin-top: 15px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(2, 1fr);
            gap: 10px;
            width: 200px;
            height: 120px;
            margin-left: auto;
            margin-right: auto;
        }

        .control-btn {
            background: rgba(255, 255, 255, 0.15);
            color: white;
            border: none;
            border-radius: 15px;
            font-size: 24px;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        .control-btn:active {
            transform: scale(0.95);
            background: rgba(255, 255, 255, 0.25);
        }
        .up { grid-column: 2; grid-row: 1; }
        .left { grid-column: 1; grid-row: 2; }
        .right { grid-column: 3; grid-row: 2; }
        .down { grid-column: 2; grid-row: 2; }

        .pause-btn, .quit-game-btn {
            margin-top: 15px;
            padding: 10px 20px;
            font-size: 14px;
        }
        #quitGameBtn { margin-left: 10px; }


        /* --- MODAIS E TELAS DE SOBREPOSIÇÃO (GAME OVER, PARABÉNS, INBOX) --- */
        .game-over, #congratulationsScreen, .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            background: rgba(26, 29, 45, 0.9);
            backdrop-filter: blur(5px);
            z-index: 2000;
            color: white;
            padding: 20px;
        }
        .game-over h2, #congratulationsScreen h2, .modal-content h2 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }
        #congratulationsScreen h2 {
            text-shadow: 0 0 15px #FFD700;
            animation: congrats-pulse 1s infinite alternate;
        }
        @keyframes congrats-pulse {
            to { transform: scale(1.05); text-shadow: 0 0 25px #FFD700; }
        }

        /* --- CAIXA DE ENTRADA --- */
        .modal-content {
            background: #1a1d2d;
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            width: 100%;
            max-width: 380px;
            max-height: 80vh;
            display: flex;
            flex-direction: column;
        }
        .inbox-list {
            overflow-y: auto;
            flex-grow: 1;
        }
        .inbox-message {
            background: rgba(255, 255, 255, 0.05);
            padding: 15px;
            margin-bottom: 10px;
            border-radius: 8px;
            text-align: left;
        }
        .inbox-message-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .inbox-message-header span { font-size: 12px; opacity: 0.7; }
        .inbox-message p { font-size: 14px; color: #fff; white-space: pre-wrap; }
        .inbox-message button { font-size: 10px; padding: 4px 8px; }


        /* --- FOGOS DE ARTIFÍCIO --- */
        .firework {
            position: absolute;
            width: 4px;
            height: 4px;
            border-radius: 50%;
            opacity: 1;
            animation: firework-explode 1.2s forwards;
        }
        @keyframes firework-explode {
            100% { transform: scale(30); opacity: 0; }
        }


        /* --- CONFIGURAÇÕES E ABAS --- */
        .settings-tabs {
            display: flex;
            margin-bottom: 20px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            overflow-x: auto;
            -webkit-overflow-scrolling: touch;
        }
        .settings-tabs::-webkit-scrollbar { display: none; }

        .tab-button {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            transition: color 0.3s, border-bottom 0.3s;
            border-bottom: 3px solid transparent;
            white-space: nowrap;
        }
        .tab-button:hover { color: white; }
        .tab-button.selected {
            color: white;
            border-bottom: 3px solid #4a72ff;
            font-weight: 600;
        }

        .settings-tab-content { padding-top: 10px; text-align: left; }
        .settings-tab-content h4 { margin-top: 20px; margin-bottom: 10px; font-size: 16px; color: white; }
        .settings-tab-content label { display: block; margin-bottom: 8px; font-weight: 500; }
        .settings-tab-content input[type="color"], .settings-tab-content input[type="range"], .settings-tab-content select {
            width: 100%;
            padding: 5px;
            margin-bottom: 10px;
        }
        
        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .setting-item label {
            margin-bottom: 0;
        }
        .setting-item input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
        }


        /* --- SELETOR DE IDIOMA --- */
        .language-selector {
            position: absolute;
            top: 28px;
            right: 90px;
            z-index: 1000;
        }
        .language-selector-button {
            background: rgba(255, 255, 255, 0.1);
            border: 0px solid rgba(255, 255, 255, 0.2);
            border-radius: 0px;
            padding: 0px;
            cursor: pointer;
            display: flex;
            align-items: center;
            width: 30px;
            height: 20px;
        }
        .language-selector-button img { width: 100%; border-radius: 4px; }
        .language-selector-dropdown {
            position: absolute;
            top: 110%;
            left: 0;
            background: #2a2d3d;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4);
            z-index: 100;
            min-width: 120px;
            display: none;
            border: 1px solid rgba(255,255,255,0.1);
            overflow: hidden;
        }
        .language-selector-dropdown.show { display: block; }
        .language-selector-option {
            padding: 8px 12px;
            color: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        .language-selector-option:hover { background: #4a72ff; }
        .language-selector-option img { width: 24px; height: 16px; border-radius: 2px; }

        /* --- BOTÕES DE AÇÃO NO TOPO DA TELA DE JOGO --- */
        #logoutBtn, #settingsBtn, #inboxBtn {
            position: absolute;
            top: 17px;
            z-index: 1000;
            background: none;
            border: none;
            font-size: 25px;
            cursor: pointer;
            color: white;
            opacity: 0.8;
            transition: opacity 0.2s;
        }
        #logoutBtn:hover, #settingsBtn:hover, #inboxBtn:hover { opacity: 1; }
        #logoutBtn { left: 18px; font-size: 22px; }
        #inboxBtn { right: 52px; }
        #settingsBtn { right: 20px; }

        /* Notificação da caixa de entrada */
        #inboxNotification {
            position: absolute;
            top: -5px;
            right: -8px;
            background-color: #d63031;
            color: white;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            font-size: 10px;
            display: none;
            justify-content: center;
            align-items: center;
            font-weight: bold;
        }


        /* Estilo para o display de moedas totais */
        .total-coins-display {
            position: absolute;
            top: 50px; /* Ajuste conforme necessário para ficar abaixo dos botões */
            right: 20px;
            color: #FFD700; /* Cor dourada para as moedas */
            font-size: 0.7em;
            font-weight: bold;
            z-index: 999;
            background: rgba(0, 0, 0, 0.3);
            padding: 5px 10px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            align-items: center;
            gap: 5px;
        }
        #skinPreviewCanvas {
            display: block;
            margin: 15px auto; /* Adiciona espaço e centraliza */
            background: #11131e; /* Mesmo fundo do canvas principal */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }
        /* --- ANÚNCIO GLOBAL --- */
        #globalAnnouncement {
            display: none;
            background-color: #4a72ff;
            color: white;
            padding: 8px;
            font-size: 12px;
            text-align: center;
            border-radius: 8px;
            margin: 0 auto 10px auto;
            max-width: 95%;
        }

        /* --- ESTILOS DO PAINEL DE ADMIN --- */
        #adminPanel {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(26, 29, 45, 0.95);
            backdrop-filter: blur(10px);
            z-index: 2500;
            color: white;
            display: none;
            flex-direction: column;
            padding: 20px;
        }

        .admin-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .admin-header h2 {
            margin: 0;
        }

        .admin-content {
            flex-grow: 1;
            overflow-y: auto;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 15px;
        }

        /* Custom scrollbar for admin panel content */
        .admin-content::-webkit-scrollbar {
            width: 5px;
        }
        .admin-content::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
        }
        .admin-content::-webkit-scrollbar-track {
            background: transparent;
        }

        .admin-tabs {
            display: flex;
            margin-bottom: 15px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            flex-wrap: wrap; /* Permite que as abas quebrem a linha em telas pequenas */
        }

        .admin-tab-button {
            background: none;
            border: none;
            color: rgba(255, 255, 255, 0.6);
            padding: 10px 15px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 500;
            border-bottom: 3px solid transparent;
            transition: all 0.3s;
        }
        .admin-tab-button:hover { color: white; }
        .admin-tab-button.selected {
            color: white;
            border-bottom-color: #e17055;
            font-weight: 600;
        }

        .admin-tab-content {
            display: none;
        }
        .admin-tab-content.active {
            display: block;
        }

        .stat-card {
            background: rgba(0,0,0,0.2);
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 10px;
            text-align: center;
        }
        .stat-card h4 {
            margin: 0 0 5px 0;
            font-size: 14px;
            color: #d1d1d1;
        }
        .stat-card p {
            font-size: 24px;
            font-weight: bold;
            color: white;
        }
        /* Card de análise */
        .analytics-card {
            text-align: left;
            padding: 20px;
        }
        .analytics-card h4 {
            text-align: center;
            font-size: 16px;
            margin-bottom: 15px;
        }
        .analytics-card p {
            font-size: 16px;
            font-weight: normal;
            display: flex;
            justify-content: space-between;
        }
        .analytics-card p strong {
            font-weight: 600;
            color: #e17055;
        }
        
        /* Gráfico de Barras */
        .bar-chart-container { margin-top: 20px; }
        .bar-chart-item {
            display: flex;
            align-items: center;
            margin-bottom: 8px;
            font-size: 12px;
        }
        .bar-chart-label { width: 80px; flex-shrink: 0; }
        .bar-chart-bar-bg {
            flex-grow: 1;
            background: rgba(0,0,0,0.3);
            border-radius: 4px;
            height: 20px;
            overflow: hidden;
        }
        .bar-chart-bar {
            background-color: #4a72ff;
            height: 100%;
            border-radius: 4px;
            transition: width 0.5s ease-out;
        }
        .bar-chart-value { margin-left: 10px; font-weight: bold; }


        .admin-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 12px;
        }
        .admin-table th, .admin-table td {
            padding: 8px;
            text-align: left;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        .admin-table th {
            color: #d1d1d1;
            font-weight: 600;
        }
        .admin-table td .btn {
            font-size: 10px;
            padding: 4px 8px;
        }

        .filter-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        /* Modal de Edição de Usuário */
        .edit-user-modal {
            position: fixed;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: rgba(0,0,0,0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 3000;
            padding: 20px;
        }
        .edit-user-modal-content {
            background: #1a1d2d;
            padding: 20px;
            border-radius: 15px;
            border: 1px solid rgba(255,255,255,0.1);
            width: 100%;
            max-width: 350px;
            text-align: left;
        }
        .edit-user-modal-content h3 {
            margin-top: 0;
            text-align: center;
        }
        .edit-user-modal-content label {
            margin-top: 10px;
        }
        .edit-user-modal-content .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
        }
        .edit-user-modal-content .btn {
            width: 100%;
        }

</style>
</head>
<body>
<div id="adminPanel">
    <div class="admin-header">
        <h2>Painel do Administrador</h2>
        <button class="btn btn-danger" onclick="closeAdminPanel()">Fechar</button>
    </div>
    <div class="admin-tabs">
        <button class="admin-tab-button selected" onclick="showAdminTab('dashboard')">Dashboard</button>
        <button class="admin-tab-button" onclick="showAdminTab('analytics')">Análises</button> <button class="admin-tab-button" onclick="showAdminTab('users')">Usuários</button>
        <button class="admin-tab-button" onclick="showAdminTab('leaderboard')">Leaderboard</button>
        <button class="admin-tab-button" onclick="showAdminTab('support')">Suporte</button>
        <button class="admin-tab-button" onclick="showAdminTab('announcements')">Anúncios</button>
        <button class="admin-tab-button" onclick="showAdminTab('collectiveActions')">Ações Coletivas</button> </div>
    <div class="admin-content">
        <div id="adminDashboardTab" class="admin-tab-content active">
            <h3>Visão Geral</h3>
            <div id="admin-stats-grid" style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 15px;">
                <div class="stat-card">
                    <h4>Total de Usuários</h4>
                    <p id="totalUsersStat">0</p>
                </div>
                <div class="stat-card">
                    <h4>Novos Usuários (24h)</h4>
                    <p id="newUsersStat">0</p>
                </div>
                <div class="stat-card">
                    <h4>Partidas Jogadas</h4>
                    <p id="totalScoresStat">0</p>
                </div>
                <div class="stat-card">
                    <h4>Tickets Abertos</h4>
                    <p id="openTicketsStat">0</p>
                </div>
            </div>
        </div>

        <div id="adminAnalyticsTab" class="admin-tab-content">
            <h3>Análises Detalhadas do Jogo</h3>
            
            <div class="analytics-card stat-card" style="margin-top: 15px;">
                <h4>Preferências Gerais</h4>
                <p>Skin Mais Usada: <strong id="mostUsedSkinStat">Calculando...</strong></p>
                <p>Mapa Mais Jogado: <strong id="mostPlayedMapStat">Calculando...</strong></p>
                <p>Dificuldade Mais Usada: <strong id="mostUsedDifficultyStat">Calculando...</strong></p>
            </div>

            <div class="analytics-card stat-card" style="margin-top: 15px;">
                <h4>Uso de Skins</h4>
                <div style="overflow-x: auto;">
                    <table class="admin-table" id="skinUsageTable">
                        <thead><tr><th>Skin</th><th>Nº de Jogadores</th><th>% do Total</th></tr></thead>
                        <tbody><tr><td colspan="3">Calculando...</td></tr></tbody>
                    </table>
                </div>
            </div>

            <div class="analytics-card stat-card" style="margin-top: 15px;">
                <h4>Distribuição de Dificuldade</h4>
                <div id="difficultyDistributionChart" class="bar-chart-container">
                    <p>Calculando...</p>
                </div>
            </div>

             <div class="analytics-card stat-card" style="margin-top: 15px;">
                <h4>Mapas Mais Jogados (por partida)</h4>
                <div id="mostPlayedMapsList">
                    <p>Calculando...</p>
                </div>
            </div>

        </div>
        <div id="adminUsersTab" class="admin-tab-content">
            <div class="filter-controls">
                <input type="text" id="userSearchInput" class="name-input" placeholder="Buscar por nome de usuário..." style="flex-grow: 1; margin: 0;">
                <button class="btn btn-primary" onclick="searchUser()">Buscar</button>
            </div>
            <div style="overflow-x: auto;">
                <table class="admin-table" id="usersTable">
                    <thead><tr><th>Usuário</th><th>Email</th><th>Moedas</th><th>Status</th><th>Ações</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div id="adminLeaderboardTab" class="admin-tab-content">
            <div class="filter-controls">
                <label for="leaderboardMapSelector">Mapa:</label>
                <select id="leaderboardMapSelector" class="name-input" onchange="loadFullLeaderboard(this.value)" style="flex-grow: 1; margin: 0; text-align: left;">
                    <option value="normal">Padrão</option>
                    <option value="no-walls">Sem Paredes</option>
                </select>
            </div>
            <div style="overflow-x: auto;">
                <table class="admin-table" id="leaderboardTable">
                     <thead><tr><th>#</th><th>Nome</th><th>Pontuação</th><th>Dificuldade</th><th>Data</th><th>Ação</th></tr></thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>

        <div id="adminSupportTab" class="admin-tab-content">
            <div class="filter-controls">
                <label for="supportStatusFilter">Filtrar por Status:</label>
                <select id="supportStatusFilter" class="name-input" onchange="loadSupportTickets()" style="flex-grow: 1; margin: 0; text-align: left;">
                    <option value="new">Novo</option>
                    <option value="in_progress">Em Andamento</option>
                    <option value="resolved">Resolvido</option>
                </select>
            </div>
            <div id="supportTicketsList"></div>
        </div>
        
        <div id="adminAnnouncementsTab" class="admin-tab-content">
            <h3>Anúncio Global</h3>
            <p style="font-size:12px; opacity: 0.7; margin-bottom: 15px;">A mensagem abaixo será exibida para todos os jogadores na tela principal.</p>
            <label for="announcementText">Texto do Anúncio:</label>
            <textarea id="announcementText" class="name-input" rows="3" style="text-align: left;"></textarea>
            <div class="setting-item">
                <label for="announcementActive">Ativar Anúncio</label>
                <input type="checkbox" id="announcementActive">
            </div>
            <button class="btn btn-primary" onclick="saveAnnouncement()" style="width:100%; margin-top: 20px;">Salvar Anúncio</button>
        </div>

        <div id="adminCollectiveActionsTab" class="admin-tab-content">
            <h3>Enviar Recompensa Coletiva</h3>
            <p style="font-size:12px; opacity: 0.7; margin-bottom: 15px;">Envie Snake Coins e uma mensagem para a caixa de entrada de todos os usuários cadastrados.</p>
            
            <label for="collectiveCoinsAmount">Quantidade de Snake Coins:</label>
            <input type="number" id="collectiveCoinsAmount" class="name-input" placeholder="Ex: 500">

            <label for="collectiveRewardMessage">Mensagem da Recompensa:</label>
            <textarea id="collectiveRewardMessage" class="name-input" rows="3" style="text-align: left;" placeholder="Ex: Obrigado por jogar! Aqui está um presente."></textarea>
            
            <button class="btn btn-primary" onclick="sendCollectiveReward()" style="width:100%; margin-top: 20px;">Enviar para Todos os Jogadores</button>
        </div>
        </div>
</div>

<div id="editUserModal" class="edit-user-modal">
    <div class="edit-user-modal-content">
        <h3 id="editUserTitle">Editar Usuário</h3>
        <input type="hidden" id="editUserId">
        <label for="editUserCoins">Snake Coins</label>
        <input type="number" id="editUserCoins" class="name-input">
        <div class="setting-item" style="margin-top: 15px;">
            <label for="editUserBanned">Banir Usuário</label>
            <input type="checkbox" id="editUserBanned">
        </div>
        <div class="btn-group">
            <button class="btn btn-secondary" onclick="closeEditUserModal()">Cancelar</button>
            <button class="btn btn-primary" onclick="handleUpdateUser()">Salvar</button>
        </div>
    </div>
</div>


<div id="reenterFullscreenPrompt" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); color: white; z-index: 3000; flex-direction: column; justify-content: center; align-items: center; text-align: center; padding: 20px;">
    <h2>Tela Cheia Recomendada</h2>
    <p style="margin: 20px 0;">Para a melhor experiência, o jogo deve ser jogado em tela cheia.</p>
    <button class="btn btn-primary">Voltar para Tela Cheia</button>
</div>

<div id="inboxModal" class="modal-overlay">
    <div class="modal-content">
        <h2 data-lang-key="inbox_title">Caixa de Entrada</h2>
        <div class="inbox-list" id="inboxList">
            </div>
        <button class="btn btn-secondary" onclick="closeInbox()" style="margin-top: 20px; width:100%;">Fechar</button>
    </div>
</div>


<div id="congratulationsScreen">
    <h2 data-lang-key="congrats_title">🎉 Parabéns! Novo Recorde! 🎉</h2>
    <p><span data-lang-key="your_score_prefix">Sua pontuação: </span><span id="finalScoreCongrats">0</span></p>
    <p><span data-lang-key="coins_earned_in_game_prefix">Moedas ganhas nesta partida: </span><span id="coinsEarnedCongrats">0</span>🪙</p>
    <button class="btn btn-primary restart-btn" onclick="restartGame()" data-lang-key="play_again_button">Jogar Novamente</button>
</div>

<div class="main-title">
    <span data-lang-key="title_snake_emoji">🐍</span>
    <span data-lang-key="title_j">J</span><span data-lang-key="title_o">o</span><span data-lang-key="title_g">g</span><span data-lang-key="title_o2">o</span>
    <span data-lang-key="title_d">d</span><span data-lang-key="title_a">a</span>
    <span data-lang-key="title_c">C</span><span data-lang-key="title_o3">o</span><span data-lang-key="title_b">b</span><span data-lang-key="title_r">r</span><span data-lang-key="title_i">i</span><span data-lang-key="title_n">n</span><span data-lang-key="title_h">h</span><span data-lang-key="title_a2">a</span>
</div>

<div class="game-container" id="loginScreen">
    <img src="https://i.imgur.com/Y0hwK0g.png" alt="Logo" class="login-logo">
    <h1 data-lang-key="welcome_title">Bem-vindo</h1>
    <input class="name-input" id="loginEmail" placeholder="Email" type="email" style="text-transform: none;"/>
    <input class="name-input" id="loginPass" placeholder="Senha" type="password"/>

    <p style="text-align: right; margin-top: 5px; margin-bottom: 15px; font-size: 12px;">
        <a href="#" onclick="handlePasswordReset()" data-lang-key="forgot_password_link">Esqueci a senha?</a>
    </p>

    <button class="btn btn-primary start-btn" onclick="handleLogin()" data-lang-key="login_button" style="margin-bottom: 0;">Entrar</button>
    <p style="margin-top: 15px;" data-lang-key="no_account_text">Ainda não tem conta? <a href="#" onclick="showRegister()" data-lang-key="register_link">Cadastre-se</a></p>
    <p style="font-size: 10px; margin-top: 20px; opacity: 0.5;" data-lang-key="developed_by">Desenvolvido por: John Costa</p>
</div>


<div class="game-container" id="registerScreen" style="display:none;">
    <h1 data-lang-key="register_title">📝 Cadastro</h1>
    <input class="name-input" id="registerEmail" placeholder="Email" type="email" style="text-transform: none;"/>
    <input class="name-input" id="registerPass" placeholder="Senha" type="password"/>
    <input class="name-input" id="registerUsername" placeholder="Nome de Usuário" type="text" />
    <button class="btn btn-primary start-btn" onclick="handleRegister()" data-lang-key="register_button" style="margin-bottom: 0;">Cadastrar</button>
    <p style="margin-top: 15px;"><a href="#" onclick="showLogin()" data-lang-key="already_have_account_link">Já tem conta? Entrar</a></p>
</div>

<div class="game-container" id="mainGame" style="display: none;">
    <button id="logoutBtn" onclick="handleLogout()" data-lang-key="logout_button" title="">🚪</button>
    <button id="inboxBtn" onclick="openInbox()" title="Caixa de Entrada">
        ✉️
        <div id="inboxNotification">0</div>
    </button>
    <button id="settingsBtn" onclick="toggleSettings()" title="Configurações">⚙️</button>
    <div class="language-selector">
        <button class="language-selector-button" id="languageButton">
            <img id="currentFlag" src="https://flagsapi.com/BR/flat/64.png" alt="Brazilian Flag">
        </button>
        <div class="language-selector-dropdown" id="languageDropdown">
            <div class="language-selector-option" data-lang="pt">
                <img src="https://flagsapi.com/BR/flat/64.png" alt="Brazilian Flag">
                <span>Português</span>
            </div>
            <div class="language-selector-option" data-lang="en">
                <img src="https://flagsapi.com/US/flat/64.png" alt="USA Flag">
                <span>English</span>
            </div>
            <div class="language-selector-option" data-lang="es">
                <img src="https://flagsapi.com/ES/flat/64.png" alt="Spanish Flag">
                <span>Español</span>
            </div>
        </div>
    </div>

    <div class="total-coins-display">
        <span id="totalSnakeCoins">0</span>
    </div>


<div class="leaderboard">
<img src="https://i.imgur.com/Y0hwK0g.png" alt="Logo" class="leaderboard-logo">

    <div class="personal-record">
        <span data-lang-key="your_high_score_prefix">Seu Recorde:</span> <span id="userHighScoreDisplay">0</span>
    </div>
    <h3 data-lang-key="top3_title">🏆 TOP 3</h3>
    <div class="leaderboard-item" id="leaderboard-item-1">
        <span>1º <span id="first-name">---</span><span class="leaderboard-difficulty" id="first-difficulty"></span></span>
        <span id="first-score">0</span>
    </div>
    <div class="leaderboard-item" id="leaderboard-item-2">
        <span>2º <span id="second-name">---</span><span class="leaderboard-difficulty" id="second-difficulty"></span></span>
        <span id="second-score">0</span>
    </div>
    <div class="leaderboard-item" id="leaderboard-item-3">
        <span>3º <span id="third-name">---</span><span class="leaderboard-difficulty" id="third-difficulty"></span></span>
        <span id="third-score">0</span>
    </div>
</div>
<div id="globalAnnouncement"></div>
<div class="player-score-container">
    <div id="loggedUser" data-lang-key="player_name_prefix">Jogador: ---</div>
    <div class="current-score">
        <span id="scorePrefix" data-lang-key="score_prefix">Pontos: </span><span id="score">0</span>
    </div>
</div>

<div class="current-difficulty" id="difficultyDisplay" style="display: none;">
    <span data-lang-key="difficulty_prefix">Dificuldade:</span> <span id="currentDifficultyText">Normal</span>
</div>

<canvas height="320" id="gameCanvas" width="320"></canvas>

<div id="settingsMenu" style="display: none; background: rgba(0,0,0,0.5); padding: 20px; border-radius: 15px; margin-top: 10px;">
    <h3 style="margin-top: 0;" data-lang-key="settings_title">⚙️ Configurações do Jogo</h3>
    <div class="settings-tabs">
        <button class="tab-button selected" onclick="showSettingsTab('general')" data-lang-key="tab_general">Geral</button>
        <button class="tab-button" onclick="showSettingsTab('controls')" data-lang-key="tab_controls">Controles</button>
        <button class="tab-button" onclick="showSettingsTab('account')" data-lang-key="tab_account">Conta</button>
        <button class="tab-button" onclick="showSettingsTab('support')" data-lang-key="tab_support">Suporte</button>
    </div>
    <div id="generalSettings" class="settings-tab-content">
        <label for="skinSelector" data-lang-key="label_skin">Visual da Cobrinha:</label>
        <select id="skinSelector" onchange="selectSkin(this.value)"></select>
        <canvas id="skinPreviewCanvas" width="120" height="40"></canvas>
        <button id="buySkinBtn" onclick="handlePurchase()" class="btn btn-primary" style="display: none; width: 100%; margin-top: 5px;"></button>
        <div id="colorPickerContainer" style="display: none; margin-top: 10px;">
            <label for="snakeColorPicker" data-lang-key="label_snake_color">Cor Personalizada:</label>
            <input id="snakeColorPicker" type="color" value="#00b894"/>
        </div>
        <br/><br/>
        
        <label for="screenBackgroundColor" data-lang-key="label_screen_background_color">Cor da Tela:</label>
        <input type="color" id="screenBackgroundColor" value="#1a1a1a" /><br /><br />
    </div>
    <div id="controlsSettings" class="settings-tab-content" style="display:none;">
        <label for="sensitivityRange" data-lang-key="label_button_sensitivity">Sensibilidade dos Botões:</label>
        <input id="sensitivityRange" max="10" min="1" type="range" value="5"/><br/><br/>
        <label for="joystickModel" data-lang-key="label_joystick_model">Modelo de Joystick:</label>
        <select id="joystickModel" class="name-input" onchange="toggleJoystick()">
            <option value="classic" data-lang-key="option_classic">Clássico</option>
            <option value="floating" data-lang-key="option_floating">Flutuante</option>
        </select><br/><br/>
        <label for="joystickPosition" data-lang-key="label_joystick_position">Posição do Joystick Flutuante:</label>
        <select id="joystickPosition" class="name-input" onchange="updateJoystickPosition()">
            <option value="right" data-lang-key="option_right">Direita</option>
            <option value="left" data-lang-key="option_left">Esquerda</option>
            <option value="center" data-lang-key="option_center">Centro</option>
        </select><br/><br/>
    </div>
    <div id="accountSettings" class="settings-tab-content" style="display:none;">
        <h4 data-lang-key="change_username_title">Mudar Nome de Usuário</h4>
        <input class="name-input" id="newUsername" placeholder="Novo Nome de Usuário" type="text"/>
        <input class="name-input" id="currentPassForUsername" placeholder="Sua Senha Atual" type="password"/>
        <button class="btn btn-primary" onclick="handleChangeUsername()" data-lang-key="confirm_button">Confirmar</button>
        <p style="color:red; font-size:12px; min-height: 15px;" id="usernameChangeError"></p>

        <h4 data-lang-key="change_email_title">Mudar Email</h4>
        <input class="name-input" id="newEmail" placeholder="Novo Email" type="email" style="text-transform: none;"/>
        <input class="name-input" id="currentPassForEmail" placeholder="Sua Senha Atual" type="password"/>
        <button class="btn btn-primary" onclick="handleChangeEmail()" data-lang-key="confirm_button_2">Confirmar</button>
        <p style="color:red; font-size:12px; min-height: 15px;" id="emailChangeError"></p>

        <h4 style="margin-top: 20px;" data-lang-key="change_password_title">Mudar Senha</h4>
        <input class="name-input" id="oldPassword" placeholder="Senha Antiga" type="password"/>
        <input class="name-input" id="newPassword" placeholder="Nova Senha" type="password"/>
        <input class="name-input" id="confirmNewPassword" placeholder="Confirme Nova Senha" type="password"/>
        <button class="btn btn-primary" onclick="handleChangePassword()" data-lang-key="confirm_button_3">Confirmar</button>
        <p style="color:red; font-size:12px; min-height: 15px;" id="passwordChangeError"></p>
    </div>
    <div id="supportSettings" class="settings-tab-content" style="display:none;">
        <h4 data-lang-key="support_title">Contatar Suporte</h4>
        <p style="font-size: 12px; opacity: 0.8; margin-bottom: 15px;" data-lang-key="support_description">Encontrou um problema ou tem alguma sugestão? Nos envie uma mensagem!</p>
        
        <label for="supportType" data-lang-key="label_support_type">Tópico:</label>
        <select id="supportType" class="name-input">
            <option value="bug" data-lang-key="option_bug">Reportar Bug</option>
            <option value="player" data-lang-key="option_player">Reportar Jogador</option>
            <option value="feedback" data-lang-key="option_feedback">Feedback/Sugestão</option>
            <option value="other" data-lang-key="option_other">Outro</option>
        </select>
        
        <label for="supportMessage" data-lang-key="label_support_message">Sua Mensagem:</label>
        <textarea id="supportMessage" class="name-input" rows="4" style="text-align: left; padding: 10px; resize: vertical;" placeholder="Descreva seu problema ou sugestão detalhadamente aqui..."></textarea>
        
        <p style="color:limegreen; font-size:12px; min-height: 15px;" id="supportSuccessMessage"></p>
        
        <button class="btn btn-primary" onclick="handleSupportRequest()" data-lang-key="send_button" style="width: 100%;">Enviar</button>
    </div>
    <button class="btn btn-secondary" onclick="closeSettings()" style="margin-top: 20px; width:100%;" data-lang-key="close_button">Fechar</button>
</div>

<div id="startScreen">
    <button class="btn btn-primary start-btn" onclick="startGame()" data-lang-key="start_game_button">Iniciar Jogo</button>
    
    <h3 class="selection-title" data-lang-key="choose_difficulty_title">Escolha a Dificuldade:</h3>
    <div class="difficulty-selection">
        <button class="difficulty-btn easy" onclick="selectDifficulty('easy')" data-lang-key="difficulty_easy_button">🐌<br>Fácil</button>
        <button class="difficulty-btn normal selected" onclick="selectDifficulty('normal')" data-lang-key="difficulty_normal_button">🐍<br>Normal</button>
        <button class="difficulty-btn hard" onclick="selectDifficulty('hard')" data-lang-key="difficulty_hard_button">🚀<br>Difícil</button>
        <button class="difficulty-btn insane" onclick="selectDifficulty('insane')" data-lang-key="difficulty_insane_button">💀<br>Insano</button>
    </div>
    <div class="difficulty-info" id="difficultyInfo">Velocidade média - Perfeito para iniciantes!</div>

    <h3 class="selection-title" data-lang-key="choose_map_title">Escolha o Mapa:</h3>
    <div class="map-selection">
        <button class="difficulty-btn selected" onclick="selectMap('normal')" data-lang-key="map_default_button">🧱<br>Padrão</button>
        <button class="difficulty-btn" onclick="selectMap('no-walls')" data-lang-key="map_no_walls_button">🌌<br>Sem Paredes</button>
    </div>
    <div class="difficulty-info" id="mapInfo">Paredes normais.</div>
</div>

<div class="controls" id="gameControls" style="display: none;">
    <button class="control-btn up" id="upBtn">↑</button>
    <button class="control-btn left" id="leftBtn">←</button>
    <button class="control-btn right" id="rightBtn">→</button>
    <button class="control-btn down" id="downBtn">↓</button>
</div>
<div style="display: flex; justify-content: center;">
    <button class="btn btn-secondary pause-btn" id="pauseBtn" onclick="togglePause()" style="display: none;" data-lang-key="pause_button">⏸️ Pausar</button>
    <button class="btn btn-danger quit-game-btn" id="quitGameBtn" onclick="quitGame()" style="display: none;" data-lang-key="quit_game_button">🚫 Sair</button>
</div>
<div class="instructions" id="gameInstructions" style="display: none; margin-top: 15px;">
    <p data-lang-key="instructions_controls" style="font-size: 12px; opacity: 0.7;">Use os botões para controlar a cobra</p>
    <p data-lang-key="instructions_food" style="font-size: 12px; opacity: 0.7;">Colete a comida vermelha para crescer!</p>
</div>

<div class="game-over" id="gameOver">
<h2>Game Over!</h2>
<p><span id="yourScorePrefix" data-lang-key="your_score_prefix">Sua pontuação: </span><span id="finalScore">0</span></p>
<p><span data-lang-key="coins_earned_in_game_prefix">Moedas ganhas nesta partida: </span><span id="coinsEarnedGameOver">0</span>🪙</p>
<button class="btn btn-primary restart-btn" onclick="restartGame()" data-lang-key="play_again_button">Jogar Novamente</button>
</div>

</div>

<div id="floatingJoystick" style="position: fixed; bottom: 40px; right: 40px; width: 120px; height: 120px; border-radius: 50%; background: rgba(255,255,255,0.1); border: 2px solid rgba(255,255,255,0.2); display: none; touch-action: none;">
    <div id="joystickThumb" style="width: 40px; height: 40px; background: rgba(255,255,255,0.3); border-radius: 50%; position: absolute; left: 40px; top: 40px;"></div>
</div>

<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-app.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-auth.js"></script>
<script src="https://www.gstatic.com/firebasejs/8.10.0/firebase-firestore.js"></script>

<script>
    // Configuração e inicialização do Firebase
    const firebaseConfig = {
        apiKey: "AIzaSyD-W1DR-m3kRXZ9l4J04R8D_L0adVGkxyA",
        authDomain: "cdi-games.firebaseapp.com",
        projectId: "cdi-games",
        storageBucket: "cdi-games.appspot.com",
        messagingSenderId: "965010965921",
        appId: "1:965010965921:web:270812342fe53f4d1637e0",
        measurementId: "G-P0TL8K8GH6"
    };

    firebase.initializeApp(firebaseConfig);
    const auth = firebase.auth();
    const db = firebase.firestore();

    const skinPreviewCanvas = document.getElementById('skinPreviewCanvas');
    const previewCtx = skinPreviewCanvas.getContext('2d');
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const gameOverElement = document.getElementById('gameOver');
    const finalScoreElement = document.getElementById('finalScore');
    const startScreen = document.getElementById('startScreen');
    const gameControls = document.getElementById('gameControls');
    const pauseBtn = document.getElementById('pauseBtn');
    const quitGameBtn = document.getElementById('quitGameBtn');
    const gameInstructions = document.getElementById('gameInstructions');
    const difficultyDisplay = document.getElementById('difficultyDisplay');
    const currentDifficultyText = document.getElementById('currentDifficultyText');
    const difficultyInfo = document.getElementById('difficultyInfo');
    const mapInfo = document.getElementById('mapInfo');
    const congratulationsScreen = document.getElementById('congratulationsScreen');
    const finalScoreCongrats = document.getElementById('finalScoreCongrats');
    const reenterPrompt = document.getElementById('reenterFullscreenPrompt');
    let fireworksInterval;
    const firstName = document.getElementById('first-name');
    const firstScore = document.getElementById('first-score');
    const firstDifficulty = document.getElementById('first-difficulty');
    const secondName = document.getElementById('second-name');
    const secondScore = document.getElementById('second-score');
    const secondDifficulty = document.getElementById('second-difficulty');
    const thirdName = document.getElementById('third-name');
    const thirdScore = document.getElementById('third-score');
    const thirdDifficulty = document.getElementById('third-difficulty');
    let screenBackgroundColor;
    
    // Variáveis para o sistema de moedas
    let snakeCoins = 0; // Total de Snake Coins do usuário
    let coinsEarnedThisGame = 0; // Moedas ganhas na partida atual
    const coinsEarnedCongratsElement = document.getElementById('coinsEarnedCongrats');
    const coinsEarnedGameOverElement = document.getElementById('coinsEarnedGameOver');
    const totalSnakeCoinsElement = document.getElementById('totalSnakeCoins');
    const userHighScoreDisplay = document.getElementById('userHighScoreDisplay'); // Elemento para recorde pessoal

    // Objeto para armazenar recordes pessoais por mapa
    let userHighScoresPerMap = {}; 

    // --- Sistema de Skins ---
    const skins = {
        'custom': { name_pt: 'Personalizada', name_en: 'Custom', name_es: 'Personalizado', unlockScore: 0, bodyColor: null, headColor: null },
        'default': { name_pt: 'Padrão', name_en: 'Default', name_es: 'Estándar', unlockScore: 0, bodyColor: '#00b894', headColor: '#008269' },
        'spider': { name_pt: 'Aranha', name_en: 'Spider', name_es: 'Araña', unlockScore: 2000, blueColor: '#005AFF', redColor: '#FF0000' },
        'coral': { name_pt: 'Coral', name_en: 'Coral', name_es: 'Coral', unlockScore: 1500, colors: ['#D90429', '#000000', '#FFFFFF'] }, // Vermelho, Preto, Branco
        'pharaoh': { name_pt: 'Faraó', name_en: 'Pharaoh', name_es: 'Faraón', unlockScore: 2500, bodyColor1: '#FFD700', bodyColor2: '#DAA520', headColor: '#00008B', uraeusColor: '#FF0000' },
        // Novas skins baseadas em SC
        'galaxy': { name_pt: 'Galáxia', name_en: 'Galaxy', name_es: 'Galaxia', unlockCoins: 1500, colors: ['#4B0082', '#00008B', '#8A2BE2'], headColor: '#FFFFFF' },
        'circuit': { name_pt: 'Tecnologia', name_en: 'Circuit', name_es: 'Tecnología', unlockCoins: 1000, bodyColor: '#39FF14', headColor: '#00FFFF' },
        'camo': { name_pt: 'Camo', name_en: 'Camo', name_es: 'Camo', unlockCoins: 500, colors: ['#4B5320', '#8B4513', '#D2B48C'], headColor: '#228B22' },
        'halloween': { name_pt: 'Halloween', name_en: 'Halloween', name_es: 'Halloween', unlockCoins: 1000, bodyColor1: '#000000', bodyColor2: '#4B0082', headColor: '#FF8C00', lineColor: '#FF8C00' },
        'christmas': { name_pt: 'Natal', name_en: 'Christmas', name_es: 'Navidad', unlockCoins: 500, colors: ['#006400', '#DC143C'], headColor: '#FFD700' }
    };
    let currentSkin = 'default';
    let unlockedSkins = ['default', 'custom']; // Inicializa com default e custom
    
    document.getElementById('screenBackgroundColor').addEventListener('input', function(e) {
        screenBackgroundColor = e.target.value;
        document.getElementById('mainGame').style.background = screenBackgroundColor;
    });
    function shadeColor(color, percent) {
        let f=parseInt(color.slice(1),16),t=percent<0?0:255,p=percent<0?percent*-1:percent,R=f>>16,G=f>>8&0x00FF,B=f&0x0000FF;
        return "#"+(0x1000000+(Math.round((t-R)*p)+R)*0x10000+(Math.round((t-G)*p)+G)*0x100+(Math.round((t-B)*p)+B)).toString(16).slice(1);
    }
    const difficulties = {
        easy: { speed: 150, name_pt: 'Fácil', name_en: 'Easy', name_es: 'Fácil', description_pt: 'Velocidade lenta - Ideal para relaxar!', description_en: 'Slow speed - Ideal for relaxing!', description_es: 'Velocidad lenta - ¡Ideal para relajarse!', emoji: '🐌', points: 5 },
        normal: { speed: 120, name_pt: 'Normal', name_en: 'Normal', name_es: 'Normal', description_pt: 'Velocidade balanceada - A experiência clássica.', description_en: 'Balanced speed - The classic experience.', description_es: 'Velocidad equilibrada - La experiencia clásica.', emoji: '🐍', points: 10 },
        hard: { speed: 90, name_pt: 'Difícil', name_en: 'Hard', name_es: 'Difícil', description_pt: 'Velocidade rápida - Um bom desafio!', description_en: 'Fast speed - A good challenge!', description_es: 'Velocidad rápida - ¡Un buen desafío!', emoji: '🚀', points: 20 },
        insane: { speed: 70, name_pt: 'Insano', name_en: 'Insane', name_es: 'Insano', description_pt: 'Velocidade extrema - Para os mestres da cobrinha!', description_en: 'Extreme speed - For the snake masters!', description_es: 'Velocidad extrema - ¡Para los maestros de la serpiente!', emoji: '💀', points: 32 }
    };
    let currentDifficulty = 'normal';
    let gameInterval;
    const maps = {
        'normal': { name_pt: 'Padrão', name_en: 'Standard', name_es: 'Estándar', description_pt: 'As paredes são barreiras mortais.', description_en: 'Walls are deadly barriers.', description_es: 'Las paredes son barreras mortales.', wrapAround: false },
        'no-walls': { name_pt: 'Sem Paredes', name_en: 'No Walls', name_es: 'Sin Paredes', description_pt: 'Atravesse as paredes e reapareça do outro lado!', description_en: 'Pass through walls and reappear on the other side!', description_es: '¡Atraviesa las paredes y reaparece del otro lado!', wrapAround: true }
    };
    let currentMap = 'normal';
    const gridSize = 16;
    const tileCount = Math.floor(canvas.width / gridSize);
    let snake = [{x: Math.floor(tileCount/2), y: Math.floor(tileCount/2)}];
    let food = {};
    let dx = 0;
    let dy = 0;
    let score = 0;
    let gameRunning = false;
    let gameStarted = false;
    let gamePaused = false;
    let inputQueue = [];
    const translations = {
        'pt': {
            'label_skin': 'Visual da Cobrinha:', 'label_snake_color': 'Cor Personalizada:', 'skin_custom': 'Personalizada', 'skin_default': 'Padrão', 'skin_spider': 'Aranha', 'skin_coral': 'Coral', 'skin_pharaoh': 'Faraó', 'skin_galaxy': 'Galáxia', 'skin_circuit': 'Tecnologia', 'skin_camo': 'Camuflado', 'skin_halloween': 'Halloween', 'skin_christmas': 'Natal', 'congrats_title': '🎉 Parabéns! Novo Recorde! 🎉', 'title_snake_emoji': '', 'title_j': 'J', 'title_o': 'o', 'title_g': 'g', 'title_o2': 'o', 'title_d': ' d', 'title_a': 'a', 'title_c': ' C', 'title_o3': 'o', 'title_b': 'b', 'title_r': 'r', 'title_i': 'i', 'title_n': 'n', 'title_h': 'h', 'title_a2': 'a', 'welcome_title': 'Bem-vindo', 'login_button': 'Entrar', 'no_account_text': 'Ainda não tem conta?', 'register_link': 'Cadastre-se', 'developed_by': 'Desenvolvido por: John Costa', 'register_title': '📝 Cadastro', 'register_button': 'Cadastrar', 'already_have_account_link': 'Já tem conta? Entrar', 'game_title': 'Jogo da Cobrinha', 'player_name_prefix': 'Jogador:', 'score_prefix': 'Pontos:', 'difficulty_prefix': 'Dificuldade:', 'top3_title': '🏆 TOP 3', 'logout_button': '🚪', 'settings_title': '⚙️ Configurações', 'tab_general': 'Geral', 'tab_controls': 'Controles', 'tab_account': 'Conta', 'label_screen_background_color': 'Cor da Tela:', 'label_button_sensitivity': 'Sensibilidade dos Botões:', 'label_joystick_model': 'Modelo de Joystick:', 'option_classic': 'Clássico', 'option_floating': 'Flutuante', 'label_joystick_position': 'Posição do Joystick Flutuante:', 'option_right': 'Direita', 'option_left': 'Esquerda', 'option_center': 'Centro', 'change_username_title': 'Mudar Nome de Usuário', 'change_email_title': 'Mudar Email', 'confirm_button': 'Confirmar', 'confirm_button_2': 'Confirmar', 'confirm_button_3': 'Confirmar', 'change_password_title': 'Mudar Senha', 'close_button': 'Fechar', 'start_game_button': 'Iniciar Jogo', 'choose_difficulty_title': 'Escolha a Dificuldade:', 'difficulty_easy_button': '🐌<br>Fácil', 'difficulty_normal_button': '🐍<br>Normal', 'difficulty_hard_button': '🚀<br>Difícil', 'difficulty_insane_button': '💀<br>Insano', 'choose_map_title': 'Escolha o Mapa:', 'map_default_button': '🧱<br>Padrão', 'map_no_walls_button': '🌌<br>Sem Paredes', 'pause_button': 'Pausar', 'continue_button': 'Continuar', 'quit_game_button': '🚫 Sair', 'game_over_title': 'Game Over!', 'your_score_prefix': 'Sua pontuação:', 'play_again_button': 'Jogar Novamente', 'instructions_controls': 'Use os botões para controlar a cobra', 'instructions_food': 'Colete a comida vermelha para crescer!', 'alert_fill_all_fields': 'Preencha todos os campos', 'alert_user_exists': 'Este email já está cadastrado', 'alert_registration_success': 'Cadastro realizado com sucesso!', 'alert_invalid_credentials': 'Email ou senha inválidos', 'alert_confirm_quit': 'Tem certeza que deseja sair da partida atual?', 'alert_no_user_logged_in': 'Nenhum usuário logado.', 'alert_new_email_empty': 'O novo email não pode ser vazio.', 'alert_email_taken': 'Este email já está em uso.', 'alert_incorrect_current_password': 'Senha atual incorreta.', 'alert_email_changed_success': 'Email alterado com sucesso!', 'alert_new_email_same_as_current': 'O novo email é o mesmo que o atual.', 'alert_fill_all_password_fields': 'Preencha todos os campos de senha.', 'alert_old_password_incorrect': 'Senha antiga incorreta.', 'alert_new_passwords_dont_match': 'A nova senha e a confirmação não coincidem.', 'alert_password_changed_success': 'Senha alterada com sucesso!', 'alert_new_password_same_as_old': 'A nova senha não pode ser igual à antiga.', 'password_min_length': 'A senha deve ter no mínimo {minLength} caracteres.', 'password_needs_number': 'A senha deve conter pelo menos um número.', 'password_needs_letter': 'A senha deve conter pelo menos uma letra.', 'alert_invalid_email': 'Por favor, insira um endereço de e-mail válido.', 'choose_username_title': 'Escolha seu nome de usuário', 'choose_username_subtitle': 'Este nome será exibido no jogo e no ranking.', 'alert_username_taken': 'Este nome de usuário já está em uso.', 'alert_username_empty': 'O nome de usuário não pode ser vazio.', 'alert_username_changed_success': 'Nome de usuário alterado com sucesso!', 'alert_new_username_same_as_current': 'O novo nome de usuário é o mesmo que o atual.', 'forgot_password_link': 'Esqueci a senha?', 'alert_enter_email_for_reset': 'Por favor, insira seu email no campo correspondente para redefinir a senha.', 'alert_password_reset_success': 'Email de redefinição de senha enviado! Verifique sua caixa de entrada.',
            'coins_earned_in_game_prefix': 'Moedas ganhas nesta partida:',
            'total_coins_display': 'SC',
            'confirm_buy_skin': 'Tem certeza que deseja comprar esta skin por',
            'not_enough_coins': 'Você não tem Snake Coins suficientes para comprar esta skin!',
            'skin_unlocked_success': 'Skin desbloqueada com sucesso!',
            'your_high_score_prefix': 'Seu Recorde:',
            // Novas traduções de Suporte
            'tab_support': 'Suporte',
            'support_title': 'Contatar Suporte',
            'support_description': 'Encontrou um problema ou tem alguma sugestão? Nos envie uma mensagem!',
            'label_support_type': 'Tópico:',
            'option_bug': 'Reportar Bug',
            'option_player': 'Reportar Jogador',
            'option_feedback': 'Feedback/Sugestão',
            'option_other': 'Outro',
            'label_support_message': 'Sua Mensagem:',
            'send_button': 'Enviar',
            'alert_support_message_empty': 'A mensagem não pode estar vazia.',
            'alert_support_success': 'Mensagem enviada com sucesso! Agradecemos o contato.',
            // Novas traduções da Caixa de Entrada
            'inbox_title': 'Caixa de Entrada',
            'inbox_empty': 'Sua caixa de entrada está vazia.',
            'inbox_delete_confirm': 'Tem certeza que deseja apagar esta mensagem?'
        },
        'en': {
            'label_skin': 'Snake Skin:', 'label_snake_color': 'Custom Color:', 'skin_custom': 'Custom', 'skin_default': 'Default', 'skin_spider': 'Spider', 'skin_coral': 'Coral', 'skin_pharaoh': 'Pharaoh', 'skin_galaxy': 'Galaxy', 'skin_circuit': 'Circuit', 'skin_camo': 'Camouflaged', 'skin_halloween': 'Halloween', 'skin_christmas': 'Christmas', 'congrats_title': '🎉 Congratulations! New Record! 🎉', 'title_snake_emoji': '', 'title_j': 'S', 'title_o': 'n', 'title_g': 'a', 'title_o2': 'k', 'title_d': 'e', 'title_a': ' G', 'title_c': 'a', 'title_o3': 'm', 'title_b': 'e', 'title_r': '', 'title_i': '', 'title_n': '', 'title_h': '', 'title_a2': '', 'welcome_title': 'Welcome', 'login_button': 'Login', 'no_account_text': 'Don\'t have an account?', 'register_link': 'Sign Up', 'developed_by': 'John Costa', 'register_title': '📝 Sign Up', 'register_button': 'Sign Up', 'already_have_account_link': 'Already have an account? Login', 'game_title': ' Snake Game', 'player_name_prefix': 'Player:', 'score_prefix': 'Score:', 'difficulty_prefix': 'Difficulty:', 'top3_title': '🏆 TOP 3', 'logout_button': '🚪', 'settings_title': '⚙️ Settings', 'tab_general': 'General', 'tab_controls': 'Controls', 'tab_account': 'Account', 'label_screen_background_color': 'Screen Color:', 'label_button_sensitivity': 'Button Sensitivity:', 'label_joystick_model': 'Joystick Model:', 'option_classic': 'Classic', 'option_floating': 'Floating', 'label_joystick_position': 'Floating Joystick Position:', 'option_right': 'Right', 'option_left': 'Left', 'option_center': 'Center', 'change_username_title': 'Change Username', 'change_email_title': 'Change Email', 'confirm_button': 'Confirm', 'confirm_button_2': 'Confirm', 'confirm_button_3': 'Confirm', 'change_password_title': 'Change Password', 'close_button': 'Close', 'start_game_button': 'Start Game', 'choose_difficulty_title': 'Choose Difficulty:', 'difficulty_easy_button': '🐌<br>Easy', 'difficulty_normal_button': '🐍<br>Normal', 'difficulty_hard_button': '🚀<br>Hard', 'difficulty_insane_button': '💀<br>Insane', 'choose_map_title': 'Choose Map:', 'map_default_button': '🧱<br>Standard', 'map_no_walls_button': '🌌<br>No Walls', 'pause_button': 'Pause', 'continue_button': 'Continue', 'quit_game_button': '🚫 Quit', 'game_over_title': 'Game Over!', 'your_score_prefix': 'Your Score:', 'play_again_button': 'Play Again', 'instructions_controls': 'Use the buttons to control the snake', 'instructions_food': 'Collect red food to grow!', 'alert_fill_all_fields': 'Please fill in all fields', 'alert_user_exists': 'This email is already registered', 'alert_registration_success': 'Registration successful!', 'alert_invalid_credentials': 'Invalid email or password', 'alert_confirm_quit': 'Are you sure you want to quit the current game?', 'alert_no_user_logged_in': 'No user logged in.', 'alert_new_email_empty': 'New email cannot be empty.', 'alert_email_taken': 'This email is already in use.', 'alert_incorrect_current_password': 'Incorrect current password.', 'alert_email_changed_success': 'Email changed successfully!', 'alert_new_email_same_as_current': 'The new email is the same as the current one.', 'alert_fill_all_password_fields': 'Please fill in all password fields.', 'alert_old_password_incorrect': 'Incorrect old password.', 'alert_new_passwords_dont_match': 'New password and confirmation do not match.', 'alert_password_changed_success': 'Password changed successfully!', 'alert_new_password_same_as_old': 'New password cannot be the same as the old one.', 'password_min_length': 'Password must be at least {minLength} characters long.', 'password_needs_number': 'Password must contain at least one number.', 'password_needs_letter': 'Password must contain at least one letter.', 'alert_invalid_email': 'Please enter a valid email address.', 'choose_username_title': 'Choose your username', 'choose_username_subtitle': 'This name will be displayed in-game and on the leaderboard.', 'alert_username_taken': 'This username is already taken.', 'alert_username_empty': 'Username cannot be empty.', 'alert_username_changed_success': 'Username changed successfully!', 'alert_new_username_same_as_current': 'The new username is the same as the current one.', 'forgot_password_link': 'Forgot password?', 'alert_enter_email_for_reset': 'Please enter your email in the field to reset your password.', 'alert_password_reset_success': 'Password reset email sent! Check your inbox.',
            'coins_earned_in_game_prefix': 'Coins earned this game:',
            'total_coins_display': 'SC',
            'confirm_buy_skin': 'Are you sure you want to buy this skin for',
            'not_enough_coins': 'You do not have enough Snake Coins to buy this skin!',
            'skin_unlocked_success': 'Skin unlocked successfully!',
            'your_high_score_prefix': 'Your High Score:',
            // Novas traduções de Suporte
            'tab_support': 'Support',
            'support_title': 'Contact Support',
            'support_description': 'Found an issue or have a suggestion? Send us a message!',
            'label_support_type': 'Topic:',
            'option_bug': 'Report a Bug',
            'option_player': 'Report a Player',
            'option_feedback': 'Feedback/Suggestion',
            'option_other': 'Other',
            'label_support_message': 'Your Message:',
            'send_button': 'Send',
            'alert_support_message_empty': 'The message cannot be empty.',
            'alert_support_success': 'Message sent successfully! Thank you for contacting us.',
            // Novas traduções da Caixa de Entrada
            'inbox_title': 'Inbox',
            'inbox_empty': 'Your inbox is empty.',
            'inbox_delete_confirm': 'Are you sure you want to delete this message?'
        },
        'es': {
            'label_skin': 'Aspecto de Serpiente:', 'label_snake_color': 'Color Personalizado:', 'skin_custom': 'Personalizado', 'skin_default': 'Estándar', 'skin_spider': 'Araña', 'skin_coral': 'Coral', 'skin_pharaoh': 'Faraón', 'skin_galaxy': 'Galaxia', 'skin_circuit': 'Tecnología', 'skin_camo': 'Camuflado', 'skin_halloween': 'Halloween', 'skin_christmas': 'Navidad', 'congrats_title': '🎉 ¡Felicidades! ¡Nuevo Récord! 🎉', 'title_snake_emoji': '', 'title_j': 'J', 'title_o': 'u', 'title_g': 'e', 'title_o2': 'g', 'title_d': 'o', 'title_a': ' d', 'title_c': 'e', 'title_o3': ' l', 'title_b': 'a', 'title_r': ' S', 'title_i': 'e', 'title_n': 'r', 'title_h': 'p', 'title_a2': 'iente', 'welcome_title': 'Bienvenido', 'login_button': 'Iniciar Sesión', 'no_account_text': '¿No tienes cuenta?', 'register_link': 'Regístrate', 'developed_by': 'Desarrollado por: John Costa', 'register_title': '📝 Registro', 'register_button': 'Registrar', 'already_have_account_link': '¿Ya tienes cuenta? Iniciar Sesión', 'game_title': ' Juego de la Serpiente', 'player_name_prefix': 'Jugador:', 'score_prefix': 'Puntos:', 'difficulty_prefix': 'Dificultad:', 'top3_title': '🏆 TOP 3', 'logout_button': '🚪', 'settings_title': '⚙️ Ajustes', 'tab_general': 'General', 'tab_controls': 'Controles', 'tab_account': 'Cuenta', 'label_screen_background_color': 'Color de la Pantalla:', 'label_button_sensitivity': 'Sensibilidad de los Botones:', 'label_joystick_model': 'Modelo de Joystick:', 'option_classic': 'Clásico', 'option_floating': 'Flotante', 'label_joystick_position': 'Posición del Joystick Flotante:', 'option_right': 'Derecha', 'option_left': 'Izquierda', 'option_center': 'Centro', 'change_username_title': 'Cambiar Nombre de Usuario', 'change_email_title': 'Cambiar Email', 'confirm_button': 'Confirmar', 'confirm_button_2': 'Confirmar', 'confirm_button_3': 'Confirmar', 'change_password_title': 'Cambiar Contraseña', 'close_button': 'Cerrar', 'start_game_button': 'Iniciar Juego', 'choose_difficulty_title': 'Elige la Dificultad:', 'difficulty_easy_button': '🐌<br>Fácil', 'difficulty_normal_button': '🐍<br>Normal', 'difficulty_hard_button': '🚀<br>Difícil', 'difficulty_insane_button': '💀<br>Insano', 'choose_map_title': 'Elige el Mapa:', 'map_default_button': '🧱<br>Estándar', 'map_no_walls_button': '🌌<br>Sin Paredes', 'pause_button': 'Pausar', 'continue_button': 'Continuar', 'quit_game_button': '🚫 Salir', 'game_over_title': '¡Fin del Juego!', 'your_score_prefix': 'Tu puntuación:', 'play_again_button': 'Jugar de Nuevo', 'instructions_controls': 'Usa los botones para controlar la serpiente', 'instructions_food': '¡Recoge la comida roja para crecer!', 'alert_fill_all_fields': 'Por favor, rellene todos los campos', 'alert_user_exists': 'Este correo electrónico ya está registrado', 'alert_registration_success': '¡Registro exitoso!', 'alert_invalid_credentials': 'Correo electrónico o contraseña no válidos', 'alert_confirm_quit': '¿Estás seguro de que quieres salir del juego actual?', 'alert_no_user_logged_in': 'Ningún usuario ha iniciado sesión.', 'alert_new_email_empty': 'El nuevo correo electrónico no puede estar vacío.', 'alert_email_taken': 'Este correo electrónico ya está en uso.', 'alert_incorrect_current_password': 'Contraseña actual incorrecta.', 'alert_email_changed_success': '¡Correo electrónico cambiado con éxito!', 'alert_new_email_same_as_current': 'El nuevo correo electrónico es el mismo que el actual.', 'alert_fill_all_password_fields': 'Por favor, rellene todos los campos de contraseña.', 'alert_old_password_incorrect': 'Contraseña antigua incorrecta.', 'alert_new_passwords_dont_match': 'La nueva contraseña y la confirmación no coinciden.', 'alert_password_changed_success': '¡Contraseña cambiada con éxito!', 'alert_new_password_same_as_old': 'La nueva contraseña no puede ser igual a la antigua.', 'password_min_length': 'La contraseña debe tener al menos {minLength} caracteres.', 'password_needs_number': 'La contraseña debe contener al menos un número.', 'password_needs_letter': 'La contraseña debe contener al menos uma letra.', 'alert_invalid_email': 'Por favor, introduce una dirección de correo electrónico válida.', 'choose_username_title': 'Elige tu nombre de usuario', 'choose_username_subtitle': 'Este nombre se mostrará en el juego y en la clasificación.', 'alert_username_taken': 'Este nombre de usuario ya está en uso.', 'alert_username_empty': 'El nombre de usuario no puede estar vacío.', 'alert_username_changed_success': '¡Nombre de usuario cambiado con éxito!', 'alert_new_username_same_as_current': 'El nuevo nombre de usuario es el mismo que el actual.', 'forgot_password_link': '¿Olvidaste la contraseña?', 'alert_enter_email_for_reset': 'Por favor, introduce tu correo electrónico en el campo para restablecer la contraseña.', 'alert_password_reset_success': '¡Correo de restablecimiento de contraseña enviado! Revisa tu bandeja de entrada.',
            'coins_earned_in_game_prefix': 'Monedas ganadas en esta partida:',
            'total_coins_display': 'SC',
            'confirm_buy_skin': '¿Estás seguro de que quieres comprar esta skin por',
            'not_enough_coins': '¡No tienes suficientes Snake Coins para comprar esta skin!',
            'skin_unlocked_success': '¡Skin desbloqueada con éxito!',
            'your_high_score_prefix': 'Tu Record:',
            // Novas traduções de Suporte
            'tab_support': 'Soporte',
            'support_title': 'Contactar a Soporte',
            'support_description': '¿Encontraste un problema o tienes una sugerencia? ¡Envíanos un mensaje!',
            'label_support_type': 'Asunto:',
            'option_bug': 'Reportar un Bug',
            'option_player': 'Reportar un Jugador',
            'option_feedback': 'Comentarios/Sugerencia',
            'option_other': 'Otro',
            'label_support_message': 'Tu Mensaje:',
            'send_button': 'Enviar',
            'alert_support_message_empty': 'El mensaje no puede estar vacío.',
            'alert_support_success': '¡Mensaje enviado con éxito! Gracias por contactarnos.',
             // Novas traduções da Caixa de Entrada
            'inbox_title': 'Buzón de Entrada',
            'inbox_empty': 'Tu buzón de entrada está vacío.',
            'inbox_delete_confirm': '¿Estás seguro de que quieres borrar este mensaje?'
        }
    };
    let currentLanguage = localStorage.getItem('snakeGameLanguage') || 'pt';

    function updateContent() {
        const lang = translations[currentLanguage];
        document.querySelectorAll('[data-lang-key]').forEach(element => {
            const key = element.getAttribute('data-lang-key');
            const text = lang[key];
            if (key.startsWith('skin_')) return; 

            if (key.startsWith('title_') && element.closest('.main-title')) {
                const fullTitle = [ lang['title_snake_emoji'], lang['title_j'], lang['title_o'], lang['title_g'], lang['title_o2'], lang['title_d'], lang['title_a'], lang['title_c'], lang['title_o3'], lang['title_b'], lang['title_r'], lang['title_i'], lang['title_n'], lang['title_h'], lang['title_a2'] ].join('');
                document.querySelector('.main-title').textContent = fullTitle.replace(/,/g, ''); 
                return;
            }
            
            if (key === 'player_name_prefix') {
                 if (currentUsername) {
                    element.textContent = `${text} ${currentUsername}`;
                } else {
                    element.textContent = text;
                }
            } else if (key === 'your_high_score_prefix') {
                element.textContent = text;
            } else if (element.placeholder && key) {
                element.placeholder = text;
            } else if (key === 'no_account_text') {
                const linkText = lang['register_link'];
                element.innerHTML = `${text} <a href="#" onclick="showRegister()">${linkText}</a>`;
            } else if (key === 'already_have_account_link') {
                element.innerHTML = `<a href="#" onclick="showLogin()">${text}</a>`;
            } else if (key === 'pause_button' && !gamePaused) {
                element.innerHTML = `⏸️ ${text}`;
            } else if (key === 'continue_button' && gamePaused) {
                 element.innerHTML = `▶️ ${text}`;
            }
            else if (key.endsWith('_button')) {
                element.innerHTML = text;
            }
            else {
                if (text) element.textContent = text;
            }
        });
        totalSnakeCoinsElement.textContent = `🪙 ${snakeCoins} ${translations[currentLanguage]['total_coins_display']}`;
        
        // Atualiza placeholder do campo de mensagem de suporte
        const supportMessageTextarea = document.getElementById('supportMessage');
        if (supportMessageTextarea) {
            supportMessageTextarea.placeholder = translations[currentLanguage]['placeholder_support_message'] || 'Descreva seu problema ou sugestão detalhadamente aqui...';
        }

        populateSkinSelector();
        selectDifficulty(currentDifficulty);
        selectMap(currentMap);
    }
    function toggleLanguageDropdown() { document.getElementById('languageDropdown').classList.toggle('show'); }
    function selectLanguage(lang) {
        currentLanguage = lang; localStorage.setItem('snakeGameLanguage', lang);
        const flagMap = { pt: 'BR', en: 'US', es: 'ES' }; const flagCode = flagMap[lang] || 'BR';
        document.getElementById('currentFlag').src = `https://flagsapi.com/${flagCode}/flat/64.png`;
        updateContent(); document.getElementById('languageDropdown').classList.remove('show');
    }
    window.addEventListener('click', function(event) { if (!event.target.closest('.language-selector')) { const dropdown = document.getElementById('languageDropdown'); if (dropdown.classList.contains('show')) { dropdown.classList.remove('show'); } } });
    document.getElementById('languageButton').addEventListener('click', toggleLanguageDropdown);
    document.querySelectorAll('.language-selector-option').forEach(option => { option.addEventListener('click', function() { selectLanguage(this.dataset.lang); }); });
    
    function selectDifficulty(difficulty) {
        currentDifficulty = difficulty; document.querySelectorAll('.difficulty-selection .difficulty-btn').forEach(btn => btn.classList.remove('selected'));
        document.querySelector(`.difficulty-selection .difficulty-btn.${difficulty}`).classList.add('selected');
        difficultyInfo.textContent = difficulties[difficulty]['description_' + currentLanguage];
    }

    function selectMap(map) {
        currentMap = map; 
        document.querySelectorAll('.map-selection .difficulty-btn').forEach(btn => btn.classList.remove('selected'));
        document.querySelector(`.map-selection .difficulty-btn[onclick*="'${map}'"]`).classList.add('selected');
        mapInfo.textContent = maps[map]['description_' + currentLanguage];
        userHighScoreDisplay.textContent = userHighScoresPerMap[currentMap] || 0;
        updateLeaderboardDisplay();
    }
    function randomTile() { return Math.floor(Math.random() * tileCount); }
    function generateFood() { food = { x: randomTile(), y: randomTile() }; for (let segment of snake) { if (segment.x === food.x && segment.y === food.y) { generateFood(); return; } } }
    
    function queueDirection(newDx, newDy) {
        if (!gameRunning || !gameStarted) return;
        let lastDirection = { dx: dx, dy: dy };
        if (inputQueue.length > 0) {
            lastDirection = inputQueue[inputQueue.length - 1];
        }
        if ((newDx !== 0 && newDx === -lastDirection.dx) || (newDy !== 0 && newDy === -lastDirection.dy)) {
            return;
        }
        if (inputQueue.length < 2) {
            inputQueue.push({ dx: newDx, dy: newDy });
        }
    }

    function processInput() {
        if (gamePaused || !gameRunning || inputQueue.length === 0) {
            return;
        }
        const nextMove = inputQueue.shift();
        if ((nextMove.dx !== 0 && nextMove.dx === -dx) || (nextMove.dy !== 0 && nextMove.dy === -dy)) {
            return;
        }
        dx = nextMove.dx;
        dy = nextMove.dy;
    }

    function handleCanvasInteraction(e) {
        if (!gameRunning || gamePaused || joystickType === 'floating' || !gameStarted) {
            return;
        }
        e.preventDefault();
        if (dx === 0 && dy === 0) return;
        const rect = canvas.getBoundingClientRect();
        const touch = e.type === 'touchstart' ? e.touches[0] : e;
        const tapX = touch.clientX - rect.left;
        const tapY = touch.clientY - rect.top;
        const headCanvasX = snake[0].x * gridSize + (gridSize / 2);
        const headCanvasY = snake[0].y * gridSize + (gridSize / 2);
        const deltaX = tapX - headCanvasX;
        const deltaY = tapY - headCanvasY;
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
            queueDirection(deltaX > 0 ? 1 : -1, 0);
        } else {
            queueDirection(0, deltaY > 0 ? 1 : -1);
        }
    }
    
    // ==================================================================
    // FUNÇÃO DO VISUALIZADOR DE SKINS
    // ==================================================================
    function drawSkinPreview(skinKey) {
    if (!previewCtx) return;

    const previewGridSize = 20;
    const previewCanvasWidth = skinPreviewCanvas.width;
    const previewCanvasHeight = skinPreviewCanvas.height;

    previewCtx.clearRect(0, 0, previewCanvasWidth, previewCanvasHeight);
    previewCtx.fillStyle = '#11131e';
    previewCtx.fillRect(0, 0, previewCanvasWidth, previewCanvasHeight);

    const previewSnake = [
        { x: 4, y: 1 }, { x: 3, y: 1 }, { x: 2, y: 1 }, { x: 1, y: 1 }, { x: 0, y: 1 }
    ];
    const offsetX = 10;
    const skinOptions = skins[skinKey] || skins['default'];
    
    // Helper da teia da aranha
    const drawPreviewWebPattern = (x, y) => {
        previewCtx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
        previewCtx.lineWidth = 1;
        previewCtx.beginPath();
        previewCtx.moveTo(x + previewGridSize / 3, y);
        previewCtx.lineTo(x + previewGridSize / 3, y + previewGridSize);
        previewCtx.moveTo(x + (previewGridSize / 3) * 2, y);
        previewCtx.lineTo(x + (previewGridSize / 3) * 2, y + previewGridSize);
        previewCtx.moveTo(x, y + previewGridSize / 3);
        previewCtx.lineTo(x + previewGridSize, y + previewGridSize / 3);
        previewCtx.moveTo(x, y + (previewGridSize / 3) * 2);
        previewCtx.lineTo(x + previewGridSize, y + (previewGridSize / 3) * 2);
        previewCtx.stroke();
    };

    // --- DESENHO DE CADA SEGMENTO, SKIN POR SKIN ---
    // Loop de trás para frente para facilitar a lógica de alguns desenhos
    for (let i = previewSnake.length - 1; i >= 0; i--) {
        const segment = previewSnake[i];
        const segmentX = segment.x * previewGridSize + offsetX;
        const segmentY = segment.y * previewGridSize;
        const isHead = (i === 0);

        if (skinKey === 'default' || skinKey === 'custom') {
            let color;
            if (isHead) {
                color = (skinKey === 'custom') ? shadeColor(document.getElementById('snakeColorPicker').value, -20) : skinOptions.headColor;
            } else {
                color = (skinKey === 'custom') ? document.getElementById('snakeColorPicker').value : skinOptions.bodyColor;
            }
            previewCtx.fillStyle = color;
            previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
        
        } else if (skinKey === 'pharaoh') {
            const goldColor = '#FFD700', blueColor = '#00008B';
            if (isHead) {
                const eyeWhiteColor = '#FFFFFF', eyePupilColor = '#000000';
                previewCtx.save();
                previewCtx.translate(segmentX + previewGridSize / 2, segmentY + previewGridSize / 2);
                previewCtx.rotate(Math.PI / 2);
                const halfGrid = previewGridSize / 2;
                previewCtx.fillStyle = blueColor; previewCtx.fillRect(-halfGrid, -halfGrid, previewGridSize, previewGridSize);
                previewCtx.fillStyle = goldColor; previewCtx.fillRect(-halfGrid, -halfGrid, previewGridSize, halfGrid * 0.2);
                previewCtx.fillRect(-halfGrid, -halfGrid * 0.2, previewGridSize, halfGrid * 0.2);
                previewCtx.fillRect(-halfGrid, halfGrid * 0.6, previewGridSize, halfGrid * 0.2);
                previewCtx.fillStyle = goldColor; previewCtx.fillRect(-halfGrid * 0.6, -halfGrid * 0.8, halfGrid * 1.2, halfGrid * 0.8);
                const eyeY = -halfGrid * 0.5, eyeX = -halfGrid * 0.2;
                previewCtx.fillStyle = eyeWhiteColor; previewCtx.fillRect(eyeX - (previewGridSize * 0.2), eyeY, previewGridSize * 0.4, previewGridSize * 0.2);
                previewCtx.fillRect(-eyeX - (previewGridSize * 0.2), eyeY, previewGridSize * 0.4, previewGridSize * 0.2);
                previewCtx.fillStyle = eyePupilColor; previewCtx.fillRect(eyeX - (previewGridSize * 0.05), eyeY, previewGridSize * 0.1, previewGridSize * 0.2);
                previewCtx.fillRect(-eyeX - (previewGridSize * 0.05), eyeY, previewGridSize * 0.1, previewGridSize * 0.2);
                const beardYStart = halfGrid * 0.1; const beardHeight = halfGrid * 0.8;
                previewCtx.fillStyle = blueColor; previewCtx.fillRect(-previewGridSize * 0.15, beardYStart, previewGridSize * 0.3, beardHeight);
                previewCtx.fillStyle = goldColor;
                for (let j = 0; j < 3; j++) { previewCtx.fillRect(-previewGridSize * 0.15, beardYStart + (j * 0.3) * beardHeight, previewGridSize * 0.3, beardHeight * 0.15); }
                previewCtx.restore();
            } else {
                const prevSegment = previewSnake[i - 1];
                const segmentDx = segment.x - prevSegment.x;
                const halfGridSize = previewGridSize / 2;
                if (segmentDx === 1) { // Lógica para corpo movendo para a direita
                    previewCtx.fillStyle = goldColor; previewCtx.fillRect(segmentX, segmentY, previewGridSize, halfGridSize);
                    previewCtx.fillStyle = blueColor; previewCtx.fillRect(segmentX, segmentY + halfGridSize, previewGridSize, halfGridSize);
                } else { // Lógica para corpo movendo para a esquerda (preview)
                    previewCtx.fillStyle = blueColor; previewCtx.fillRect(segmentX, segmentY, previewGridSize, halfGridSize);
                    previewCtx.fillStyle = goldColor; previewCtx.fillRect(segmentX, segmentY + halfGridSize, previewGridSize, halfGridSize);
                }
                if (i % 2 === 0) {
                    const dotSize = 1;
                    previewCtx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                    previewCtx.fillRect(segmentX + previewGridSize * 0.2, segmentY + previewGridSize * 0.2, dotSize, dotSize);
                    previewCtx.fillRect(segmentX + previewGridSize * 0.7, segmentY + previewGridSize * 0.8, dotSize, dotSize);
                    previewCtx.fillStyle = 'rgba(0, 0, 139, 0.8)';
                    previewCtx.fillRect(segmentX + previewGridSize * 0.8, segmentY + previewGridSize * 0.3, dotSize, dotSize);
                    previewCtx.fillRect(segmentX + previewGridSize * 0.3, segmentY + previewGridSize * 0.7, dotSize, dotSize);
                }
            }
        } else if (skinKey === 'spider') {
            if (isHead) {
                previewCtx.fillStyle = skinOptions.redColor;
                previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                drawPreviewWebPattern(segmentX, segmentY);
                const eyeXOffset = previewGridSize * 0.2, eyeYOffset = previewGridSize * 0.2;
                const eyeWidth = previewGridSize * 0.25, eyeHeight = previewGridSize * 0.5;
                previewCtx.fillStyle = 'white';
                previewCtx.fillRect(segmentX + eyeXOffset, segmentY + eyeYOffset, eyeWidth, eyeHeight);
                previewCtx.fillRect(segmentX + previewGridSize - 2 - eyeXOffset - eyeWidth, segmentY + eyeYOffset, eyeWidth, eyeHeight);
                previewCtx.strokeStyle = 'black';
                previewCtx.lineWidth = 1.5;
                previewCtx.strokeRect(segmentX + eyeXOffset, segmentY + eyeYOffset, eyeWidth, eyeHeight);
                previewCtx.strokeRect(segmentX + previewGridSize - 2 - eyeXOffset - eyeWidth, segmentY + eyeYOffset, eyeWidth, eyeHeight);
            } else {
                const isRedSegment = i % 2 === 0;
                previewCtx.fillStyle = isRedSegment ? skinOptions.redColor : skinOptions.blueColor;
                previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                if (isRedSegment) drawPreviewWebPattern(segmentX, segmentY);
            }
        } else if (skinKey === 'coral') {
            const coralColors = skinOptions.colors;
            if (isHead) {
                previewCtx.fillStyle = coralColors[1]; // Preto
                previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
                const mouthSize = Math.max(2, Math.floor(previewGridSize / 6));
                previewCtx.fillStyle = coralColors[2]; // Branco
                previewCtx.fillRect(segmentX + previewGridSize - 2 - mouthSize, segmentY + mouthSize, mouthSize, previewGridSize - 2 - (2 * mouthSize));
            } else {
                const patternIndex = (i - 1) % 4;
                const halfSize = (previewGridSize - 2) / 2;
                switch (patternIndex) {
                    case 0: previewCtx.fillStyle = coralColors[0]; previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2); break;
                    case 1: case 2: // Para o preview horizontal, a cobra "desce" visualmente
                        previewCtx.fillStyle = coralColors[2]; previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, halfSize);
                        previewCtx.fillStyle = coralColors[1]; previewCtx.fillRect(segmentX, segmentY + halfSize, previewGridSize - 2, halfSize);
                        break;
                    case 3: previewCtx.fillStyle = coralColors[1]; previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2); break;
                }
            }
        } else if (skinKey === 'circuit') {
            previewCtx.fillStyle = isHead ? skinOptions.headColor : skinOptions.bodyColor;
            previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
            if (!isHead) {
                previewCtx.strokeStyle = '#000000'; previewCtx.lineWidth = 1;
                previewCtx.beginPath();
                previewCtx.moveTo(segmentX + 2, segmentY + previewGridSize / 2);
                previewCtx.lineTo(segmentX + previewGridSize - 4, segmentY + previewGridSize / 2);
                previewCtx.moveTo(segmentX + previewGridSize / 2, segmentY + 2);
                previewCtx.lineTo(segmentX + previewGridSize / 2, segmentY + previewGridSize - 4);
                previewCtx.stroke();
            }
        } else if (skinKey === 'galaxy') {
            previewCtx.fillStyle = isHead ? skinOptions.headColor : skinOptions.colors[i % skinOptions.colors.length];
            previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
            previewCtx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            previewCtx.fillRect(segmentX + Math.random() * (previewGridSize-2), segmentY + Math.random() * (previewGridSize-2), isHead ? 1.5 : 1, isHead ? 1.5 : 1);
        } else if (skinKey === 'camo' || skinKey === 'christmas') {
            if (isHead) {
                previewCtx.fillStyle = skinOptions.headColor;
            } else {
                previewCtx.fillStyle = skinOptions.colors[i % skinOptions.colors.length];
            }
            previewCtx.fillRect(segmentX, segmentY, previewGridSize - 2, previewGridSize - 2);
            
            if (!isHead && skinKey === 'christmas' && i % 2 === 0) {
                 previewCtx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                 previewCtx.fillRect(segmentX, segmentY + previewGridSize / 3, previewGridSize - 2, previewGridSize / 3);
            }
        } else if (skinKey === 'halloween') {
            const pumpkinColor = skinOptions.headColor;
            const bodyBlack = skinOptions.bodyColor1;
            const bodyPurple = skinOptions.bodyColor2;
            const lineOrange = skinOptions.lineColor;

            if (isHead) {
                // Cabeça de abóbora
                previewCtx.fillStyle = pumpkinColor;
                previewCtx.fillRect(segmentX, segmentY, previewGridSize, previewGridSize);

                // Rosto entalhado (preto)
                previewCtx.fillStyle = '#000000';
                const pg_half = previewGridSize / 2;
                
                // Olho esquerdo (triângulo)
                previewCtx.beginPath();
                previewCtx.moveTo(segmentX + previewGridSize * 0.2, segmentY + previewGridSize * 0.2);
                previewCtx.lineTo(segmentX + previewGridSize * 0.4, segmentY + previewGridSize * 0.4);
                previewCtx.lineTo(segmentX + previewGridSize * 0.2, segmentY + previewGridSize * 0.4);
                previewCtx.closePath();
                previewCtx.fill();
                
                // Olho direito (triângulo)
                previewCtx.beginPath();
                previewCtx.moveTo(segmentX + previewGridSize * 0.8, segmentY + previewGridSize * 0.2);
                previewCtx.lineTo(segmentX + previewGridSize * 0.6, segmentY + previewGridSize * 0.4);
                previewCtx.lineTo(segmentX + previewGridSize * 0.8, segmentY + previewGridSize * 0.4);
                previewCtx.closePath();
                previewCtx.fill();
                
                // Nariz (triângulo)
                previewCtx.beginPath();
                previewCtx.moveTo(segmentX + pg_half, segmentY + pg_half - (pg_half * 0.1));
                previewCtx.lineTo(segmentX + pg_half - (pg_half * 0.2), segmentY + pg_half + (pg_half * 0.2));
                previewCtx.lineTo(segmentX + pg_half + (pg_half * 0.2), segmentY + pg_half + (pg_half * 0.2));
                previewCtx.closePath();
                previewCtx.fill();

                // Boca Sorridente
                const mouthY_abs = segmentY + pg_half + (pg_half * 0.4);
                previewCtx.fillRect(segmentX + pg_half - (pg_half * 0.8), mouthY_abs, pg_half * 1.6, pg_half * 0.2); // Linha principal
                previewCtx.fillRect(segmentX + pg_half - (pg_half * 0.5), mouthY_abs - (pg_half * 0.2), pg_half * 0.2, pg_half * 0.2); // Dente 1
                previewCtx.fillRect(segmentX + pg_half + (pg_half * 0.3), mouthY_abs - (pg_half * 0.2), pg_half * 0.2, pg_half * 0.2); // Dente 2
            } else {
                // Desenha a borda interna primeiro
                previewCtx.fillStyle = bodyPurple; // Borda superior/esquerda
                previewCtx.fillRect(segmentX, segmentY, previewGridSize, previewGridSize);
                previewCtx.fillStyle = bodyBlack; // Borda inferior/direita
                previewCtx.fillRect(segmentX + 0, segmentY + 1, previewGridSize + 3, previewGridSize + 3);

                // Corpo: Metade preto, metade roxo com linha laranja (desenhado dentro da borda)
                const fillSize = previewGridSize - 2;
                const fillX = segmentX + 1;
                const fillY = segmentY + 1;
                const halfFillSize = fillSize / 2;
                const lineSize = 2;

                // Metade preta (superior)
                previewCtx.fillStyle = bodyBlack;
                previewCtx.fillRect(fillX, fillY, fillSize, halfFillSize - (lineSize/2));

                // Metade roxa (inferior)
                previewCtx.fillStyle = bodyPurple;
                previewCtx.fillRect(fillX, fillY + halfFillSize + (lineSize/2), fillSize, halfFillSize - (lineSize/2));

                // Linha laranja no meio
                previewCtx.fillStyle = lineOrange;
                previewCtx.fillRect(fillX, fillY + halfFillSize - (lineSize/2), fillSize, lineSize);
            }
        }
    }
    // PASS 2 for preview: Draw connectors
    if (skinKey === 'halloween') {
        const lineOrange = skins.halloween.lineColor;
        const bodyBlack = skins.halloween.bodyColor1;
        const bodyPurple = skins.halloween.bodyColor2;
        const lineSize = 2;

        for (let i = 1; i < previewSnake.length; i++) {
             // Preview é sempre horizontal, então o conector é sempre vertical
            const curr = previewSnake[i];
            const connX = (curr.x * previewGridSize) + offsetX - 1;
            const connY = curr.y * previewGridSize + 1;
            const connW = 2;
            const connH = previewGridSize - 2;
            
            const halfSize = connH / 2;
            previewCtx.fillStyle = bodyBlack;
            previewCtx.fillRect(connX, connY, connW, halfSize - lineSize / 2);
            previewCtx.fillStyle = bodyPurple;
            previewCtx.fillRect(connX, connY + halfSize + lineSize / 2, connW, halfSize - lineSize / 2);
            previewCtx.fillStyle = lineOrange;
            previewCtx.fillRect(connX, connY + halfSize - lineSize / 2, connW, lineSize);
        }
    }
}

    function drawGame() {
        ctx.fillStyle = '#11131e';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        const skinOptions = skins[currentSkin] || skins['default'];

        const drawWebPattern = (x, y) => {
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.5)';
            ctx.lineWidth = 1;
            ctx.beginPath();
            ctx.moveTo(x + gridSize / 3, y);
            ctx.lineTo(x + gridSize / 3, y + gridSize);
            ctx.moveTo(x + (gridSize / 3) * 2, y);
            ctx.lineTo(x + (gridSize / 3) * 2, y + gridSize);
            ctx.moveTo(x, y + gridSize / 3);
            ctx.lineTo(x + gridSize, y + gridSize / 3);
            ctx.moveTo(x, y + (gridSize / 3) * 2);
            ctx.lineTo(x + gridSize, y + (gridSize / 3) * 2);
            ctx.stroke();
        };

        if (currentSkin === 'spider') {
            const redColor = skinOptions.redColor;
            const blueColor = skinOptions.blueColor;

            for (let i = snake.length - 1; i > 0; i--) {
                const segment = snake[i];
                const segmentX = segment.x * gridSize;
                const segmentY = segment.y * gridSize;
                
                const isRedSegment = i % 2 === 0;
                ctx.fillStyle = isRedSegment ? redColor : blueColor;
                ctx.fillRect(segmentX, segmentY, gridSize - 2, gridSize - 2);

                if (isRedSegment) {
                    drawWebPattern(segmentX, segmentY);
                }
            }

            const head = snake[0];
            const headX = head.x * gridSize;
            const headY = head.y * gridSize;
            ctx.fillStyle = redColor;
            ctx.fillRect(headX, headY, gridSize - 2, gridSize - 2);
            drawWebPattern(headX, headY);

            const eyeXOffset = gridSize * 0.2;
            const eyeYOffset = gridSize * 0.2;
            const eyeWidth = gridSize * 0.25;
            const eyeHeight = gridSize * 0.5;
            
            ctx.fillStyle = 'white';
            ctx.fillRect(headX + eyeXOffset, headY + eyeYOffset, eyeWidth, eyeHeight);
            ctx.fillRect(headX + gridSize - eyeXOffset - eyeWidth - 2, headY + eyeYOffset, eyeWidth, eyeHeight);

            ctx.strokeStyle = 'black';
            ctx.lineWidth = 1.5;
            ctx.strokeRect(headX + eyeXOffset, headY + eyeYOffset, eyeWidth, eyeHeight);
            ctx.strokeRect(headX + gridSize - eyeXOffset - eyeWidth - 2, headY + eyeYOffset, eyeWidth, eyeHeight);
        } else if (currentSkin === 'coral') {
            const coralColors = skinOptions.colors;
            
            for (let i = snake.length - 1; i > 0; i--) { 
                const segment = snake[i];
                const prevSegment = snake[i - 1];
                const segmentX = segment.x * gridSize;
                const segmentY = segment.y * gridSize;
                const patternIndex = (i - 1) % 4;

                switch (patternIndex) {
                    case 0:
                        ctx.fillStyle = coralColors[0];
                        ctx.fillRect(segmentX, segmentY, gridSize - 2, gridSize - 2);
                        break;
                    case 1:
                    case 2:
                        const halfSize = (gridSize - 2) / 2;
                        const segmentDx = prevSegment.x - segment.x;
                        const segmentDy = prevSegment.y - segment.y;

                        if (segmentDy === -1) {
                            ctx.fillStyle = coralColors[1];
                            ctx.fillRect(segmentX, segmentY, gridSize - 2, halfSize);
                            ctx.fillStyle = coralColors[2];
                            ctx.fillRect(segmentX, segmentY + halfSize, gridSize - 2, halfSize);
                        } else if (segmentDy === 1) {
                            ctx.fillStyle = coralColors[2];
                            ctx.fillRect(segmentX, segmentY, gridSize - 2, halfSize);
                            ctx.fillStyle = coralColors[1];
                            ctx.fillRect(segmentX, segmentY + halfSize, gridSize - 2, halfSize);
                        } else if (segmentDx === -1) {
                            ctx.fillStyle = coralColors[1];
                            ctx.fillRect(segmentX, segmentY, halfSize, gridSize - 2);
                            ctx.fillStyle = coralColors[2];
                            ctx.fillRect(segmentX + halfSize, segmentY, halfSize, gridSize - 2);
                        } else if (segmentDx === 1) {
                            ctx.fillStyle = coralColors[2];
                            ctx.fillRect(segmentX, segmentY, halfSize, gridSize - 2);
                            ctx.fillStyle = coralColors[1];
                            ctx.fillRect(segmentX + halfSize, segmentY, halfSize, gridSize - 2);
                        } else {
                            ctx.fillStyle = coralColors[1];
                            ctx.fillRect(segmentX, segmentY, halfSize, gridSize - 2);
                            ctx.fillStyle = coralColors[2];
                            ctx.fillRect(segmentX + halfSize, segmentY, halfSize, gridSize - 2);
                        }
                        break;
                    case 3:
                        ctx.fillStyle = coralColors[1];
                        ctx.fillRect(segmentX, segmentY, gridSize - 2, gridSize - 2);
                        break;
                }
            }

            const head = snake[0];
            const headX = head.x * gridSize;
            const headY = head.y * gridSize;
            
            ctx.fillStyle = coralColors[1];
            ctx.fillRect(headX, headY, gridSize - 2, gridSize - 2);

            ctx.fillStyle = coralColors[2];
            const mouthSize = Math.max(2, Math.floor(gridSize / 6));

            if (dy === -1) {
                ctx.fillRect(headX + mouthSize, headY, gridSize - 2 - (2 * mouthSize), mouthSize);
            } else if (dy === 1) {
                ctx.fillRect(headX + mouthSize, headY + gridSize - 2 - mouthSize, gridSize - 2 - (2 * mouthSize), mouthSize);
            } else if (dx === -1) {
                ctx.fillRect(headX, headY + mouthSize, mouthSize, gridSize - 2 - (2 * mouthSize));
            } else {
                ctx.fillRect(headX + gridSize - 2 - mouthSize, headY + mouthSize, mouthSize, gridSize - 2 - (2 * mouthSize));
            }
        } else if (currentSkin === 'pharaoh') {
            const goldColor = '#FFD700';
            const blueColor = '#00008B';
            const eyeWhiteColor = '#FFFFFF';
            const eyePupilColor = '#000000';

            for (let i = 1; i < snake.length; i++) {
                const segment = snake[i];
                const prevSegment = snake[i-1];
                const segmentX = segment.x * gridSize;
                const segmentY = segment.y * gridSize;
                const segmentDx = segment.x - prevSegment.x;
                const segmentDy = segment.y - prevSegment.y;
                const halfGridSize = gridSize / 2;

                if (segmentDy === 1) {
                    ctx.fillStyle = blueColor;
                    ctx.fillRect(segmentX, segmentY, halfGridSize, gridSize);
                    ctx.fillStyle = goldColor;
                    ctx.fillRect(segmentX + halfGridSize, segmentY, halfGridSize, gridSize);
                } else if (segmentDy === -1) {
                    ctx.fillStyle = goldColor;
                    ctx.fillRect(segmentX, segmentY, halfGridSize, gridSize);
                    ctx.fillStyle = blueColor;
                    ctx.fillRect(segmentX + halfGridSize, segmentY, halfGridSize, gridSize);
                } else if (segmentDx === 1) {
                    ctx.fillStyle = goldColor;
                    ctx.fillRect(segmentX, segmentY, gridSize, halfGridSize);
                    ctx.fillStyle = blueColor;
                    ctx.fillRect(segmentX, segmentY + halfGridSize, gridSize, halfGridSize);
                } else if (segmentDx === -1) {
                    ctx.fillStyle = blueColor;
                    ctx.fillRect(segmentX, segmentY, gridSize, halfGridSize);
                    ctx.fillStyle = goldColor;
                    ctx.fillRect(segmentX, segmentY + halfGridSize, gridSize, halfGridSize);
                } else {
                    ctx.fillStyle = blueColor;
                    ctx.fillRect(segmentX, segmentY, halfGridSize, gridSize);
                    ctx.fillStyle = goldColor;
                    ctx.fillRect(segmentX + halfGridSize, segmentY, halfGridSize, gridSize);
                }

                if (i % 2 === 0) {
                    const dotSize = 1;
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.8)';
                    ctx.fillRect(segmentX + gridSize * 0.2, segmentY + gridSize * 0.2, dotSize, dotSize);
                    ctx.fillRect(segmentX + gridSize * 0.7, segmentY + gridSize * 0.8, dotSize, dotSize);
                    ctx.fillStyle = 'rgba(0, 0, 139, 0.8)';
                    ctx.fillRect(segmentX + gridSize * 0.8, segmentY + gridSize * 0.3, dotSize, dotSize);
                    ctx.fillRect(segmentX + gridSize * 0.3, segmentY + gridSize * 0.7, dotSize, dotSize);
                }
            }

            const head = snake[0];
            const headX = head.x * gridSize;
            const headY = head.y * gridSize;
            ctx.save();
            ctx.translate(headX + gridSize / 2, headY + gridSize / 2);

            let rotation = 0;
            if (dx === 1) {
                rotation = Math.PI / 2;
            } else if (dx === -1) {
                rotation = -Math.PI / 2;
            } else if (dy === 1) {
                rotation = Math.PI;
            }

            ctx.rotate(rotation);
            const halfGrid = gridSize / 2;
            ctx.fillStyle = blueColor;
            ctx.fillRect(-halfGrid, -halfGrid, gridSize, gridSize);
            ctx.fillStyle = goldColor;
            ctx.fillRect(-halfGrid, -halfGrid, gridSize, gridSize * 0.2);
            ctx.fillRect(-halfGrid, -halfGrid * 0.2, gridSize, gridSize * 0.2);
            ctx.fillRect(-halfGrid, halfGrid * 0.6, gridSize, gridSize * 0.2);
            ctx.fillStyle = goldColor;
            ctx.fillRect(-halfGrid * 0.6, -halfGrid * 0.8, gridSize * 0.6, gridSize * 0.8);
            const eyeY = -halfGrid * 0.5;
            const eyeX = -halfGrid * 0.2;
            ctx.fillStyle = eyeWhiteColor;
            ctx.fillRect(eyeX - (gridSize * 0.2), eyeY, gridSize * 0.4, gridSize * 0.2);
            ctx.fillRect(-eyeX - (gridSize * 0.2), eyeY, gridSize * 0.4, gridSize * 0.2);
            ctx.fillStyle = eyePupilColor;
            ctx.fillRect(eyeX - (gridSize * 0.05), eyeY, gridSize * 0.1, gridSize * 0.2);
            ctx.fillRect(-eyeX - (gridSize * 0.05), eyeY, gridSize * 0.1, gridSize * 0.2);
            const beardYStart = halfGrid * 0.1;
            const beardHeight = halfGrid * 0.8;
            ctx.fillStyle = blueColor;
            ctx.fillRect(-gridSize * 0.15, beardYStart, gridSize * 0.3, beardHeight);
            ctx.fillStyle = goldColor;
            for (let i = 0; i < 3; i++) {
                ctx.fillRect(-gridSize * 0.15, beardYStart + (i * 0.3) * beardHeight, gridSize * 0.3, beardHeight * 0.15);
            }
            ctx.restore();
        } else if (currentSkin === 'galaxy') {
            const galaxyColors = skinOptions.colors;
            const headColor = skinOptions.headColor;

            for (let i = 1; i < snake.length; i++) {
                const segment = snake[i];
                ctx.fillStyle = galaxyColors[i % galaxyColors.length];
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
                
                ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
                ctx.fillRect(segment.x * gridSize + Math.random() * gridSize, segment.y * gridSize + Math.random() * gridSize, 1, 1);
                ctx.fillRect(segment.x * gridSize + Math.random() * gridSize, segment.y * gridSize + Math.random() * gridSize, 1, 1);
            }
            ctx.fillStyle = headColor;
            ctx.fillRect(snake[0].x * gridSize, snake[0].y * gridSize, gridSize - 2, gridSize - 2);
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.fillRect(snake[0].x * gridSize + Math.random() * gridSize, snake[0].y * gridSize + Math.random() * gridSize, 1.5, 1.5);

        } else if (currentSkin === 'circuit') {
            const bodyColor = skinOptions.bodyColor;
            const headColor = skinOptions.headColor;
            
            for (let i = 1; i < snake.length; i++) {
                ctx.fillStyle = bodyColor;
                ctx.fillRect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize - 2, gridSize - 2);
                
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(snake[i].x * gridSize + 2, snake[i].y * gridSize + gridSize / 2);
                ctx.lineTo(snake[i].x * gridSize + gridSize - 4, snake[i].y * gridSize + gridSize / 2);
                ctx.moveTo(snake[i].x * gridSize + gridSize / 2, snake[i].y * gridSize + 2);
                ctx.lineTo(snake[i].x * gridSize + gridSize / 2, snake[i].y * gridSize + gridSize - 4);
                ctx.stroke();
            }
            ctx.fillStyle = headColor;
            ctx.fillRect(snake[0].x * gridSize, snake[0].y * gridSize, gridSize - 2, gridSize - 2);

        } else if (currentSkin === 'camo') {
            const camoColors = skinOptions.colors;
            const headColor = skinOptions.headColor;
            
            for (let i = 1; i < snake.length; i++) {
                const segment = snake[i];
                ctx.fillStyle = camoColors[i % camoColors.length];
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
            }
            ctx.fillStyle = headColor;
            ctx.fillRect(snake[0].x * gridSize, snake[0].y * gridSize, gridSize - 2, gridSize - 2);

        } else if (currentSkin === 'halloween') {
            const pumpkinColor = skinOptions.headColor;
            const bodyBlack = skinOptions.bodyColor1;
            const bodyPurple = skinOptions.bodyColor2;
            const lineOrange = skinOptions.lineColor;
            
            // PASS 1: Desenha todos os segmentos do corpo com suas bordas
            for (let i = 1; i < snake.length; i++) {
                const segment = snake[i];
                const segX = segment.x * gridSize;
                const segY = segment.y * gridSize;

                // Desenha o fundo do segmento que servirá de borda
                ctx.fillStyle = bodyPurple;
                ctx.fillRect(segX, segY, gridSize, gridSize);
                ctx.fillStyle = bodyBlack;
                ctx.fillRect(segX + 1, segY + 1, gridSize - 2, gridSize - 2);

                // Define a área de preenchimento interna
                const fillX = segX + 1;
                const fillY = segY + 1;
                const fillSize = gridSize - 2;
                const halfFillSize = fillSize / 2;
                const lineSize = 2;
                
                const prevSegment = snake[i-1];
                const segmentDx = segment.x - prevSegment.x;

                // Desenha o conteúdo dentro da borda
                if (segmentDx === 0) { // Movimento vertical
                    ctx.fillStyle = bodyBlack;
                    ctx.fillRect(fillX, fillY, halfFillSize - lineSize / 2, fillSize);
                    ctx.fillStyle = bodyPurple;
                    ctx.fillRect(fillX + halfFillSize + lineSize / 2, fillY, halfFillSize - lineSize / 2, fillSize);
                    ctx.fillStyle = lineOrange;
                    ctx.fillRect(fillX + halfFillSize - lineSize / 2, fillY, lineSize, fillSize);
                } else { // Movimento horizontal
                    ctx.fillStyle = bodyBlack;
                    ctx.fillRect(fillX, fillY, fillSize, halfFillSize - lineSize / 2);
                    ctx.fillStyle = bodyPurple;
                    ctx.fillRect(fillX, fillY + halfFillSize + lineSize / 2, fillSize, halfFillSize - lineSize / 2);
                    ctx.fillStyle = lineOrange;
                    ctx.fillRect(fillX, fillY + halfFillSize - lineSize / 2, fillSize, lineSize);
                }
            }
            
            // PASS 2: Desenha os conectores para criar a fluidez
            for (let i = 1; i < snake.length; i++) {
                 const curr = snake[i];
                 const prev = snake[i-1];
                 
                 const lineSize = 2;
                 let connX, connY, connW, connH, isHorizontal;
                 
                 if (curr.x === prev.x) { // Movimento Vertical
                    isHorizontal = false;
                    connW = gridSize - 2;
                    connH = 2;
                    connX = curr.x * gridSize + 1;
                    connY = (curr.y > prev.y) ? curr.y * gridSize - 1 : prev.y * gridSize -1;
                 } else { // Movimento Horizontal
                    isHorizontal = true;
                    connW = 2;
                    connH = gridSize - 2;
                    connY = curr.y * gridSize + 1;
                    connX = (curr.x > prev.x) ? curr.x * gridSize - 1 : prev.x * gridSize - 1;
                 }
                 
                if (isHorizontal) {
                    const halfSize = connH / 2;
                    ctx.fillStyle = bodyBlack;
                    ctx.fillRect(connX, connY, connW, halfSize - lineSize / 2);
                    ctx.fillStyle = bodyPurple;
                    ctx.fillRect(connX, connY + halfSize + lineSize / 2, connW, halfSize - lineSize / 2);
                    ctx.fillStyle = lineOrange;
                    ctx.fillRect(connX, connY + halfSize - lineSize / 2, connW, lineSize);
                } else {
                    const halfSize = connW / 2;
                    ctx.fillStyle = bodyBlack;
                    ctx.fillRect(connX, connY, halfSize - lineSize / 2, connH);
                    ctx.fillStyle = bodyPurple;
                    ctx.fillRect(connX + halfSize + lineSize / 2, connY, halfSize - lineSize / 2, connH);
                    ctx.fillStyle = lineOrange;
                    ctx.fillRect(connX + halfSize - lineSize / 2, connY, lineSize, connH);
                }
            }


            // Desenha a cabeça por último para ficar por cima de tudo
            const head = snake[0];
            const headX = head.x * gridSize;
            const headY = head.y * gridSize;
            
            ctx.fillStyle = pumpkinColor;
            ctx.fillRect(headX, headY, gridSize, gridSize);

            // Usa save/restore e rotate para orientar o rosto corretamente
            ctx.save();
            ctx.translate(headX + gridSize / 2, headY + gridSize / 2);

            let rotation = 0;
            if (dx === 1) { rotation = Math.PI / 2; }      // Direita
            else if (dx === -1) { rotation = -Math.PI / 2; }// Esquerda
            else if (dy === 1) { rotation = Math.PI; }     // Baixo
            ctx.rotate(rotation);

            // Desenha o rosto relativo ao centro da cabeça
            const halfGrid = gridSize / 2;
            ctx.fillStyle = '#000000';
            
            // Olho 1 (triângulo)
            ctx.beginPath();
            ctx.moveTo(-halfGrid * 0.6, -halfGrid * 0.6);
            ctx.lineTo(-halfGrid * 0.2, -halfGrid * 0.2);
            ctx.lineTo(-halfGrid * 0.6, -halfGrid * 0.2);
            ctx.closePath();
            ctx.fill();
            
            // Olho 2 (triângulo)
            ctx.beginPath();
            ctx.moveTo(halfGrid * 0.6, -halfGrid * 0.6);
            ctx.lineTo(halfGrid * 0.2, -halfGrid * 0.2);
            ctx.lineTo(halfGrid * 0.6, -halfGrid * 0.2);
            ctx.closePath();
            ctx.fill();

            // Nariz (triângulo)
            ctx.beginPath();
            ctx.moveTo(0, -halfGrid * 0.1); // Ponto de cima
            ctx.lineTo(-halfGrid * 0.2, halfGrid * 0.2); // Ponto de baixo-esquerda
            ctx.lineTo(halfGrid * 0.2, halfGrid * 0.2); // Ponto de baixo-direita
            ctx.closePath();
            ctx.fill();

            // Boca Sorridente
            const mouthY = halfGrid * 0.4;
            ctx.fillRect(-halfGrid * 0.8, mouthY, halfGrid * 1.6, halfGrid * 0.2); // Linha principal do sorriso
            ctx.fillRect(-halfGrid * 0.5, mouthY - halfGrid * 0.2, halfGrid * 0.2, halfGrid * 0.2); // Dente 1
            ctx.fillRect(halfGrid * 0.3, mouthY - halfGrid * 0.2, halfGrid * 0.2, halfGrid * 0.2); // Dente 2
            
            ctx.restore(); // Restaura o contexto do canvas

        } else if (currentSkin === 'christmas') {
            const christmasColors = skinOptions.colors;
            const headColor = skinOptions.headColor;

            for (let i = 1; i < snake.length; i++) {
                const segment = snake[i];
                ctx.fillStyle = christmasColors[i % christmasColors.length];
                ctx.fillRect(segment.x * gridSize, segment.y * gridSize, gridSize - 2, gridSize - 2);
                
                if (i % 2 === 0) {
                    ctx.fillStyle = 'rgba(255, 215, 0, 0.5)';
                    ctx.fillRect(segment.x * gridSize, segment.y * gridSize + gridSize / 3, gridSize - 2, gridSize / 3);
                }
            }
            ctx.fillStyle = headColor;
            ctx.fillRect(snake[0].x * gridSize, snake[0].y * gridSize, gridSize - 2, gridSize - 2);

        }
        else { // Default ou Custom
            let bodyColor, headColor;
            if (currentSkin === 'custom') {
                bodyColor = document.getElementById('snakeColorPicker').value;
                headColor = shadeColor(bodyColor, -20);
            } else {
                bodyColor = skinOptions.bodyColor;
                headColor = skinOptions.headColor;
            }
            
            ctx.fillStyle = bodyColor;
            for (let i = 1; i < snake.length; i++) {
                ctx.fillRect(snake[i].x * gridSize, snake[i].y * gridSize, gridSize - 2, gridSize - 2);
            }
            ctx.fillStyle = headColor;
            ctx.fillRect(snake[0].x * gridSize, snake[0].y * gridSize, gridSize - 2, gridSize - 2);
        }

        ctx.fillStyle = '#e17055';
        ctx.fillRect(food.x * gridSize, food.y * gridSize, gridSize - 2, gridSize - 2);
        ctx.fillStyle = '#fd79a8';
        ctx.fillRect(food.x * gridSize + 2, food.y * gridSize + 2, gridSize - 6, gridSize - 6);
    }
    
    function updateGame() {
        if (!gameRunning || gamePaused) return; if (dx === 0 && dy === 0) return;
        const head = {x: snake[0].x + dx, y: snake[0].y + dy};
        if (maps[currentMap].wrapAround) {
            if (head.x < 0) head.x = tileCount - 1; else if (head.x >= tileCount) head.x = 0;
            if (head.y < 0) head.y = tileCount - 1; else if (head.y >= tileCount) head.y = 0;
        } else { if (head.x < 0 || head.x >= tileCount || head.y < 0 || head.y >= tileCount) { gameOver(); return; } }
        for (let segment of snake) { if (head.x === segment.x && head.y === segment.y) { gameOver(); return; } }
        snake.unshift(head);
        if (head.x === food.x && head.y === food.y) {
            let foodPoints = difficulties[currentDifficulty].points;
            score += foodPoints;
            scoreElement.textContent = score;
            const newCoins = Math.floor(score / 75) - coinsEarnedThisGame;
            if (newCoins > 0) {
                coinsEarnedThisGame += newCoins;
            }
            generateFood();
        } else { snake.pop(); }
    }

    async function updateLeaderboardDisplay() {
        try {
            const difficultyEmojis = { easy: '🐌', normal: '🐍', hard: '🚀', insane: '💀' };
            const mapIdentifier = currentMap || 'normal';
            const user = auth.currentUser;
            const querySnapshot = await db.collection('scores').where('map', '==', mapIdentifier).orderBy('score', 'desc').limit(3).get();
            const topScores = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
            
            for (let i = 1; i <= 3; i++) {
                document.getElementById(`leaderboard-item-${i}`).style.backgroundColor = 'rgba(0, 0, 0, 0.1)';
            }

            firstName.textContent = "---"; firstScore.textContent = "0"; firstDifficulty.textContent = "";
            secondName.textContent = "---"; secondScore.textContent = "0"; secondDifficulty.textContent = "";
            thirdName.textContent = "---"; thirdScore.textContent = "0"; thirdDifficulty.textContent = "";

            if (topScores[0]) {
                firstName.textContent = topScores[0].name; firstScore.textContent = topScores[0].score; firstDifficulty.textContent = difficultyEmojis[topScores[0].difficulty] || '🐍';
                if (user && topScores[0].userId === user.uid) { document.getElementById('leaderboard-item-1').style.backgroundColor = '#d68910'; }
            }
            if (topScores[1]) {
                secondName.textContent = topScores[1].name; secondScore.textContent = topScores[1].score; secondDifficulty.textContent = difficultyEmojis[topScores[1].difficulty] || '🐍';
                if (user && topScores[1].userId === user.uid) { document.getElementById('leaderboard-item-2').style.backgroundColor = '#d68910'; }
            }
            if (topScores[2]) {
                thirdName.textContent = topScores[2].name; thirdScore.textContent = topScores[2].score; thirdDifficulty.textContent = difficultyEmojis[topScores[2].difficulty] || '🐍';
                if (user && topScores[2].userId === user.uid) { document.getElementById('leaderboard-item-3').style.backgroundColor = '#d68910'; }
            }
            
            userHighScoreDisplay.textContent = userHighScoresPerMap[currentMap] || 0;

        } catch (error) {
            console.error("Erro ao buscar o leaderboard online: ", error);
            firstName.textContent = "ERRO";
        }
    }

    async function handlePurchase() {
        const buyBtn = document.getElementById('buySkinBtn');
        const skinKey = buyBtn.dataset.skinToBuy;
        if (!skinKey) return;

        const skin = skins[skinKey];
        if (!skin || !skin.unlockCoins) return;

        // 1. Verifica se tem moedas suficientes
        if (snakeCoins < skin.unlockCoins) {
            alert(translations[currentLanguage]['not_enough_coins']);
            return;
        }

        // 2. Pede confirmação para a compra
        if (confirm(`${translations[currentLanguage]['confirm_buy_skin']} ${skin.unlockCoins} SC?`)) {
            // 3. Executa a lógica de compra
            snakeCoins -= skin.unlockCoins;
            unlockedSkins.push(skinKey);
            currentSkin = skinKey; // Equipa a skin recém-comprada
            
            await updateUserCoins(snakeCoins);
            await updateUserUnlockedSkins(unlockedSkins);
            
            populateSkinSelector(); // Atualiza a lista para remover o cadeado
            document.getElementById('skinSelector').value = currentSkin; // Garante que a nova skin fique selecionada

            totalSnakeCoinsElement.textContent = `🪙 ${snakeCoins} ${translations[currentLanguage]['total_coins_display']}`;
            alert(translations[currentLanguage]['skin_unlocked_success']);

            buyBtn.style.display = 'none'; // Esconde o botão após a compra
        }
    }
    async function isNewRecord(score) {
        try {
            if (!currentUsername) return false;
            const querySnapshot = await db.collection('scores').where('map', '==', currentMap).orderBy('score', 'desc').limit(3).get();
            const topScores = querySnapshot.docs.map(doc => doc.data());
            return topScores.length < 3 || score > topScores[topScores.length - 1].score;
        } catch (error) {
            console.error("Erro ao verificar recorde: ", error);
            return false;
        }
    }

    async function saveScore() {
        const user = auth.currentUser;
        if (!user || !currentUsername) return;
        try {
            const name = currentUsername.substring(0, 15).toUpperCase();
            const newEntry = { userId: user.uid, name, score, difficulty: currentDifficulty, map: currentMap, timestamp: firebase.firestore.FieldValue.serverTimestamp() };
            await db.collection('scores').add(newEntry);
            await updateLeaderboardDisplay();
        } catch (error) {
            console.error("Erro ao salvar a pontuação no servidor: ", error);
        }
    }

    function triggerFireworks() {
        congratulationsScreen.style.display = 'flex';
        function createFirework() {
            const firework = document.createElement('div'); firework.className = 'firework';
            const colors = ['#ffc700', '#ff0000', '#00ff00', '#0000ff', '#ff00ff', '#00ffff'];
            firework.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            firework.style.left = Math.random() * window.innerWidth + 'px'; firework.style.top = Math.random() * window.innerHeight + 'px';
            document.body.appendChild(firework);
            setTimeout(() => { firework.remove(); }, 1200);
        }
        fireworksInterval = setInterval(createFirework, 300);
    }
    function enterFullScreen(element) {
        if (element.requestFullscreen) { element.requestFullscreen(); } 
        else if (element.mozRequestFullScreen) { element.mozRequestFullScreen(); } 
        else if (element.webkitRequestFullscreen) { element.webkitRequestFullscreen(); } 
        else if (element.msRequestFullscreen) { element.msRequestFullscreen(); }
    }
    function startGame() {
        enterFullScreen(document.documentElement);
        inputQueue = [];
        snake = [{x: Math.floor(tileCount/2), y: Math.floor(tileCount/2)}]; dx = 0; dy = 0; score = 0; scoreElement.textContent = score;
        coinsEarnedThisGame = 0;
        gameRunning = true; gameStarted = true; gamePaused = false;
        startScreen.style.display = 'none'; toggleJoystick();
        pauseBtn.style.display = 'inline-block'; quitGameBtn.style.display = 'inline-block'; gameInstructions.style.display = 'block'; difficultyDisplay.style.display = 'block';
        const difficultyConfig = difficulties[currentDifficulty];
        currentDifficultyText.textContent = `${difficultyConfig.emoji} ${difficultyConfig['name_' + currentLanguage]}`;
        generateFood();
        if (gameInterval) { clearInterval(gameInterval); }
        gameInterval = setInterval(gameLoop, difficultyConfig.speed);
    }
    function togglePause() { 
        if (!gameRunning || !gameStarted) return; 
        gamePaused = !gamePaused; 
        pauseBtn.innerHTML = gamePaused ? `▶️ ${translations[currentLanguage].continue_button}` : `⏸️ ${translations[currentLanguage].pause_button}`; 
    }
    function quitGame() { if (confirm(translations[currentLanguage]['alert_confirm_quit'])) { restartGame(); } }
    
    async function gameOver() {
        gameRunning = false; gameStarted = false;
        if (gameInterval) { clearInterval(gameInterval); }
        quitGameBtn.style.display = 'none'; reenterPrompt.style.display = 'none';
        
        snakeCoins += coinsEarnedThisGame;
        await updateUserCoins(snakeCoins);
        totalSnakeCoinsElement.textContent = `🪙 ${snakeCoins} ${translations[currentLanguage]['total_coins_display']}`;

        const currentMapHighScore = userHighScoresPerMap[currentMap] || 0;
        if (score > currentMapHighScore) {
            await updateUserHighScore(score, currentMap);
            userHighScoreDisplay.textContent = score;
        }

        if (await isNewRecord(score) && score > 0) {
            await saveScore();
            finalScoreCongrats.textContent = score;
            coinsEarnedCongratsElement.textContent = coinsEarnedThisGame;
            triggerFireworks();
        } else {
            finalScoreElement.textContent = score;
            coinsEarnedGameOverElement.textContent = coinsEarnedThisGame;
            gameOverElement.style.display = 'flex';
        }
    }

    function restartGame() {
        if (gameInterval) { clearInterval(gameInterval); }
        if (fireworksInterval) { clearInterval(fireworksInterval); fireworksInterval = null; }
        inputQueue = [];
        congratulationsScreen.style.display = 'none'; reenterPrompt.style.display = 'none';
        snake = [{x: Math.floor(tileCount/2), y: Math.floor(tileCount/2)}];
        dx = 0; dy = 0; score = 0; gameRunning = false; gameStarted = false; gamePaused = false;
        scoreElement.textContent = score; gameOverElement.style.display = 'none'; startScreen.style.display = 'block';
        gameControls.style.display = 'none'; pauseBtn.style.display = 'none'; quitGameBtn.style.display = 'none';
        gameInstructions.style.display = 'none'; difficultyDisplay.style.display = 'none';
        pauseBtn.innerHTML = `⏸️ ${translations[currentLanguage].pause_button}`;
        ctx.fillStyle = '#2d3436'; ctx.fillRect(0, 0, canvas.width, canvas.height);
        updateLeaderboardDisplay();
    }
    
    function gameLoop() {
        processInput();
        updateGame();
        drawGame();
    }
    document.getElementById('upBtn').addEventListener('touchstart', (e) => { e.preventDefault(); queueDirection(0, -1); });
    document.getElementById('downBtn').addEventListener('touchstart', (e) => { e.preventDefault(); queueDirection(0, 1); });
    document.getElementById('leftBtn').addEventListener('touchstart', (e) => { e.preventDefault(); queueDirection(-1, 0); });
    document.getElementById('rightBtn').addEventListener('touchstart', (e) => { e.preventDefault(); queueDirection(1, 0); });
    
    const gameControlsContainer = document.getElementById('gameControls');
    gameControlsContainer.addEventListener('touchstart', (e) => {
        if (e.target !== gameControlsContainer) {
            return;
        }
        e.preventDefault();

        const touch = e.touches[0];
        const touchX = touch.clientX;
        const touchY = touch.clientY;

        const buttons = {
            up: document.getElementById('upBtn'),
            down: document.getElementById('downBtn'),
            left: document.getElementById('leftBtn'),
            right: document.getElementById('rightBtn')
        };

        let nearestButton = null;
        let minDistance = Infinity;

        for (const [direction, buttonElement] of Object.entries(buttons)) {
            const rect = buttonElement.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            const distanceSq = Math.pow(touchX - centerX, 2) + Math.pow(touchY - centerY, 2);

            if (distanceSq < minDistance) {
                minDistance = distanceSq;
                nearestButton = direction;
            }
        }

        if (nearestButton) {
            switch(nearestButton) {
                case 'up': queueDirection(0, -1); break;
                case 'down': queueDirection(0, 1); break;
                case 'left': queueDirection(-1, 0); break;
                case 'right': queueDirection(1, 0); break;
            }
        }
    }, { passive: false });

    canvas.addEventListener('click', handleCanvasInteraction);
    canvas.addEventListener('touchstart', handleCanvasInteraction, { passive: false });

    document.addEventListener('keydown', (e) => {
        if (!gameRunning || !gameStarted) return;
        switch(e.key) {
            case 'ArrowUp': queueDirection(0, -1); break;
            case 'ArrowDown': queueDirection(0, 1); break;
            case 'ArrowLeft': queueDirection(-1, 0); break;
            case 'ArrowRight': queueDirection(1, 0); break;
            case ' ': togglePause(); break;
        }

    });
    document.addEventListener('fullscreenchange', () => {
        const isFullscreen = document.fullscreenElement || document.webkitFullscreenElement;
        if (!isFullscreen && gameRunning) { if (!gamePaused) { togglePause(); } reenterPrompt.style.display = 'flex';
        } else { reenterPrompt.style.display = 'none'; }
    });
    document.querySelector('#reenterFullscreenPrompt button').onclick = () => {
        enterFullScreen(document.documentElement);
        setTimeout(() => { if (gamePaused) { togglePause(); } }, 100);
    };
    let touchStartY = 0; window.addEventListener('touchstart', function(e) { if (e.touches.length !== 1) return; touchStartY = e.touches[0].clientY; }, { passive: false });
    window.addEventListener('touchmove', function(e) { const touchY = e.touches[0].clientY; const touchDiff = touchY - touchStartY; if (touchStartY < 10 && touchDiff > 10) { e.preventDefault(); } }, { passive: false });
    selectDifficulty('normal'); selectMap('normal');
    
    let joystickType = 'classic'; let joystickPosition = 'right';

    function toggleJoystick() {
        joystickType = document.getElementById('joystickModel').value;
        const classic = document.getElementById('gameControls');
        const floating = document.getElementById('floatingJoystick');
        
        if (joystickType === 'classic') { classic.style.display = 'grid'; floating.style.display = 'none';
        } else { classic.style.display = 'none'; floating.style.display = 'block'; updateJoystickPosition(); }
    }
    
    function updateJoystickPosition() { joystickPosition = document.getElementById('joystickPosition').value; const floatingJoystick = document.getElementById('floatingJoystick'); floatingJoystick.style.left = ''; floatingJoystick.style.right = ''; floatingJoystick.style.transform = ''; if (joystickPosition === 'left') { floatingJoystick.style.left = '40px'; } else if (joystickPosition === 'right') { floatingJoystick.style.right = '40px'; } else if (joystickPosition === 'center') { floatingJoystick.style.left = '50%'; floatingJoystick.style.transform = 'translateX(-50%)'; } }
    let origin = null;
    document.getElementById('floatingJoystick').addEventListener('touchstart', e => { const floatingJoystick = document.getElementById('floatingJoystick'); const touch = e.touches[0]; const rect = floatingJoystick.getBoundingClientRect(); const joystickCenterX = rect.left + rect.width / 2; const joystickCenterY = rect.top + rect.height / 2; const distance = Math.hypot(touch.clientX - joystickCenterX, touch.clientY - joystickCenterY); const maxDistanceToReposition = 100; if (distance < maxDistanceToReposition) { let newLeft = touch.clientX - rect.width / 2; let newTop = touch.clientY - rect.height / 2; newLeft = Math.max(0, Math.min(newLeft, window.innerWidth - rect.width)); newTop = Math.max(0, Math.min(newTop, window.innerHeight - rect.height)); floatingJoystick.style.left = `${newLeft}px`; floatingJoystick.style.top = `${newTop}px`; floatingJoystick.style.right = 'auto'; floatingJoystick.style.transform = 'none'; origin = { x: touch.clientX, y: touch.clientY }; } else { origin = { x: touch.clientX, y: touch.clientY }; } }, { passive: false });
    document.getElementById('floatingJoystick').addEventListener('touchmove', e => {
        if (!origin) return; e.preventDefault();
        const touch = e.touches[0];
        const dxTouch = touch.clientX - origin.x;
        const dyTouch = touch.clientY - origin.y;
        const angle = Math.atan2(dyTouch, dxTouch);
        const distance = Math.min(Math.hypot(dxTouch, dyTouch), 40);
        const thumb = document.getElementById('joystickThumb');
        thumb.style.left = 40 + distance * Math.cos(angle) + 'px';
        thumb.style.top = 40 + distance * Math.sin(angle) + 'px';
        if (!gameRunning || !gameStarted) return;
        const sensitivity = parseInt(document.getElementById('sensitivityRange').value);
        const threshold = sensitivity * 2;
        if (Math.abs(dxTouch) > Math.abs(dyTouch)) {
            if (dxTouch > threshold) { queueDirection(1, 0); }
            if (dxTouch < -threshold) { queueDirection(-1, 0); }
        } else {
            if (dyTouch > threshold) { queueDirection(0, 1); }
            if (dyTouch < -threshold) { queueDirection(0, -1); }
        }
    }, { passive: false });
    document.getElementById('floatingJoystick').addEventListener('touchend', e => { origin = null; document.getElementById('joystickThumb').style.left = '40px'; document.getElementById('joystickThumb').style.top = '40px'; });
    
    function toggleSettings() { 
        document.getElementById('settingsMenu').style.display = 'block'; 
        showSettingsTab('general');
        drawSkinPreview(currentSkin);
    }
    function closeSettings() { 
        document.getElementById('settingsMenu').style.display = 'none'; 
        saveUserSettings(); 
        showSettingsTab('general'); 
    }
    
    const loginScreen = document.getElementById('loginScreen');
    const registerScreen = document.getElementById('registerScreen');
    const gameUI = document.getElementById('mainGame');
    const loggedUser = document.getElementById('loggedUser');
    let currentUsername = null; 
    let userSettings = {};
    let isAdmin = false;
    let inboxListener = null; // Listener para a caixa de entrada

    document.getElementById('loginPass').addEventListener('keydown', function(event) { if (event.key === 'Enter') { event.preventDefault(); handleLogin(); } });

    async function selectSkin(skinKey) {
    const skin = skins[skinKey];
    if (!skin) return;

    // Sempre atualiza o visualizador com a skin que foi clicada
    drawSkinPreview(skinKey);

    const buyBtn = document.getElementById('buySkinBtn');
    const isLocked = !unlockedSkins.includes(skinKey);

    // Mostra ou esconde o botão de compra
    if (isLocked && skin.unlockCoins) {
        buyBtn.style.display = 'block';
        // Adiciona um texto traduzível (vou usar 'Comprar por' como padrão)
        const buyText = translations[currentLanguage]['buy_for'] || 'Comprar por';
        buyBtn.textContent = `${buyText} ${skin.unlockCoins} SC 🪙`;
        buyBtn.dataset.skinToBuy = skinKey; // Armazena qual skin comprar
    } else {
        buyBtn.style.display = 'none';
    }

    // Se a skin selecionada já estiver desbloqueada, equipa ela
    if (!isLocked) {
        currentSkin = skinKey;
    }
    
    // Se a skin estiver bloqueada, a função agora só mostra o preview e o botão,
    // sem fazer mais nada, esperando o clique no botão "Comprar".
    const colorPickerContainer = document.getElementById('colorPickerContainer');
    colorPickerContainer.style.display = skinKey === 'custom' ? 'block' : 'none';
}

    function checkSkinUnlocks() {
        for (const key in skins) {
            const skin = skins[key];
            if (skin.unlockScore && (userHighScoresPerMap[currentMap] || 0) >= skin.unlockScore && !unlockedSkins.includes(key)) {
                unlockedSkins.push(key);
            }
        }
    }
    
    function populateSkinSelector() {
        const selector = document.getElementById('skinSelector');
        selector.innerHTML = '';
        
        for (const key in skins) {
            const skin = skins[key];
            const option = document.createElement('option');
            option.value = key;

            let displayName = translations[currentLanguage][`skin_${key}`] || skin.name_pt;
            let isLocked = !unlockedSkins.includes(key);

            if (isLocked) {
                if (skin.unlockScore) {
                    displayName = `🔒 ${displayName} (${skin.unlockScore} Pts)`;
                } else if (skin.unlockCoins) {
                    displayName = `🔒 ${displayName} (${skin.unlockCoins} SC)`;
                }
                option.style.color = '#aaa'; // Cor cinza para indicar que está bloqueada
            }
            
            option.textContent = displayName;
            // A linha abaixo é comentada para permitir a seleção e visualização
            // option.disabled = isLocked;
            selector.appendChild(option);
        }
        selector.value = currentSkin;
    }

    async function updateUserHighScore(newScore, map) {
        const user = auth.currentUser;
        if (user) {
            try {
                const updateData = {};
                updateData[`highScoresPerMap.${map}`] = newScore;
                await db.collection('users').doc(user.uid).update(updateData);
                userHighScoresPerMap[map] = newScore;
            } catch (error) {
                console.error("Erro ao atualizar high score por mapa:", error);
            }
        }
    }

    async function updateUserCoins(coins) {
        const user = auth.currentUser;
        if (user) {
            try {
                await db.collection('users').doc(user.uid).update({ snakeCoins: coins });
            } catch (error) {
                console.error("Erro ao atualizar Snake Coins:", error);
            }
        }
    }

    async function updateUserUnlockedSkins(skinsList) {
        const user = auth.currentUser;
        if (user) {
            try {
                await db.collection('users').doc(user.uid).update({ unlockedSkins: skinsList });
            } catch (error) {
                console.error("Erro ao atualizar skins desbloqueadas:", error);
            }
        }
    }


    async function saveUserSettings() {
        const user = auth.currentUser;
        if (user) {
            const settingsToSave = {
                skin: currentSkin,
                customSnakeColor: document.getElementById('snakeColorPicker').value,
                sensitivity: document.getElementById('sensitivityRange').value,
                joystickModel: document.getElementById('joystickModel').value,
                screenBackgroundColor: document.getElementById('screenBackgroundColor').value,
                joystickPosition: document.getElementById('joystickPosition').value,
                language: currentLanguage
            };
            try { 
                await db.collection('users').doc(user.uid).set({ 
                    settings: settingsToSave, 
                    unlockedSkins: unlockedSkins,
                    highScoresPerMap: userHighScoresPerMap
                }, { merge: true }); 
            } catch (error) { console.error("Erro ao salvar configurações do usuário:", error); }
        }
    }

    async function loadUserSettings(uid) {
        try {
            const userDoc = await db.collection('users').doc(uid).get();
            isAdmin = false; 

            if (userDoc.exists) {
                const userData = userDoc.data();
                isAdmin = userData.isAdmin || false; 
                currentUsername = userData.username;
                userHighScoresPerMap = userData.highScoresPerMap || {};
                snakeCoins = userData.snakeCoins || 0;
                unlockedSkins = userData.unlockedSkins || ['default', 'custom'];
                userSettings = userData.settings || {};

                // Carrega o status de banimento
                if (userData.isBanned) {
                    alert("Sua conta foi banida.");
                    handleLogout();
                    return;
                }

                currentSkin = userSettings.skin || 'default';
                document.getElementById('snakeColorPicker').value = userSettings.customSnakeColor || '#00b894';
                document.getElementById('sensitivityRange').value = userSettings.sensitivity || '5';
                document.getElementById('joystickModel').value = userSettings.joystickModel || 'classic';
                document.getElementById('screenBackgroundColor').value = userSettings.screenBackgroundColor || '#1a1a1a';
                document.getElementById('joystickPosition').value = userSettings.joystickPosition || 'right';
                
                checkSkinUnlocks();
                populateSkinSelector();
                selectSkin(currentSkin);
                
                selectLanguage(userSettings.language || 'pt');
            } else {
                userSettings = { skin: 'default', customSnakeColor: '#00b894', sensitivity: '5', joystickModel: 'classic', screenBackgroundColor: '#1a1a1a', joystickPosition: 'right', language: 'pt' };
                snakeCoins = 0;
                unlockedSkins = ['default', 'custom'];
                userHighScoresPerMap = {};
                selectLanguage('pt');
            }
            
            const existingAdminBtn = document.getElementById('adminPanelBtn');
            if (isAdmin) {
                if (!existingAdminBtn) { 
                    const adminButton = document.createElement('button');
                    adminButton.id = 'adminPanelBtn';
                    adminButton.textContent = 'Painel Admin';
                    adminButton.className = 'btn btn-danger';
                    adminButton.style.marginTop = '10px';
                    adminButton.style.width = '100%';
                    adminButton.onclick = openAdminPanel;
                    const startScreenDiv = document.getElementById('startScreen');
                    startScreenDiv.appendChild(adminButton);
                }
            } else {
                if(existingAdminBtn) {
                    existingAdminBtn.remove();
                }
            }


            screenBackgroundColor = document.getElementById('screenBackgroundColor').value;
            document.getElementById('mainGame').style.background = screenBackgroundColor;
            loggedUser.textContent = `${translations[currentLanguage]['player_name_prefix']} ${currentUsername}`;
            totalSnakeCoinsElement.textContent = `🪙 ${snakeCoins} ${translations[currentLanguage]['total_coins_display']}`;
            userHighScoreDisplay.textContent = userHighScoresPerMap[currentMap] || 0;
            toggleJoystick();
            updateJoystickPosition();
            listenToInbox(uid); // Inicia o listener da caixa de entrada

        } catch (error) {
            console.error("Erro ao carregar dados do usuário:", error);
        }
    }
    
    // Carrega o anúncio global para o jogador
    async function loadAnnouncement() {
        const announcementEl = document.getElementById('globalAnnouncement');
        try {
            const doc = await db.collection('game_config').doc('announcement').get();
            if (doc.exists) {
                const data = doc.data();
                if (data.isActive && data.text) {
                    announcementEl.textContent = data.text;
                    announcementEl.style.display = 'block';
                } else {
                    announcementEl.style.display = 'none';
                }
            }
        } catch(error) {
            console.error("Erro ao carregar anúncio:", error);
            announcementEl.style.display = 'none';
        }
    }

    auth.onAuthStateChanged(async (user) => {
        if (user) {
            await loadUserSettings(user.uid);
            await loadAnnouncement(); // Carrega o anúncio para o usuário logado
            loginScreen.style.display = 'none';
            registerScreen.style.display = 'none';
            gameUI.style.display = 'block';
            await updateLeaderboardDisplay();
        } else {
            currentUsername = null;
            isAdmin = false;
            loginScreen.style.display = 'block';
            registerScreen.style.display = 'none';
            gameUI.style.display = 'none';
            
            const adminButton = document.getElementById('adminPanelBtn');
            if (adminButton) {
                adminButton.remove();
            }
            if(inboxListener) inboxListener(); // Remove o listener ao deslogar
        }
        updateContent();
    });
    
    window.onload = () => { updateContent(); };
    function showRegister() { loginScreen.style.display = 'none'; registerScreen.style.display = 'block'; }
    function showLogin() { registerScreen.style.display = 'none'; loginScreen.style.display = 'block'; }
    
    function validateEmail(email) { const re = /^(([^<>()[\]\\.,;:\s@"]+(\.[^<>()[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/; return re.test(String(email).toLowerCase()); }
    function validatePassword(password) { const minLength = 6; const hasNumber = /[0-9]/.test(password); const hasLetter = /[a-zA-Z]/.test(password); if (password.length < minLength) { return translations[currentLanguage]['password_min_length'].replace('{minLength}', minLength); } if (!hasNumber) { return translations[currentLanguage]['password_needs_number']; } if (!hasLetter) { return translations[currentLanguage]['password_needs_letter']; } return null; }
    
    // CÓDIGO CORRIGIDO para a função isUsernameTaken
async function isUsernameTaken(username) {
    if (!username) return false;
    try {
        const usernameDoc = await db.collection('usernames').doc(username.toLowerCase()).get();
        return usernameDoc.exists; // Retorna true se o documento existir, false caso contrário
    } catch (error) {
        console.error("Erro ao verificar nome de usuário:", error);
        // Em caso de erro, é mais seguro assumir que o nome está indisponível.
        return true;
    }
}

    // CÓDIGO CORRIGIDO para a função handleRegister
async function handleRegister() {
    const email = document.getElementById('registerEmail').value.trim();
    const pass = document.getElementById('registerPass').value.trim();
    const username = document.getElementById('registerUsername').value.trim();
    const usernameLowercase = username.toLowerCase();

    // ... (suas validações existentes) ...
    if (email === '' || pass === '' || username === '') { alert(translations[currentLanguage]['alert_fill_all_fields']); return; }
    if (!validateEmail(email)) { alert(translations[currentLanguage]['alert_invalid_email']); return; }
    const passwordError = validatePassword(pass); if (passwordError) { alert(passwordError); return; }

    // A verificação agora usa a nova função e vai funcionar corretamente
    if (await isUsernameTaken(username)) {
        alert(translations[currentLanguage]['alert_username_taken']);
        return;
    }
    
    try {
        const userCredential = await auth.createUserWithEmailAndPassword(email, pass);
        const user = userCredential.user;
        
        // Criar o documento do usuário
        const userRef = db.collection('users').doc(user.uid);
        // Criar o documento de referência do nome de usuário
        const usernameRef = db.collection('usernames').doc(usernameLowercase);

        // Usar um batch para garantir que ambas as operações ocorram juntas
        const batch = db.batch();

        batch.set(userRef, {
            username,
            username_lowercase: usernameLowercase,
            email, 
            snakeCoins: 0,
            isBanned: false,
            unlockedSkins: ['default', 'custom'],
            highScoresPerMap: { "normal": 0, "no-walls": 0 },
            createdAt: firebase.firestore.FieldValue.serverTimestamp(),
            settings: { skin: 'default', customSnakeColor: '#00b894' }
        });

        batch.set(usernameRef, {
            userId: user.uid // Armazena o UID do dono do nome de usuário
        });

        await batch.commit(); // Executa ambas as operações
        
        alert(translations[currentLanguage]['alert_registration_success']);
    } catch (error) {
        console.error("Erro no cadastro:", error);
        alert(error.code === 'auth/email-already-in-use' ? translations[currentLanguage]['alert_user_exists'] : error.message);
    }
}
    
    async function handleLogin() {
        const email = document.getElementById('loginEmail').value.trim();
        const pass = document.getElementById('loginPass').value.trim();
        if (email === '' || pass === '') { alert(translations[currentLanguage]['alert_fill_all_fields']); return; }
        try { await auth.signInWithEmailAndPassword(email, pass); }
        catch (error) { console.error("Erro no login:", error); alert(translations[currentLanguage]['alert_invalid_credentials']); }
    }

    async function handlePasswordReset() {
        const email = document.getElementById('loginEmail').value.trim();
        if (email === '') { alert(translations[currentLanguage]['alert_enter_email_for_reset']); return; }
        try { await auth.sendPasswordResetEmail(email); alert(translations[currentLanguage]['alert_password_reset_success']); }
        catch (error) { console.error("Erro ao enviar email de recuperação:", error); alert(error.message); }
    }

    function handleLogout() {
        if(inboxListener) inboxListener(); // Desconecta o listener de inbox
        saveUserSettings(); auth.signOut().catch(error => console.error("Erro ao sair:", error));
    }

    function showSettingsTab(tabId) { document.querySelectorAll('.settings-tab-content').forEach(tab => { tab.style.display = 'none'; }); document.querySelectorAll('.tab-button').forEach(btn => { btn.classList.remove('selected'); }); document.getElementById(tabId + 'Settings').style.display = 'block'; document.querySelector(`.tab-button[onclick*="${tabId}"]`).classList.add('selected'); }
    
    async function reauthenticate(currentPassword) { const user = auth.currentUser; const cred = firebase.auth.EmailAuthProvider.credential(user.email, currentPassword); return user.reauthenticateWithCredential(cred); }
    
   // CÓDIGO CORRIGIDO para a função handleChangeUsername
async function handleChangeUsername() {
    const newUsername = document.getElementById('newUsername').value.trim();
    const currentPass = document.getElementById('currentPassForUsername').value.trim();
    const usernameChangeError = document.getElementById('usernameChangeError');
    usernameChangeError.textContent = '';
    const user = auth.currentUser;

    // ... (suas validações existentes) ...
    if (!user) { usernameChangeError.textContent = translations[currentLanguage]['alert_no_user_logged_in']; return; }
    if (newUsername === '') { usernameChangeError.textContent = translations[currentLanguage]['alert_username_empty']; return; }
    if (newUsername.toLowerCase() === currentUsername.toLowerCase()){ usernameChangeError.textContent = translations[currentLanguage]['alert_new_username_same_as_current']; return; }
    
    // A verificação agora usa a nova função e vai funcionar corretamente
    if (await isUsernameTaken(newUsername)) {
        usernameChangeError.textContent = translations[currentLanguage]['alert_username_taken'];
        return;
    }
    
    try {
        // Reautenticação do usuário continua sendo necessária
        await reauthenticate(currentPass);

        // Iniciar uma transação para garantir a consistência dos dados
        await db.runTransaction(async (transaction) => {
            const oldUsernameLowercase = currentUsername.toLowerCase();
            const newUsernameLowercase = newUsername.toLowerCase();

            const userRef = db.collection('users').doc(user.uid);
            const oldUsernameRef = db.collection('usernames').doc(oldUsernameLowercase);
            const newUsernameRef = db.collection('usernames').doc(newUsernameLowercase);
            
            // 1. Deleta o documento do nome de usuário antigo
            transaction.delete(oldUsernameRef);
            // 2. Cria o documento para o novo nome de usuário
            transaction.set(newUsernameRef, { userId: user.uid });
            // 3. Atualiza o nome de usuário no perfil do usuário
            transaction.update(userRef, {
                username: newUsername,
                username_lowercase: newUsernameLowercase
            });
        });

        // Se a transação for bem-sucedida, atualize o estado local
        currentUsername = newUsername;
        loggedUser.textContent = `${translations[currentLanguage]['player_name_prefix']} ${currentUsername}`;
        alert(translations[currentLanguage]['alert_username_changed_success']);
        document.getElementById('newUsername').value = '';
        document.getElementById('currentPassForUsername').value = '';

    } catch (error) {
        console.error("Erro ao mudar nome de usuário:", error);
        usernameChangeError.textContent = error.code === 'auth/wrong-password' 
            ? translations[currentLanguage]['alert_incorrect_current_password'] 
            : 'Erro: ' + error.message;
    }
}

    async function handleChangeEmail() {
        const newEmail = document.getElementById('newEmail').value.trim();
        const currentPass = document.getElementById('currentPassForEmail').value.trim();
        const emailChangeError = document.getElementById('emailChangeError');
        emailChangeError.textContent = '';
        const user = auth.currentUser;

        if (!user) { emailChangeError.textContent = translations[currentLanguage]['alert_no_user_logged_in']; return; }
        if (newEmail === '') { emailChangeError.textContent = translations[currentLanguage]['alert_new_email_empty']; return; }
        if (!validateEmail(newEmail)) { emailChangeError.textContent = translations[currentLanguage]['alert_invalid_email']; return; }
        if (newEmail.toLowerCase() === user.email.toLowerCase()) { emailChangeError.textContent = translations[currentLanguage]['alert_new_email_same_as_current']; return; }

        try {
            await reauthenticate(currentPass); await user.updateEmail(newEmail);
            await db.collection('users').doc(user.uid).update({ email: newEmail });
            alert(translations[currentLanguage]['alert_email_changed_success']);
            document.getElementById('newEmail').value = ''; document.getElementById('currentPassForEmail').value = '';
        } catch (error) {
            console.error("Erro ao mudar email:", error);
            if (error.code === 'auth/wrong-password') { emailChangeError.textContent = translations[currentLanguage]['alert_incorrect_current_password']; }
            else if (error.code === 'auth/email-already-in-use') { emailChangeError.textContent = translations[currentLanguage]['alert_email_taken']; }
            else { emailChangeError.textContent = 'Erro: ' + error.message; }
        }
    }
    
    async function handleChangePassword() {
        const oldPass = document.getElementById('oldPassword').value.trim();
        const newPass = document.getElementById('newPassword').value.trim();
        const confirmNewPass = document.getElementById('confirmNewPassword').value.trim();
        const passwordChangeError = document.getElementById('passwordChangeError');
        passwordChangeError.textContent = '';
        const user = auth.currentUser;

        if (!user) { passwordChangeError.textContent = translations[currentLanguage]['alert_no_user_logged_in']; return; }
        if (oldPass === '' || newPass === '' || confirmNewPass === '') { passwordChangeError.textContent = translations[currentLanguage]['alert_fill_all_password_fields']; return; }
        if (newPass !== confirmNewPass) { passwordChangeError.textContent = translations[currentLanguage]['alert_new_passwords_dont_match']; return; }
        const passwordError = validatePassword(newPass); if (passwordError) { passwordChangeError.textContent = passwordError; return; }
        if (oldPass === newPass) { passwordChangeError.textContent = translations[currentLanguage]['alert_new_password_same_as_old']; return; }

        try {
            await reauthenticate(oldPass); await user.updatePassword(newPass);
            alert(translations[currentLanguage]['alert_password_changed_success']);
            document.getElementById('oldPassword').value = ''; document.getElementById('newPassword').value = ''; document.getElementById('confirmNewPassword').value = '';
        } catch (error) {
            console.error("Erro ao mudar senha:", error);
            passwordChangeError.textContent = error.code === 'auth/wrong-password' ? translations[currentLanguage]['alert_old_password_incorrect'] : 'Erro: ' + error.message;
        }
    }
    
    async function handleSupportRequest() {
        const supportType = document.getElementById('supportType').value;
        const supportMessage = document.getElementById('supportMessage').value.trim();
        const successMessageElement = document.getElementById('supportSuccessMessage');
        const user = auth.currentUser;

        successMessageElement.textContent = '';

        if (!user) {
            alert(translations[currentLanguage]['alert_no_user_logged_in']);
            return;
        }
        if (supportMessage === '') {
            alert(translations[currentLanguage]['alert_support_message_empty']);
            return;
        }

        try {
            await db.collection('support_tickets').add({
                userId: user.uid,
                username: currentUsername,
                email: user.email,
                type: supportType,
                message: supportMessage,
                status: 'new',
                timestamp: firebase.firestore.FieldValue.serverTimestamp()
            });

            successMessageElement.textContent = translations[currentLanguage]['alert_support_success'];
            document.getElementById('supportMessage').value = '';
            
            setTimeout(() => {
                successMessageElement.textContent = '';
            }, 5000);

        } catch (error) {
            console.error("Erro ao enviar ticket de suporte:", error);
            alert('Ocorreu um erro ao enviar sua mensagem. Tente novamente.');
        }
    }

    document.getElementById('snakeColorPicker').addEventListener('change', saveUserSettings); document.getElementById('sensitivityRange').addEventListener('change', saveUserSettings); document.getElementById('joystickModel').addEventListener('change', saveUserSettings); document.getElementById('screenBackgroundColor').addEventListener('change', saveUserSettings); document.getElementById('joystickPosition').addEventListener('change', saveUserSettings);
    
    document.getElementById('snakeColorPicker').addEventListener('input', () => {
        if (currentSkin === 'custom') {
            drawSkinPreview('custom');
        }
    });

    showSettingsTab('general');


    // ==================================================================
    // FUNÇÕES DO PAINEL DE ADMIN
    // ==================================================================
    
    function openAdminPanel() {
        document.getElementById('adminPanel').style.display = 'flex';
        showAdminTab('dashboard'); // Mostra a primeira aba por padrão
    }

    function closeAdminPanel() {
        document.getElementById('adminPanel').style.display = 'none';
    }

    function showAdminTab(tabId) {
        document.querySelectorAll('.admin-tab-content').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.admin-tab-button').forEach(btn => btn.classList.remove('selected'));
        
        document.getElementById(`admin${tabId.charAt(0).toUpperCase() + tabId.slice(1)}Tab`).classList.add('active');
        document.querySelector(`.admin-tab-button[onclick*="'${tabId}'"]`).classList.add('selected');

        // Carrega o conteúdo da aba selecionada
        if (tabId === 'dashboard') loadAdminDashboard();
        if (tabId === 'analytics') loadGameAnalytics();
        if (tabId === 'users') listAllUsers();
        if (tabId === 'leaderboard') loadFullLeaderboard(document.getElementById('leaderboardMapSelector').value);
        if (tabId === 'support') loadSupportTickets();
        if (tabId === 'announcements') loadCurrentAnnouncementForAdmin();
        if (tabId === 'collectiveActions') { /* Não precisa carregar nada ao abrir */ } 
    }

    // ABA 1: Dashboard
    async function loadAdminDashboard() {
        try {
            // Total de usuários
            const usersSnapshot = await db.collection('users').get();
            document.getElementById('totalUsersStat').textContent = usersSnapshot.size;

            // Novos usuários (últimas 24h)
            const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000);
            const newUsersSnapshot = await db.collection('users').where('createdAt', '>=', oneDayAgo).get();
            document.getElementById('newUsersStat').textContent = newUsersSnapshot.size;

            // Total de pontuações (proxy para partidas)
            const scoresSnapshot = await db.collection('scores').get();
            document.getElementById('totalScoresStat').textContent = scoresSnapshot.size;

            // Tickets de suporte abertos
            const ticketsSnapshot = await db.collection('support_tickets').where('status', '==', 'new').get();
            document.getElementById('openTicketsStat').textContent = ticketsSnapshot.size;
        } catch(error) {
            console.error("Erro ao carregar dashboard:", error);
            alert("Não foi possível carregar os dados do dashboard.");
        }
    }

    // ABA 2 - Análises do Jogo (MODIFICADA)
    async function loadGameAnalytics() {
        const mostUsedSkinStat = document.getElementById('mostUsedSkinStat');
        const mostPlayedMapStat = document.getElementById('mostPlayedMapStat');
        const mostUsedDifficultyStat = document.getElementById('mostUsedDifficultyStat');
        const skinUsageTableBody = document.querySelector('#skinUsageTable tbody');
        const difficultyChartContainer = document.getElementById('difficultyDistributionChart');
        const mostPlayedMapsList = document.getElementById('mostPlayedMapsList');

        // Resetar campos
        mostUsedSkinStat.textContent = "Calculando...";
        mostPlayedMapStat.textContent = "Calculando...";
        mostUsedDifficultyStat.textContent = "Calculando...";
        skinUsageTableBody.innerHTML = '<tr><td colspan="3">Calculando...</td></tr>';
        difficultyChartContainer.innerHTML = '<p>Calculando...</p>';
        mostPlayedMapsList.innerHTML = '<p>Calculando...</p>';

        try {
            const usersSnapshot = await db.collection('users').get();
            const scoresSnapshot = await db.collection('scores').get();
            const totalUsers = usersSnapshot.size;

            // --- Análise de Skins ---
            const skinCounts = {};
            usersSnapshot.forEach(doc => {
                const skin = (doc.data().settings && doc.data().settings.skin) ? doc.data().settings.skin : 'default';
                skinCounts[skin] = (skinCounts[skin] || 0) + 1;
            });
            
            skinUsageTableBody.innerHTML = '';
            Object.keys(skins).forEach(skinKey => {
                const count = skinCounts[skinKey] || 0;
                const percentage = totalUsers > 0 ? ((count / totalUsers) * 100).toFixed(1) : 0;
                const skinName = translations[currentLanguage][`skin_${skinKey}`] || skins[skinKey].name_pt;
                const row = `<tr>
                    <td>${skinName}</td>
                    <td>${count}</td>
                    <td>${percentage}%</td>
                </tr>`;
                skinUsageTableBody.innerHTML += row;
            });

            const mostUsedSkinKey = Object.keys(skinCounts).reduce((a, b) => skinCounts[a] > skinCounts[b] ? a : b, 'default');
            mostUsedSkinStat.textContent = translations[currentLanguage][`skin_${mostUsedSkinKey}`] || skins[mostUsedSkinKey].name_pt;
            
            // --- Análise de Partidas (Mapas e Dificuldades) ---
            const mapCounts = {};
            const difficultyCounts = {};
            scoresSnapshot.forEach(doc => {
                const map = doc.data().map || 'normal';
                const diff = doc.data().difficulty || 'normal';
                mapCounts[map] = (mapCounts[map] || 0) + 1;
                difficultyCounts[diff] = (difficultyCounts[diff] || 0) + 1;
            });
            const totalScores = scoresSnapshot.size;

            const mostPlayedMapKey = Object.keys(mapCounts).reduce((a, b) => mapCounts[a] > mapCounts[b] ? a : b, 'normal');
            mostPlayedMapStat.textContent = maps[mostPlayedMapKey]['name_' + currentLanguage];

            const mostUsedDifficultyKey = Object.keys(difficultyCounts).reduce((a, b) => difficultyCounts[a] > difficultyCounts[b] ? a : b, 'normal');
            mostUsedDifficultyStat.textContent = difficulties[mostUsedDifficultyKey]['name_' + currentLanguage];

            // Gráfico de Distribuição de Dificuldade
            difficultyChartContainer.innerHTML = '';
            Object.keys(difficulties).forEach(diffKey => {
                const count = difficultyCounts[diffKey] || 0;
                const percentage = totalScores > 0 ? ((count / totalScores) * 100).toFixed(1) : 0;
                const diffName = difficulties[diffKey]['name_' + currentLanguage];
                const chartItem = `
                    <div class="bar-chart-item">
                        <div class="bar-chart-label">${diffName}</div>
                        <div class="bar-chart-bar-bg">
                            <div class="bar-chart-bar" style="width: ${percentage}%;"></div>
                        </div>
                        <div class="bar-chart-value">${count}</div>
                    </div>`;
                difficultyChartContainer.innerHTML += chartItem;
            });
            
            // Lista de Mapas Mais Jogados
            mostPlayedMapsList.innerHTML = '';
            const sortedMaps = Object.entries(mapCounts).sort(([,a],[,b]) => b-a);
             sortedMaps.forEach(([mapKey, count]) => {
                const mapName = maps[mapKey] ? maps[mapKey]['name_' + currentLanguage] : 'Desconhecido';
                const listItem = `<p>${mapName}: <strong>${count} partidas</strong></p>`;
                mostPlayedMapsList.innerHTML += listItem;
            });

        } catch (error) {
            console.error("Erro ao carregar análises detalhadas:", error);
            mostUsedSkinStat.textContent = "Erro";
            skinUsageTableBody.innerHTML = '<tr><td colspan="3">Erro ao carregar.</td></tr>';
            difficultyChartContainer.innerHTML = '<p>Erro ao carregar.</p>';
            mostPlayedMapsList.innerHTML = '<p>Erro ao carregar.</p>';
        }
    }


    // ABA 3: Gerenciamento de Usuários
    async function listAllUsers(query = db.collection('users').orderBy('username_lowercase')) {
        const tableBody = document.querySelector('#usersTable tbody');
        tableBody.innerHTML = '<tr><td colspan="5">Carregando...</td></tr>';
        try {
            const snapshot = await query.get();
            if (snapshot.empty) {
                tableBody.innerHTML = '<tr><td colspan="5">Nenhum usuário encontrado.</td></tr>';
                return;
            }
            tableBody.innerHTML = '';
            snapshot.forEach(doc => {
                const user = doc.data();
                const row = `
                    <tr>
                        <td>${user.username}</td>
                        <td>${user.email}</td>
                        <td>${user.snakeCoins || 0}</td>
                        <td>${user.isBanned ? '<span style="color:red;">Banido</span>' : '<span style="color:limegreen;">Ativo</span>'}</td>
                        <td>
                            <button class="btn btn-primary" onclick="openEditUserModal('${doc.id}')">Editar</button>
                        </td>
                    </tr>
                `;
                tableBody.innerHTML += row;
            });
        } catch(error) {
            console.error("Erro ao listar usuários:", error);
            tableBody.innerHTML = '<tr><td colspan="5">Erro ao carregar usuários.</td></tr>';
        }
    }

    function searchUser() {
        const searchTerm = document.getElementById('userSearchInput').value.trim().toLowerCase();
        if (searchTerm === '') {
            listAllUsers();
            return;
        }
        const query = db.collection('users').where('username_lowercase', '==', searchTerm);
        listAllUsers(query);
    }
    
    async function openEditUserModal(userId) {
        try {
            const userDoc = await db.collection('users').doc(userId).get();
            if (!userDoc.exists) {
                alert("Usuário não encontrado.");
                return;
            }
            const userData = userDoc.data();

            document.getElementById('editUserId').value = userId;
            document.getElementById('editUserTitle').textContent = `Editar ${userData.username}`;
            document.getElementById('editUserCoins').value = userData.snakeCoins || 0;
            document.getElementById('editUserBanned').checked = userData.isBanned || false;
            
            document.getElementById('editUserModal').style.display = 'flex';
        } catch(error) {
            console.error("Erro ao buscar dados do usuário:", error);
            alert("Erro ao abrir editor.");
        }
    }

    function closeEditUserModal() {
        document.getElementById('editUserModal').style.display = 'none';
    }

    async function handleUpdateUser() {
        const userId = document.getElementById('editUserId').value;
        const coins = parseInt(document.getElementById('editUserCoins').value);
        const isBanned = document.getElementById('editUserBanned').checked;

        if (!userId) return;

        try {
            await db.collection('users').doc(userId).update({
                snakeCoins: coins,
                isBanned: isBanned
            });
            alert("Usuário atualizado com sucesso!");
            closeEditUserModal();
            listAllUsers(); // Recarrega a lista
        } catch(error) {
            console.error("Erro ao atualizar usuário:", error);
            alert("Falha ao atualizar o usuário.");
        }
    }

    // ABA 4: Moderação do Leaderboard
    async function loadFullLeaderboard(map) {
        const tableBody = document.querySelector('#leaderboardTable tbody');
        tableBody.innerHTML = '<tr><td colspan="6">Carregando...</td></tr>';
        const difficultyEmojis = { easy: '🐌', normal: '🐍', hard: '🚀', insane: '💀' };
        try {
            const snapshot = await db.collection('scores').where('map', '==', map).orderBy('score', 'desc').limit(50).get();
            if (snapshot.empty) {
                tableBody.innerHTML = `<tr><td colspan="6">Nenhuma pontuação para o mapa "${map}".</td></tr>`;
                return;
            }
            tableBody.innerHTML = '';
            let rank = 1;
            snapshot.forEach(doc => {
                const score = doc.data();
                const date = score.timestamp ? score.timestamp.toDate().toLocaleDateString('pt-BR') : 'N/A';
                const row = `
                    <tr>
                        <td>${rank++}</td>
                        <td>${score.name}</td>
                        <td>${score.score}</td>
                        <td>${difficultyEmojis[score.difficulty] || ''}</td>
                        <td>${date}</td>
                        <td>
                            <button class="btn btn-danger" onclick="deleteScore('${doc.id}', '${map}')">Excluir</button>
                        </td>
                    </tr>
                `;
                tableBody.innerHTML += row;
            });
        } catch(error) {
            console.error("Erro ao carregar leaderboard:", error);
            tableBody.innerHTML = '<tr><td colspan="6">Erro ao carregar pontuações.</td></tr>';
        }
    }

    async function deleteScore(scoreId, map) {
        if(confirm("Tem certeza que deseja excluir esta pontuação? A ação não pode ser desfeita.")) {
            try {
                await db.collection('scores').doc(scoreId).delete();
                alert("Pontuação excluída com sucesso.");
                loadFullLeaderboard(map); // Recarrega a lista
            } catch(error) {
                console.error("Erro ao excluir pontuação:", error);
                alert("Falha ao excluir a pontuação.");
            }
        }
    }

    // ABA 5: Suporte ao Jogador
    async function loadSupportTickets() {
        const status = document.getElementById('supportStatusFilter').value;
        const listEl = document.getElementById('supportTicketsList');
        listEl.innerHTML = '<p>Carregando tickets...</p>';

        try {
            const snapshot = await db.collection('support_tickets').where('status', '==', status).orderBy('timestamp', 'desc').get();
            if (snapshot.empty) {
                listEl.innerHTML = '<p>Nenhum ticket encontrado com este status.</p>';
                return;
            }
            listEl.innerHTML = '';
            snapshot.forEach(doc => {
                const ticket = doc.data();
                const date = ticket.timestamp ? ticket.timestamp.toDate().toLocaleString('pt-BR') : 'N/A';
                const ticketHTML = `
                    <div class="stat-card" style="text-align: left;">
                        <div style="display:flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                            <strong style="font-size: 14px;">${ticket.username} (${ticket.type})</strong>
                            <span style="font-size: 11px; opacity: 0.7;">${date}</span>
                        </div>
                        <p style="font-size: 13px; font-weight: normal; margin-bottom: 15px;">${ticket.message}</p>
                        <div class="filter-controls">
                             <button class="btn btn-secondary" style="font-size: 10px;" onclick="updateTicketStatus('${doc.id}', 'new')">Novo</button>
                             <button class="btn btn-primary" style="font-size: 10px;" onclick="updateTicketStatus('${doc.id}', 'in_progress')">Em Andamento</button>
                             <button class="btn" style="background-color: #00b894; font-size: 10px;" onclick="updateTicketStatus('${doc.id}', 'resolved')">Resolvido</button>
                        </div>
                    </div>
                `;
                listEl.innerHTML += ticketHTML;
            });
        } catch(error) {
            console.error("Erro ao carregar tickets:", error);
            listEl.innerHTML = '<p>Erro ao carregar os tickets de suporte.</p>';
        }
    }

    async function updateTicketStatus(ticketId, newStatus) {
        try {
            await db.collection('support_tickets').doc(ticketId).update({ status: newStatus });
            alert(`Status do ticket alterado para "${newStatus}"!`);
            loadSupportTickets();
        } catch(error) {
            console.error("Erro ao atualizar status do ticket:", error);
            alert("Falha ao atualizar o status.");
        }
    }

    // ABA 6: Anúncios Globais
    async function loadCurrentAnnouncementForAdmin() {
        try {
            const doc = await db.collection('game_config').doc('announcement').get();
            if (doc.exists) {
                const data = doc.data();
                document.getElementById('announcementText').value = data.text || '';
                document.getElementById('announcementActive').checked = data.isActive || false;
            }
        } catch (error) {
            console.error("Erro ao carregar anúncio para admin:", error);
        }
    }

    async function saveAnnouncement() {
        const text = document.getElementById('announcementText').value.trim();
        const isActive = document.getElementById('announcementActive').checked;
        try {
            await db.collection('game_config').doc('announcement').set({ text, isActive }, { merge: true });
            alert("Anúncio salvo com sucesso!");
        } catch(error) {
            console.error("Erro ao salvar anúncio:", error);
            alert("Falha ao salvar o anúncio.");
        }
    }

    // ABA 7 - Ações Coletivas (MODIFICADA)
    async function sendCollectiveReward() {
        const amountInput = document.getElementById('collectiveCoinsAmount');
        const messageInput = document.getElementById('collectiveRewardMessage');
        
        const amount = parseInt(amountInput.value) || 0; // Garante que é um número
        const customMessage = messageInput.value.trim();

        if (amount < 0) {
            alert("A quantidade de moedas não pode ser negativa.");
            return;
        }
        if (customMessage === '') {
            alert("Por favor, escreva uma mensagem para a recompensa.");
            return;
        }

        try {
            const batch = db.batch();
            const usersSnapshot = await db.collection('users').get();
            
            if (!confirm(`Você tem certeza que deseja enviar ${amount} moedas e uma mensagem para TODOS os ${usersSnapshot.size} jogadores? Esta ação não pode ser desfeita.`)) {
                return;
            }

            usersSnapshot.forEach(doc => {
                const userRef = db.collection('users').doc(doc.id);
                const inboxRef = userRef.collection('inbox').doc();

                // MODIFICADO: Cria a mensagem final para o usuário
                let finalMessage = '';
                if (amount > 0) {
                    finalMessage += `Você recebeu ${amount} Snake Coins! 🪙\n\n`;
                }
                finalMessage += customMessage; // Adiciona a mensagem do admin

                // Adiciona a atualização de moedas (se houver)
                if (amount > 0) {
                    batch.update(userRef, { snakeCoins: firebase.firestore.FieldValue.increment(amount) });
                }

                // Adiciona a mensagem formatada à caixa de entrada do usuário
                batch.set(inboxRef, {
                    message: finalMessage, // Salva a mensagem completa
                    timestamp: firebase.firestore.FieldValue.serverTimestamp(),
                    isRead: false
                });
            });

            await batch.commit();

            alert(`Sucesso! ${amount} moedas e uma mensagem foram enviadas para ${usersSnapshot.size} jogadores.`);
            amountInput.value = '';
            messageInput.value = '';

        } catch (error) {
            console.error("Erro ao enviar recompensa coletiva:", error);
            alert("Ocorreu um erro ao enviar a recompensa. Verifique o console para mais detalhes.");
        }
    }

    // ==================================================================
    // FUNÇÕES DA CAIXA DE ENTRADA DO JOGADOR
    // ==================================================================
    let unreadMessagesCount = 0;

    function listenToInbox(userId) {
        if(inboxListener) inboxListener(); // Remove o listener antigo se houver

        inboxListener = db.collection('users').doc(userId).collection('inbox')
            .onSnapshot(snapshot => {
                unreadMessagesCount = 0;
                snapshot.forEach(doc => {
                    if (!doc.data().isRead) {
                        unreadMessagesCount++;
                    }
                });
                updateInboxNotification();
            }, error => {
                console.error("Erro ao escutar a caixa de entrada: ", error);
            });
    }

    function updateInboxNotification() {
        const notification = document.getElementById('inboxNotification');
        if (unreadMessagesCount > 0) {
            notification.textContent = unreadMessagesCount;
            notification.style.display = 'flex';
        } else {
            notification.style.display = 'none';
        }
    }

    async function openInbox() {
        const user = auth.currentUser;
        if (!user) return;

        const inboxList = document.getElementById('inboxList');
        inboxList.innerHTML = '<p>Carregando mensagens...</p>';
        document.getElementById('inboxModal').style.display = 'flex';

        const messagesRef = db.collection('users').doc(user.uid).collection('inbox').orderBy('timestamp', 'desc');
        const snapshot = await messagesRef.get();
        
        if (snapshot.empty) {
            inboxList.innerHTML = `<p style="text-align: center; opacity: 0.7;">${translations[currentLanguage]['inbox_empty']}</p>`;
            return;
        }

        inboxList.innerHTML = '';
        const batch = db.batch();
        snapshot.forEach(doc => {
            const message = doc.data();
            const date = message.timestamp ? message.timestamp.toDate().toLocaleDateString('pt-BR') : '';
            
            const messageEl = document.createElement('div');
            messageEl.className = 'inbox-message';
            // MODIFICADO: Simplificado para exibir a mensagem que já vem completa
            messageEl.innerHTML = `
                <div class="inbox-message-header">
                    <strong>Mensagem do Sistema</strong>
                    <span>${date}</span>
                </div>
                <p>${message.message}</p>
                <button class="btn btn-danger" style="float: right; margin-top: 10px;" onclick="deleteInboxMessage('${doc.id}')">Apagar</button>
            `;
            inboxList.appendChild(messageEl);

            // Marca como lida se não estiver
            if (!message.isRead) {
                const docRef = db.collection('users').doc(user.uid).collection('inbox').doc(doc.id);
                batch.update(docRef, { isRead: true });
            }
        });

        await batch.commit(); // Executa todas as atualizações de 'isRead'
    }

    function closeInbox() {
        document.getElementById('inboxModal').style.display = 'none';
    }
    
    async function deleteInboxMessage(messageId) {
        if (!confirm(translations[currentLanguage]['inbox_delete_confirm'])) return;
        
        const user = auth.currentUser;
        if (!user) return;

        try {
            await db.collection('users').doc(user.uid).collection('inbox').doc(messageId).delete();
            openInbox(); // Recarrega a caixa de entrada para mostrar a mudança
        } catch(error) {
            console.error("Erro ao apagar mensagem:", error);
            alert("Não foi possível apagar a mensagem.");
        }
    }


</script> 
</body>
</html>